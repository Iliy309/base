# Hello, World!—Основы Python

![Hello World](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjE3ODkwMmU0MGQ1OWUwOGNkNGM0MDQ5ZGRiNjMyNjYxLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=735ff96ffbbab0155e9c58e28bb9e367604daf815b964320bec8d3f75468b49a)

Изучение нового языка программирования традиционно начинается с 'Hello, World!'. Это простая программа, которая выводит приветствие на экран и заодно знакомит с новым языком — его синтаксисом и структурой программы.

Этой традиции уже больше сорока лет, поэтому и мы не будем нарушать ее. В первом уроке мы напишем программу `Hello, World!`. Чтобы сделать это, нужно дать компьютеру специальную команду. В языке Python это — `print()`:

```
print('Hello, World!')
# => Hello, World!
```

Чтобы объяснить подробнее, какое значение выводится на экран, мы использовали комментарий.

## Как работают комментарии

Практически все языки программирования позволяют оставлять в коде комментарии. Они никак не используются интерпретатором. Они нужны исключительно для людей, чтобы программист оставлял пометки для себя и для других программистов.

С их помощью добавляют пояснения, как работает код, какие ошибки нужно поправить или не забыть что-то добавить позже:

```
# Удалить строку ниже после реализации задачи по регистрации
print(10)
```

Комментарии в Python начинаются со знака `#` и могут появляться в любом месте программы. Они могут занимать всю строку. Если одной строки мало, то создается несколько комментариев:

```
# For Winterfell!
# For Lannisters!
```

Комментарий может находиться на строке после кода:

```
print('I am the King')  # For Lannisters!
```

# Инструкции—Основы Python


![Инструкции](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjJmNzZmMGI0MWM0MDJmZDRkNmVmMjQ5MGI1YmU4NzExLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=4e254f9117f726135c74daf2a27ecf99f9e3b41e7ca052f2946612a25d2e5390)

Когда мы готовим блюдо, то четко следуем рецепту. Иначе еда окажется не такой, как ожидали. Это же правило действует и в программировании.

Чтобы увидеть на экране ожидаемый результат, нужно дать компьютеру четкие и пошаговые указания. Это можно сделать с помощью инструкций. Инструкция — это команда для компьютера, единица выполнения. Код на Python в этом случае — это набор инструкций. Его можно представить в виде пошагового рецепта.

Код на Python запускает **интерпретатор** — программу, которая выполняет инструкции строго по очереди. Как и шаги в рецепте, наборы инструкций для интерпретатора пишутся по порядку и отделяются друг от друга переходом на следующую строку.

Разработчики должны понимать порядок действий в коде и уметь мысленно разделять программу на независимые части, удобные для анализа.

Посмотрим на пример кода с двумя инструкциями. При его запуске на экран последовательно выводятся два предложения:

```
print('Mother of Dragons.')
print('Dracarys!')
# => Mother of Dragons.
# => Dracarys!
```

Выше мы говорили, что инструкции отделяются друг от друга переходом на новую строку. Но есть и другой способ: их можно разделить точкой с запятой — `;`:

```
print('Mother of Dragons.'); print('Drakarys!')
```

Технической разницы между первым и вторым вариантом нет — интерпретатор поймет инструкции одинаково. Разница только в том, что человеку будет неудобно читать второй вариант.

Лучше инструкции располагать друг под другом. Так коллегам будет удобнее читать ваш код, обслуживать его и вносить изменения.

# Арифметические операции

На базовом уровне компьютеры оперируют только числами. Даже в прикладных программах на высокоуровневых языках внутри много чисел и операций над ними. Но для старта достаточно знать обычную арифметику — с нее и начнем.

![Счетные палочки](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImEzOTQwZjUxMGJlZDFjZDNjNzZkMWE5OTMxZmZhZDEzLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=07d36e4a0a85b815cc11bc799bbc0766fb9d17e0ed71a4f82fc99d3b219a76b6)

Например, для сложения двух чисел в математике мы пишем: `3 + 4`. В программировании — то же самое. Вот программа, которая складывает два числа:

```
3 + 4
```

Арифметика в программировании практически не отличается от школьной арифметики.

Строчка кода `3 + 4` заставит интерпретатор сложить числа и узнать результат. Эта программа будет работать, но в ней нет смысла. По сути, мы не даем команду интерпретатору, мы просто говорим ему: «смотри, сумма трех и четырех». В реальной работе недостаточно сообщать интерпретатору о математическом выражении.

Например, если создавать интернет-магазин, недостаточно просить интерпретатор посчитать стоимость товаров в корзине. Нужно просить посчитать стоимость **И** показать цену покупателю.

Нам нужно попросить интерпретатор сложить `3 + 4` **И** дать команду сделать что-то с результатом. Например, вывести его на экран:

```
# Сначала вычисляется сумма,
# затем она передается в функцию печати
print(3 + 4)  # => 7
```

Кроме сложения доступны следующие операции:

-   `-` — вычитание
-   `*` — умножение
-   `**` — возведение в степень
-   `/` — деление
-   `//` — [целочисленное деление](https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81_%D0%BE%D1%81%D1%82%D0%B0%D1%82%D0%BA%D0%BE%D0%BC#%D0%92_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B8)
-   `%` — [остаток от деления](https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81_%D0%BE%D1%81%D1%82%D0%B0%D1%82%D0%BA%D0%BE%D0%BC)

Теперь выведем на экран результат деления, а потом результат возведения в степень:

```
print(8 / 2)   # => 4.0 (При делении двух чисел получается тип данных float)
print(3 ** 2)  # => 9
print(9 % 2)   # => 1
```

Разберем, как в программировании называются составляющие математических операций.

## Операторы и операнды

Знак операции, такой как `+`, называют **оператором**. Операторы выполняют операции над определенными значениями, которые называются **операндами**. Сами операторы — это обычно один или несколько символов. Реже — слово. Подавляющее большинство операторов соответствуют математическим операциям.

```
print(8 + 2)
```

В этом примере `+` — это оператор, а числа `8` и `2` — это **операнды**.

Когда мы складываем, у нас есть два операнда: один слева, другой справа от знака `+`. Операции, которые требуют наличия двух операндов, называются **бинарными**. Если пропустить хотя бы один операнд, например, `3 +`, то программа завершится с синтаксической ошибкой.

Операции бывают не только бинарными, но и унарными — с одним операндом, и тернарными — с тремя операндами. Причем операторы могут выглядеть одинаково, но обозначать разные операции. Символы `+` и `-` используются не только как операторы. Когда речь идет про отрицательные числа, то знак минуса становится частью числа:

```
print(-3)  # => -3
```

Выше пример применения унарной операции к числу `3`. Оператор минус перед тройкой говорит интерпретатору взять число `3` и найти противоположное, то есть `-3`. Это может сбить с толку, потому что `-3` — это одновременно и число само по себе, и оператор с операндом. Но у языков программирования такая структура.

## Коммутативная операция

«От перемены мест слагаемых сумма не меняется» — это один из базовых законов арифметики, который также называется **коммутативным законом**. Бинарная операция считается коммутативной, если вы получаете тот же самый результат, поменяв местами операнды. В этом случае сложение — это коммутативная операция: `3 + 2 = 2 + 3`.

Но вычитание — это не коммутативная операция: `2 - 3 ≠ 3 - 2`. В программировании этот закон работает точно так же, как в арифметике. Более того, большинство операций, с которыми мы сталкиваемся в реальной жизни, не являются коммутативными. Отсюда вывод: всегда обращайте внимание на порядок того, с чем работаете.

## Композиция операций

Рассмотрим пример:

```
print(2 * 4 * 5 * 10)
```

Операции можно соединять друг с другом и вычислять все более сложные составные выражения. Чтобы представить, как происходят вычисления внутри интерпретатора, разберем пример: `2 * 4 * 5 * 10`.

1.  Сначала вычисляется `2 * 4` и получается выражение `8 * 5 * 10`
2.  Затем `8 * 5`. В итоге имеем `40 * 10`
3.  В итоге происходит последнее умножение, и получается результат `400`

Операции могут содержать разные операторы, из-за чего появляется вопрос об их приоритете.

## Приоритет операций

Представим, что нужно вычислить такое выражение: `2 + 2 * 2`. Именно так и запишем:

```
print(2 + 2 * 2)  # => 6
```

В школьной математике есть понятие «приоритет операции». Приоритет определяет, в какой последовательности должны выполняться операции. Умножение и деление имеют больший приоритет, чем сложение и вычитание, а приоритет возведения в степень выше всех остальных арифметических операций. Например: `2 ** 3 * 2` вычислится в `16`.

Но нередко вычисления должны происходить в порядке, отличном от стандартного приоритета. Тогда приоритет нужно задавать круглыми скобками. Так было и в школе, например: `(2 + 2) * 2`. Скобки можно ставить вокруг любой операции. Они могут вкладываться друг в друга сколько угодно раз. Вот примеры:

```
print(3 ** (4 - 2))  # => 9
print(7 * 3 + (4 / 2) - (8 + (2 - 1)))  # => 14
```

Главное при этом соблюдать парность — закрывать скобки в правильном порядке. Это часто становится причиной ошибок не только у новичков, но и у опытных программистов. Для удобства ставьте сразу открывающую и закрывающую скобку, а потом пишите внутреннюю часть. Редактор на нашем сайте (и большинство других редакторов кода) делают это автоматически: вы пишете `(`, а редактор сразу добавляет `)`. Это касается и других парных символов, например, кавычек. О них поговорим в будущих уроках.

Иногда выражение сложно воспринимать визуально. Тогда можно расставить скобки, не повлияв на приоритет:

```
# Было
print(8 / 2 + 5 - -3 / 2)  # => 10.5

# Стало
print(((8 / 2) + 5) - (-3 / 2))  # => 10.5
```

Важно запомнить: код пишется для людей. Код будут читать люди, а машины будут только исполнять его. Для машин код — корректный или некорректный. Для них нет «более» понятного или «менее» понятного кода.

# Ошибки оформления — синтаксис и линтер
Если программа на Python написана синтаксически некорректно, то интерпретатор выводит на экран соответствующее сообщение. Также он указывает на файл и строчку, где произошла ошибка.

**Синтаксическая ошибка** возникает в том случае, когда код записали с нарушением грамматических правил. В естественных языках грамматика важна, но текст с ошибками обычно можно понять и прочитать. В программировании все строго. Мельчайшее нарушение — и программа даже не запустится. Примером может быть забытая `;`, неправильно расставленные скобки и другие детали.

Вот пример кода с синтаксической ошибкой:

```
print('Hodor)
```

Если запустить код выше, то мы увидим следующее сообщение:

```
$ python index.py
File "index.py", line 1
    print('Hodor)
                            ^
SyntaxError: EOL while scanning string literal
```

С одной стороны, ошибки синтаксиса — самые простые, потому что они связаны с грамматическими правилами написания кода, а не со смыслом кода. Их легко исправить: нужно лишь найти нарушение в записи. С другой стороны, интерпретатор не всегда может четко указать на это нарушение. Поэтому бывает, что забытую скобку нужно поставить не туда, куда указывает сообщение об ошибке.

## Ошибки линтера

Мы уже научились писать простые программы, и поэтому можно немного поговорить о том, как писать их правильно.

Код нужно оформлять определенным образом, чтобы он был понятным и простым в поддержке. Существуют специальные наборы правил, которые описывают различные аспекты написания кода — их называют **стандартами кодирования**. В Python стандарт один — [PEP8](https://www.python.org/dev/peps/pep-0008/). Он отвечает практически на все вопросы о том, как оформлять ту или иную часть кода. Этот документ содержит все правила, которых нужно придерживаться. Новичкам мы советуем завести привычку заглядывать в стандарт PEP8 и писать код по нему.

Сегодня не нужно помнить все правила из стандарта, потому что существуют специальные программы, которые проверяют код автоматически и сообщают о нарушениях. Такие программы называются **линтерами**. Они проверяют код на соответствие стандартам. В Python их достаточно много, и наиболее популярный из них — [flake8](https://flake8.pycqa.org/en/latest/).

Взгляните на пример:

```
result = 1+ 3
```

Линтер будет ругаться на нарушение правила: _E225 missing whitespace around operator_. По стандарту, все операторы всегда должны отделяться пробелами от операндов.

Выше мы увидели правило [E225](https://www.flake8rules.com/rules/E225.html) — это одно из большого количества правил. Другие правила описывают отступы, названия, скобки, математические операции, длину строчек и множество иных аспектов. Каждое отдельное правило кажется неважным и мелким, но вместе они составляют основу хорошего кода. Список всех правил flake8 доступен [в этой документации](https://www.flake8rules.com/).

Вы уже знакомы с линтером, потому что в практических заданиях платформа Хекслета проверяет ваш код с помощью него. Скоро вы начнете использовать его и за пределами Хекслета, когда будете реализовывать учебные проекты. Вы настроите линтер, и он будет проверять код уже в реальной разработке и сообщать вам о нарушениях.

# Строки
![Строки](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImY5NzBiOTQzYTAyYmU5NGE1ZGFiMTMzMzc1MzY5ZmYzLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=3bcf7507b11ef1309c85c964b96be287447a65d8dde7ebc2049cd201359f2734)

В этом уроке мы разберемся, что такое строка и какую роль в коде играют кавычки. Мы познакомимся со специальными символами и научимся их применять.

Определить строку довольно просто — это некий набор символов. Представим, что у нас есть такие записи:

```
'Hello'
'Goodbye'
'G'
' '
''
```

Какие из этих вариантов — строки? На самом деле, все пять вариантов подходят:

-   С `'Hello'` и `'Goodbye'` все очевидно — мы уже работали с подобными конструкциями и называли их строками
-   `'G'` и `' '` — тоже строки, просто в них всего по одному символу
-   `''` — это пустая строка, потому в ней ноль символов

## Кавычки

Строкой мы считаем все, что находится внутри кавычек: даже если это пробел, один символ или вообще отсутствие символов.

Выше мы записывали строки в одинарных кавычках, но это не единственный способ. Можно использовать и двойные:

```
print("Dracarys!")
```

Теперь представьте, что вы хотите напечатать строчку _Dragon's mother_. Апостроф перед буквой **s** — это такой же символ, как одинарная кавычка. Попробуем:

```
print('Dragon's mother')
# SyntaxError: invalid syntax
```

Такая программа не будет работать. С точки зрения Python строчка началась с одинарной кавычки, а потом закончилась после слова **dragon**. Дальше были символы `s mother` без кавычек — значит, это не строка. А потом была одна открывающая строку кавычка, которая так и не закрылась: `')`. Этот код содержит синтаксическую ошибку — это видно даже по тому, как подсвечен код.

Чтобы избежать этой ошибки, мы используем двойные кавычки. Такой вариант программы сработает верно:

```
print("Dragon's mother")
```

Теперь интерпретатор знает, что строка началась с двойной кавычки и закончиться должна тоже на двойной кавычке. А одинарная кавычка внутри стала частью строки.

Верно и обратное. Если внутри строки мы хотим использовать двойные кавычки, то саму строку надо делать в одинарных. Причем количество кавычек внутри самой строки неважно.

Теперь представим, что мы хотим создать такую строку:

```
Dragon's mother said "No"
```

В ней есть и одинарные, и двойные кавычки. Нам нужно каким-то образом указать интерпретатору, что кавычки — это один из символов внутри строки, а не начало или конец строки.

Для этого используют **символ экранирования**: `\` — обратный слэш. Если мы поставим `\`перед кавычкой (одинарной или двойной), то интерпретатор распознает кавычку как обычный символ внутри строки, а не начало или конец строки:

```
# Экранируем кавычки вокруг No, чтобы интерпретатор
# распознал их как часть строки
print("Dragon's mother said \"No\"")
# => Dragon's mother said "No"
```

Обратите внимание, что в примере выше нам не пришлось экранировать одинарную кавычку (апостроф 's), потому что сама строка создана с двойными кавычками. Если бы строка создавалась с одинарными кавычками, то символ экранирования нужен был бы перед апострофом, но не перед двойными кавычками.

Если нужно вывести сам обратный слеш, то работает такое же правило. Как и любой другой специальный символ, его надо экранировать:

```
print("\\")
# => \
```

## Экранированные последовательности

Мы хотим показать вот такой диалог:

```
- Are you hungry?
- Aaaarrrgh!
```

Попробуем вывести на экран строку с таким текстом:

```
print("- Are you hungry?- Aaaarrrgh!")
# => - Are you hungry?- Aaaarrrgh!
```

Как видите, результат получился не такой, как мы хотели. Строки расположились друг за другом, а не одна ниже другой. Нам нужно как-то сказать интерпретатору «нажать на Enter» — сделать перевод строки после вопросительного знака. Это можно сделать с помощью символа `\n`:

```
print("- Are you hungry?\n- Aaaarrrgh!")
# => - Are you hungry?
# => - Aaaarrrgh!
```

`\n` — это пример **экранированной последовательности** (escape sequence). Такие последовательности еще называют управляющими конструкциями. Их нельзя увидеть в том же виде, в котором их набрали.

Набирая текст в Word, вы нажимаете на Enter в конце строчки. Редактор при этом ставит в конец строчки специальный невидимый символ, который называется LINE FEED (LF, перевод строчки). В некоторых редакторах можно даже включить отображение невидимых символов. Тогда текст будет выглядеть примерно так:

```
- Привет!¶
- О, привет!¶
- Как дела?
```

Устройство, которое выводит соответствующий текст, учитывает этот символ. Например, принтер при встрече с LF протаскивает бумагу вверх на одну строку, а текстовый редактор переносит весь последующий текст ниже, также на одну строку.

Существует несколько десятков таких невидимых символов, но в программировании часто встречаются всего несколько. Кроме перевода строки, к таким символам относятся:

-   табуляция `\t` — разрыв, который получается при нажатии на кнопку Tab
-   возврат каретки `\r` — работает только в Windows

Распознать такую управляющую конструкцию в тексте можно по символу `\`. Программисты часто используют перевод строки `\n`, чтобы правильно форматировать текст. Например, напишем такой код:

```
print("Gregor Clegane\nDunsen\nPolliver\nChiswyck")
```

Тогда на экран выведется:

```
Gregor Clegane
Dunsen
Polliver
Chiswyck
```

Когда работаете с символом перевода, учитывайте следующие моменты:

1.  Не важно, что стоит перед или после `\n`: символ или пустая строка. Перевод обнаружится и выполнится в любом случае
    
2.  Строка может содержать только `\n`:
    
    ```
    print('Gregor Clegane') # Строка с текстом
    print("\n") # Строка с невидимыми символами перевода строки
    print('Dunsen') # Строка с текстом
    ```
    
    Программа выведет на экран:
    
    ```
    Gregor Clegane
    
    Dunsen
    ```
    
3.  В коде последовательность `\n` выглядит как два символа, но с точки зрения интерпретатора — это один специальный символ
    
4.  Если нужно вывести `\n` как текст (два отдельных печатных символа), то можно воспользоваться экранированием — добавить еще один `\` в начале. Последовательность `\\n` отобразится как символы `\` и `n`, которые идут друг за другом:
    

```
print("Joffrey loves using \\n")
# => Joffrey loves using \n
```

В Windows для перевода строк по умолчанию используется `\r\n`. Такая комбинация хорошо работает только в Windows, но создает проблемы при переносе в другие системы. Например, когда в команде разработчиков есть пользователи Linux.

Дело в том, что последовательность `\r\n` имеет разную трактовку в зависимости от выбранной кодировки, о чем мы поговорим позже. По этой причине в среде разработчиков принято всегда использовать `\n` без `\r`.

В таком случае перевод строки всегда трактуется одинаково и отлично работает в любой системе. Не забудьте настроить ваш редактор на использование `\n`.

## Конкатенация

В веб-разработке программы постоянно оперируют строками. Все, что мы видим на сайтах, так или иначе представлено в виде текста. Этот текст чаще всего динамический — то есть он получается из разных частей, которые соединяются вместе.

Чтобы соединить строки, нужно выполнить **конкатенацию**:

```
# Оператор такой же, как и при сложении чисел,
# но здесь он имеет другой смысл (семантику)
print('Dragon' + 'stone')  # => Dragonstone
```

Склеивание строк всегда происходит в том же порядке, в котором записаны операнды. Левый операнд становится левой частью строки, а правый — правой. Вот еще несколько примеров:

```
print('Kings' + 'wood')      # => Kingswood
print('Kings' + 'road')      # => Kingsroad
print("King's" + 'Landing')  # => King'sLanding
```

Как видите, строки можно склеивать, даже если их записали с разными кавычками.

Пробел — такой же символ, как и другие, поэтому сколько пробелов поставите в строке, столько и получится в итоговой строке:

```
# Ставим пробел в левой части
print("King's " + 'Landing')  # => King's Landing

# Ставим пробел в правой части
print("King's" + ' Landing')  # => King's Landing
```

# Переменные

## Как создать переменную

Представьте, что нам нужно напечатать на экран фразу _Father!_ два раза. Эту задачу можно решить так:

```
print('Father!')
print('Father!')
```

В простейшем случае так и стоит поступить. Но если фраза _Father!_ будет использоваться чаще двух раз, да еще и в разных частях программы, то придется ее везде повторять — это неудобно. Проблемы с таким подходом начнутся, когда понадобится изменить фразу, а такое происходит довольно часто. Нам придется найти все места с этой фразой и выполнить необходимую замену.

А можно поступить по-другому. Чтобы не копировать выражение, достаточно создать с ним переменную:

```
# greeting - переводится как приветствие
greeting = 'Father!'
print(greeting)
print(greeting)
# => Father!
# => Father!
```

![Определение переменной](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjU2ODhlZjM3OTAxMWFiNmZjNWFiZGUxYjZmZmZkOGIzLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=5c77bf70326506d54a6133bff53b19a933ea6fafce8b8bfcec1c632fee87d678)

В строчке `greeting = 'Father!'` мы берем переменную с именем `greeting` и присваиваем ей значение `'Father!'`. Переменная указывает на данные, которые в нее записали. Благодаря этому, данные можно использовать многократно и не дублировать их постоянно.

Когда переменная создана, можно ее использовать. Она подставляется в те места, где раньше стояла наша фраза. Когда код выполняется, интерпретатор доходит до строчки `print(greeting)` и подставляет содержимое переменной, а затем выполняет код.

Для имени переменной используется любой набор допустимых символов, к которым относятся буквы английского алфавита, цифры и знак `_`. При этом цифру нельзя ставить в начале. Имена переменных регистрозависимы, то есть имя `hello` и имя `HELLO` — это два разных имени для двух разных переменных. Регистр в Python имеет важное значение, никогда не забывайте про него.

Количество создаваемых переменных неограниченно. Большие программы содержат десятки и сотни тысяч имен переменных. Вот как выглядят две переменные внутри одной программы:

```
greeting1 = 'Father!'
print(greeting1)
print(greeting1)

greeting2 = 'Mother!'
print(greeting2)
print(greeting2)
```

Чтобы программу было удобно читать, среди программистов принято создавать переменные как можно ближе к тому месту, где они используются. Теперь нужно разобраться, как их изменять.

## Как изменить переменную

Само слово «переменная» подсказывает, что ее можно менять. И действительно, со временем внутри программы значения переменных могут изменяться.

Например:

```
# greeting - переводится как приветствие
greeting = 'Father!'
print(greeting)  # => Father!

greeting = 'Mother!'
print(greeting)  # => Mother!
```

Имя осталось тем же, но внутри появились другие данные. Отметим, что переменные в Python не требуют специального объявления. Вместо этого переменная объявляется, когда ее впервые используют в программе.

Переменные — мощная и в то же время рисковая вещь. Нельзя сразу с уверенностью сказать, что внутри нее записано — сначала надо проанализировать код, который находится перед переменной. Именно этим занимаются разработчики во время отладки, когда пытаются разобраться, почему программа работает не так, как задумано.

## Какие ошибки часто допускают с переменными

Порядок инструкций в коде с переменными имеет огромное значение. Поэтому переменную нужно определить до первого использования. Ниже пример ошибки, которую часто допускают новички:

```
print(greeting)
greeting = 'Father!'
```

Запуск программы выше завершается с ошибкой `NameError: name 'greeting' is not defined`— это ошибка обращения. Это значит, что в коде используется имя (идентификатор), которое пока не определено. Это говорится в самом тексте ошибки: `'greeting' is not defined`. Кроме неправильного порядка действий, в Python встречаются банальные опечатки в имени переменной. Это происходит и когда переменная используется, и когда ее объявляют.

Количество подобных ошибок можно уменьшить, если использовать правильно настроенный редактор. Он предупреждает о возможных проблемах и подсвечивает переменные, которые используются без объявления.

С переменными мы разобрались. Можно переходить к данным, которые никогда не меняются.

## Как работают константы

Некоторые данные никогда не меняются — например, математические постоянные. Возьмем для примера число π. Оно всегда равно 3.14 и не может измениться. Чтобы обратиться к подобным данным, в Python используют константы:

```
PI = 3.14
print(PI)  # => 3.14
```

Константа создается так же, как переменная. Разница только в том, что константы принято именовать заглавными буквами и с `_` в качестве разделителя между словами. Константа, как и переменная, может использоваться в любом выражении.

# Выражения в определениях

Мы уже разобрались, как работать с переменными, чтобы хранить и переиспользовать информацию. Но еще они помогают упрощать сложные вычисления. Например, конвертация валюты или составление нового слова. Рассмотрим, как это делать на практике.

## Сложные вычисления через переменную

Представим, что нам нужно перевести евро в рубли через доллары. Подобные конвертации через промежуточную валюту часто делают банки при покупках за рубежом.

Для начала переведем 50 евро в доллары. Допустим, что один евро — 1.25 долларов:

```
dollars_count = 50 * 1.25
print(dollars_count)  # => 62.5
```

Здесь в переменную `dollars_count = 50 * 1.25` справа от знака «равно» мы записываем **выражение**. Интерпретатор вычислит результат (`62.5`) и запишет его в переменную. Интерпретатору не важно, в каком виде записаны данные: `62.5` или `50 * 1.25`. Для него оба варианта — выражения, которые надо вычислить. Он проводит вычисления и приходит к одному и тому же значению — `62.5`.

Python различает выражения (expression) и инструкции (statements). 

Выражение — это любой корректный блок кода, который возвращает значение. Конкатенация строк (склеивание значений переменных) — это тоже выражение. Когда интерпретатор видит выражение, он обрабатывает его и генерирует результат — **значение выражения**.

Вот несколько примеров выражения. В комментариях справа от каждого выражения записаны итоговые значения:

```
62.5             # 62.5
50 * 1.25        # 62.5
120 / 10 * 2     # 24.0
int('100')       # 100

'hello'          # hello
'Good' + 'will'  # Goodwill
```

Инструкция — это команда, действие.

`if`, `while`, `for` — примеры инструкций. Они производят или контролируют действия, но не превращаются в значения.

Операция присваивания также является инструкцией, потому что она не возвращает, а связывает имя переменной с заданным значением:

```
a = 42 # это инструкция (statement)
a + 1 # а это выражение
```

В тех местах, где ожидается выражение, можно поставить любое вычисление. Оно может быть не только математическим, но и строковым — как конкатенация. Программа все равно останется работоспособной.

Программы состоят из множества комбинаций выражений. Основываясь на сказанном выше, подумайте, сработает ли такой код:

```
who = "dragon's " + 'mother'
print(who)
```

Такой код выведет на экран строку `dragon's mother`. Если хотите проверить самостоятельно, запустите код на [repl.it](https://repl.it/languages/python3) и поэкспериментируйте.

С помощью переменных можно записывать еще более сложные вычисления. Вернемся к нашей валютной программе. Запишем стоимость доллара в рублях, как отдельную переменную. Вычислим цену 50 евро в долларах, умножив их на `1.25`. Допустим, что 1 доллар — 60 рублей:

```
rubles_per_dollar = 60
dollars_count = 50 * 1.25  # 62.5
rubles_count = dollars_count * rubles_per_dollar  # 3750.0

print(rubles_count)
```

Теперь добавим к выводу текст с помощью конкатенации:

```
rubles_per_dollar = 60
dollars_count = 50 * 1.25  # 62.5
rubles_count = dollars_count * rubles_per_dollar  # 3750.0

# Функция str() превращает число в строку.
# О таких превращениях будет отдельный урок.
print('The price is ' + str(rubles_count) + ' rubles')
# => The price is 3750.0 rubles
```

Любая переменная может быть частью любого выражения. В момент вычисления вместо имени переменной подставляется ее значение.

Интерпретатор вычисляет значение `dollars_count` до того, как эта переменная начнет использоваться в других выражениях. Когда подходит момент использования переменной, Python уже знает значение, потому что вычислил его.

С помощью переменных можно проводить сложные вычисления, а также делать подробный вывод с получившимся значением. Но еще можно получать новые выражения посредством склеивания двух и более значений переменных. За это отвечает конкатенация.

## Переменные и конкатенация

Попробуем использовать переменные с конкатенацией, при этом синтаксически ничего не поменяется. Мы умеем конкатенировать две строки:

```
what = "Kings" + "road"
print(what)  # => Kingsroad
```

Значит, мы сумеем склеить строку и одну переменную, в которой записана строка:

```
first = "Kings"
what = first + "road"

print(what)  # => Kingsroad
```

А еще можно конкатенировать две переменные, в которых записаны строки:

```
first = "Kings"
last = 'road'

what = first + last
print(what)  # => Kingsroad
```

# Именование

![Именование](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImY5YTRmNzA3NWQwZGIxMjZhMmY3YmUzMjNlZDUyMDQ1LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=09c70668b01bf66db451203f74f2b1d88a209560ba42adf7e1a6c9b219c78014)

Мы уже умеем работать с переменными в Python. Но недостаточно знать, как ими пользоваться. Еще важно правильно обозначать переменные, чтобы они считывались верно.

Представьте, что мы задали следующую программу:

```
x = 'Father!'
print(x)
```

С подобной программой мы уже работали, но сейчас в ней изменилось имя переменной на `x`.

Компьютеру без разницы, как мы именуем ту или иную переменную. Названия важны только людям. Обычно программисты гораздо чаще читают чужой код, чем пишут свой. Чтобы коллеги смогли с легкостью прочитать и проанализировать ваш код, нужно понятно называть переменные.

Важно придумать понятное название, которое отражает смысл переменной. При этом важно давать такие имена, которые будут понимать без контекста, без изучения окружающего кода.

Существует общепринятое правило: не используйте транслит для имен — только английский язык. Если вы испытываете сложности с английским, то пользуйтесь переводчиком. Со временем, копаясь в чужом коде, вы научитесь правильно именовать переменные.

Среди разработчиков есть шутка: «Названия переменных — это одна из самых сложных вещей в программировании». Придумывать названия и правда сложно. Например, сложно назвать переменную, в которой хранится _количество неоплаченных заказов от клиентов с задолженностью в предыдущем квартале._

Чтобы проверить себя, попробуйте сделать такое задание:

> Придумайте название для переменной, в которой будет храниться _«количество братьев и сестер короля»_.
> 
> Запишите его в блокноте или отправьте себе на почту. Не указывайте там ничего, кроме названия переменной. А через несколько уроков мы вернемся к этой теме.

Теперь разберем, как придумывать простые и понятные имена переменных.

## Именование переменных

`greeting` — пример простого имени, но не все имена так просты. Часто они включают в себя несколько слов: например, «имя пользователя». В разных языках применяются разные стили кодирования, и имя переменной будет отличаться.

В именовании переменных можно выделить три основных подхода, которые иногда комбинируют друг с другом. Все эти подходы проявляют себя, когда имя переменной состоит из нескольких слов:

-   **kebab-case** — составные части переменной разделяются дефисом (`my-super-var`)
-   **snake_case** — для разделения используется подчеркивание (`my_super_var`)
-   **CamelCase** — каждое слово в переменной пишется с заглавной буквы (`MySuperVar`)

Переменные в Python именуются в стиле `snake_case`: слова записываются строчными буквами и разделяются символом подчеркивания `_`. Чтобы разобраться подробнее, можете изучить раздел [«Как называть переменные»](https://www.python.org/dev/peps/pep-0008/#naming-conventions) в стандарте PEP8.

Далее посмотрим пример плохих практик и разберем, почему их стоит избегать.

## Магические числа

Возьмем пример программы, которая считает курс валют:

```
euros_count = 1000
dollars_count = euros_count * 1.25  # 1250.0
rubles_count = dollars_count * 60   # 75000.0

print(rubles_count)
```

С точки зрения профессиональной разработки, такой код не соответствует «лучшим практикам» — best practices.

В этом примере сложно понять, что значат числа `60` и `1.25`. Представьте, что вам придется разбираться в этом коде через месяц или через год — это будет сложно. Также сложно будет программисту, который не видел код ранее.

В нашем примере контекст легко восстановить, потому что переменные названы грамотно. Но в реальных проектах код значительно сложнее, поэтому догадаться до смысла чисел зачастую невозможно.

Проблема кроется в «магических числах» — magic numbers. Это числа, происхождение которых невозможно понять с первого взгляда — приходится глубоко вникать в то, что происходит в коде.

Чтобы предотвратить проблему, нужно создавать переменные с правильными именами. Так все встанет на свои места:

```
dollars_per_euro = 1.25
rubles_per_dollar = 60

euros_count = 1000
dollars_count = euros_count * dollars_per_euro     # 1250.0
rubles_count = dollars_count * rubles_per_dollar  # 75000.0

print(rubles_count)
```

В этой программе:

-   Используется именование snake_case
-   Две новые переменные отделяются от последующих вычислений пустой строчкой. Эти переменные имеют смысл и без вычислений, поэтому такое отделение уместно, потому что повышает читаемость
-   Получился хорошо именованный и структурированный код, но он длиннее прошлой версии. Так часто бывает — это нормально, ведь код должен быть читабельным

Магические числа и непонятные именования переменных не ломают код, но делают его менее читабельным.

Нужно понимать, что компьютер в любом случае выполнит заданное вычисление. Однако другой программист будет читать код и ничего не поймет — это усложнит работу. Правильное именование переменных — половина успеха анализа кода.

# Интерполяция

Вы уже знаете, как перенести строку или «слепить» несколько строк, чтобы получить новое выражение. Но в программировании есть альтернативы этих операций. Они повышают читаемость кода и делают его проще в поддержке.

## Интерполяция

Базовый способ соединения строк — **конкатенация**. С помощью конкатенации строки «суммируются» друг с другом, как в примере ниже:

```
first_name = 'Joffrey'
greeting = 'Hello'

print(greeting + ", " + first_name + "!")
# => Hello, Joffrey!
```

Конкатенация работает просто, но выглядит не всегда наглядно. Из-за кавычек сложно разглядеть то, каким будет конечный результат. И чем сложнее устроена строка, тем запутаннее она начнет выглядеть. У конкатенации есть альтернатива — **интерполяция**. Вот как это выглядит:

```
first_name = 'Joffrey'
greeting = 'Hello'

print(f'{greeting}, {first_name}!')
# => Hello, Joffrey!
```

Буква `f` указывает на то, что мы создаем **f-строку** — шаблон, в который с помощью фигурных скобок подставляются значения переменных. На выходе получается обычная строка.

Рассмотрим такой пример:

```
school = 'Hexlet'

what_is_it = f'{school} - online courses'
print(what_is_it)  # => Hexlet - online courses
```

Почти во всех языках для объединения строк интерполяция предпочтительнее конкатенации. Строка при этом получается склеенная, и внутри нее хорошо просматриваются пробелы и другие символы.

Интерполяция помогает сделать код более понятным для разработчиков. Но это не единственная полезная альтернатива, о которой мы хотели рассказать. Далее разберемся, как объявлять многострочную строку и не использовать `\n`.

## Multi-line строки

Представьте, что нам нужно определить строку, которая состоит из нескольких строчек — то есть внутри есть переводы строки `\n`. Например, она будет выглядеть так:

```
text = 'Пример текста,\nсостоящего из\nнескольких строк'
```

На печати строка примет совсем другой вид:

```
Пример текста,
состоящего из
нескольких строк
```

Для таких ситуаций в Python есть еще один способ создания строк, который называется **multi-line строки**. Чтобы описать такую «многострочную строку», нужно заключить ее в тройные кавычки — `"""` или `'''`. Внутри multi-line строки можно переносить текст и не использовать перевод строки `\n`:

```
text = '''Пример текста,
состоящего из
нескольких строк
'''
```

```
Пример текста,
состоящего из
нескольких строк

```

Обратите внимание, что в конце текста есть пустая строка. Она появилась в тексте потому, что мы поставили закрывающие кавычки `'''` на новой строке. Если не переносить закрывающие кавычки на новую строку, то пустая строка в тексте не появится:

```
text = '''Пример текста,
состоящего из
нескольких строк'''
```

```
Пример текста,
состоящего из
нескольких строк
```

Из-за тройных кавычек multi-line строки позволяют не экранировать кавычки внутри строки:

```
Здесь не нужно экранировать 'одинарные' и "двойные" кавычки
```

Еще multi-line строки могут становиться f-строками для интерполяции:

```
a = 'A'
b = 'B'

# Слева добавился f
text = f'''{a} и {b}
сидели на трубе
'''
```

```
А и B
сидели на трубе

```

Для компьютера не важно, какие способы соединения и переноса строк вы будете использовать. Он все равно произведет вычисления и выдаст нужный результат. Интерполяция и multi-line строки используются для удобства разработчиков, чтобы им было проще читать код.

# Извлечение символов из строки

Иногда нужно получить один символ из строки. Например, если сайт знает имя и фамилию пользователя, и в какой-то момент требуется вывести эту информацию в формате _A. Ivanov_. Для этого компьютеру потребуется взять первый символ из имени. В Python есть подходящая операция, которую мы изучим сегодня.

## Извлечение элемента по индексу

Представим, что из имени Alexander нужно вывести на экран только первую букву. Это выглядит так:

```
first_name = 'Alexander'

print(first_name[0])  # => A
```

Операция с квадратными скобками с цифрой извлекает элемент по **индексу** — позицией символа внутри строки. Индексы начинаются с 0 почти во всех языках программирования. Поэтому, чтобы получить первый символ, нужно указать индекс `0`. Индекс последнего элемента равен длине строки минус единица. Обращение к индексу за пределами строки приведет к ошибке:

```
# Длина строки 9, поэтому последний индекс — это 8
first_name = 'Alexander'

print(first_name[8])  # => r

print(first_name[9])
IndexError: string index out of range
```

Чтобы лучше закрепить новые знания, посмотрите на код ниже и подумайте, что он выдаст:

```
magic = '\nyou'
print(magic[1])  # => ?
```

Бывают и нестандартные ситуации. Например, нужно вывести элемент из конца, причем из выражения с большим количеством символов. В этом случае можно воспользоваться отрицательным индексом, который облегчит работу программиста.

## Отрицательные индексы

Допустимо использовать отрицательные индексы. В этом случае идет обращение к символам, начиная с конца строки. `-1` — индекс последнего символа, `-2` — предпоследнего и так далее. В отличие от прямой индексации, обратный отсчет идет от `-1`:

```
first_name = 'Alexander'

print(first_name[-1])  # => r
```

Индексом может быть не только конкретное число, но и значение переменной. Посмотрите на пример ниже. Здесь мы записали индекс внутри квадратных скобок не числом, а переменной. Такой код приведет к тому же результату — выводу на экран символа _A_:

```
first_name = 'Alexander'
index = 0

print(first_name[index])  # => A
```

Чтобы выводить из выражения лишь некоторые символы, не нужно писать большое количество строк кода — достаточно извлечь элемент с помощью индекса. Также можно пользоваться отрицательным индексом, чтобы легче выводить символы с конца выражения. Далее разберемся, как с помощью этих знаний можно извлекать подстроки из строки.