*Сессия в http =  запрос-ответ 
```bush 
ping google.com  
PING google.com (74.125.205.102): 56 data bytes

Команда telnet выполняет команду ping, берет хост 74.125.205.102 и проводит процедуры дальше 

К сожалению telnet  на mac  урезали
```

В http  имеются глаголы. Один из них **HEAD** - он передает загаловки без боди 

>[!notes]
>Почему порт имеет номер 80? Это общепринятое соглашение. Сайты, доступные по HTTP, доступны на порту 80, а по HTTPS – на порту 443. Именно поэтому в браузерах порты не указываются, браузер подставляет их автоматически.

# HTTP 1.0
```Trying 74.125.205.102...

Connected to le-in-f102.1e100.net.

Escape character is '^]'.

HEAD / HTTP/1.0

User-Agent: google         

  
##Версия протокола - код ответа - месседж 
HTTP/1.0 200 OK
##Все осттальное заголовки 
Content-Type: text/html; charset=ISO-8859-1

P3P: CP="This is not a P3P policy! See g.co/p3phelp for more info."

Date: Wed, 01 Mar 2023 17:48:57 GMT

Server: gws

X-XSS-Protection: 0

X-Frame-Options: SAMEORIGIN

Expires: Wed, 01 Mar 2023 17:48:57 GMT

Cache-Control: private

Set-Cookie: 1P_JAR=2023-03-01-17; expires=Fri, 31-Mar-2023 17:48:57 GMT; path=/; domain=.google.com; Secure

Set-Cookie: AEC=ARSKqsLJJxEwjhAGRFzSxNlCktoeDyMtP7y9MI74RSE4Twbk6RZop2YS9g; expires=Mon, 28-Aug-2023 17:48:57 GMT; path=/; domain=.google.com; Secure; HttpOnly; SameSite=lax

Set-Cookie: NID=511=f7pVClloG-OWorbbR3IfC0ycLsitkLa-_Ofpjajpz2bfQpg0pA6JXAlrrJypzE22h5p68-KgfPy3Maqbs1Cm2zgUupbA3_ToiVdcDDQ22zw5-SFYI3FwcBoI4vryJK9AyHsRBN0ShIeCHJKPpbUNcLpnzf1fQH9GuvtlAOkuZ6c; expires=Thu, 31-Aug-2023 17:48:57 GMT; path=/; domain=.google.com; HttpOnly
Connection closed by foreign host.
```

В конце мы видим одну интересную деталь: _Connection closed by foreign host._ Запрос соединения был закрыт внешним хостом. Так работает практически все в интернете. Обычно сервера настроены на 30-секундный интервал и закрывают соединение, если в течение этого интервала ничего не приходит.

# HTTP 1.1
Протокол HTTP 1.1 расширяет возможности предыдущей версии и добавляет виртуальные хосты

```GET / HTTP/1.1  host: hexlet.io
У меня терминал не выдал боди. Хз чо происходит на мак 

HTTP/1.1 301 Moved Permanently               СТРОКА ЗАПРОСА
Cache-Control: private                       ЗАГОЛОВКИ
Content-Type: text/html; charset=UTF-8          -
Referrer-Policy: no-referrer                    -
Location: https://34.102.241.4/                 -
Content-Length: 218                             -
Date: Tue, 07 Jul 2020 03:50:16 GMT             -
                                              ПУСТАЯ СТРОКА
<HTML><HEAD><meta http-equiv="content-type"|  Боди ДО КОНЦА content="text/html;charset=utf-8">
<TITLE>301 Moved</TITLE></HEAD><BODY>
<H1>301 Moved</H1>
The document has moved
<A HREF="https://34.102.241.4/">here</A>.
</BODY></HTML
```

Предыдущая версия требует наличия только _request line_. В ней мы описываем, какой путь на сайте мы хотим посмотреть. Но упоминания сайта как такового здесь нет. При этом мы подключаемся по telnet к конкретному IP адресу. Отсюда можно сделать вывод, что понятие домена (доменного имени) при использовании HTTP 1.0 неважно. Действительно, эта версия была создана в те времена, когда считалось, что один IP адрес соответствует одному сайту. Естественно это не могло продолжаться долго, потому что рост интернета был стремительным. И HTTP 1.1 ввел такое понятие как виртуальные хосты. С точки зрения реализации в протоколе HTTP появилась одна небольшая деталь. Кроме request line стал обязательным еще и заголовок, который называется host. Он определяет, какой именно домен должен быть возвращен с этого IP адреса.

Eсть много разных кодов ответа. В итоге мы получили ответ, код которого отличается от 200. Здесь есть еще одна интересная деталь, которая введена в HTTP 1.1. После выполнения запроса мы не выпали из telnet и не оказались в bash. Это значит, что подключение не было закрыто, и мы можем продолжить вводить данные.

Мы также можем указать, что хотим закрыть соединение. Для этого после установки соединения и передачи стандартных заголовков нужно передать еще один заголовок. Он называется `connection: close`. Тогда _keep-alive_ будет отключен, и после получения ответа мы увидим сообщение, что хост закрыл соединение: _Connection closed by foreign host_.

Во время отправки ответа сервер формирует специальный заголовок, который называется _Content-Length_. Это и есть ключ к тому как работать с _body_. Перед тем как отправить тело ответа, происходит вычисление его длины и записывается количество байт.

```
# число — количество байт
Content-Length: 218
```

После того, как передан такой заголовок, другая сторона будет ожидать ровно столько байт, сколько в нем указано. Как мы помним, для _response_ и _request_ это работает абсолютно одинаково. После того как был передан последний символ, соединение закрывается. Стоит уточнить, что закрывается именно HTTP-сессия. На сервере может быть активен _keep-alive_, но ключевой момент в том, что запрос считается завершенным и отображается.

>[!warning]
>Еще одно замечание по поводу _body_. С точки зрения стандарта _HTTP_ тело может присутствовать в любом запросе и никак не связано с глаголом. Посылать _body_ можно в _HEAD_, _POST_, _PUT_ и других запросах. Если мы посылаем _body_ с _GET_, хотя это не описано в стандарте, сервер никак не будет на это реагировать, более того, он и не должен, так как с практической точки зрения это не имеет смысла. Также есть типы запросов, при которых он не будет посылать в ответ _body_ ни в коем случае. Например, ответ на _HEAD_, когда мы запрашиваем только заголовки, так как такова семантика этого глагола. Еще тело не отправляется, когда мы получаем в ответ такие статусы как 204 — нет контента и некоторые другие.

>[!summary] Что-то я не понял 
>Практика показывает, что не все серверы правильно работают при наличии только заголовка _Content-Length_. Им не хватает еще одного. Тип содержимого запроса или ответа, которое содержит _body_, должен быть как-то идентифицирован. По умолчанию в стандарте сказано, что сервер может сам попытаться определить содержимое контента на основе различных способов. Например, мы в _query string_ делаем запрос _image.png_.
>
POST /image.png HTTP/1.1
>
>Совсем не обязательно, но сервер может понять, что это картинка в формате png, и как-то это использовать. Во всех остальных случаях, когда сервер не может определить тип контента, он должен использовать заголовок _Content-Type: application/octet-stream_. Это означает, что в теле запроса передается просто поток байт. Хотя серверы должны работать именно так, но часто все происходит по другому. Если указан только _Content-Length_, то сервер отказывается принимать данные. Он просто закрывает соединение после двух переводов строки, еще до _body_. Этот нюанс выяснен экспериментальным путем.

# Особенности отправки форм 
Формы — это элементы HTML _навернео не только хтмл_, которые применяются для сбора информации от посетителей веб-сайта. К ним относятся текстовые поля для ввода данных с клавиатуры, списки для выбора предопределенных данных, флажки для установки параметров. 

При отправке формы мы отправляем какие-то данные. Так как в HTTP не предусмотрены специальные места для отправки данных из форм, они отправляются в теле запроса. При этом в зависимости от того, какой заголовок _Content-Type_ установлен, интерпретируется то, как будут закодированы данные при отправке. Обычно используется следующий формат _Content-Type: application/x-www-form-urlencoded_. Это простой формат — ключ равно значение и амперсанд между ними.

Есть еще несколько особенностей, которые нужно знать, когда мы работаем с формами в HTTP. Первая из них связана с кодированием. Поскольку это текстовый формат, то в нем очень легко допустить различные неоднозначности. Предположим в пароле используется знак =
```
login=smith&password=1234=5678
```
Закодированный символ = выглядит так — `%3D` и не важно, какой это запрос: _POST_ или _GET_. Такие закодированные последовательности символов вы можете часто видеть в адресной строке браузера
```
login=smith&password=1234%3D5678
```
Еще одна особенность связана с тем, что иногда нам нужно отправить данные, вложенные друг в друга. Например, массив опций. В таком случае тело может выглядеть так: ```user[login]=smith&user[password]=12345678```
Нюанс в том, что HTTP не умеет работать с такими данными. Их обработкой занимаются *мидлвары (англ. middlewares* — промежуточное программное обеспечение).

``` Вот так происходит запрос 
POST /session/new HTTP/1.1
Host: hexlet.local
Content-Type: application/x-www-form-urlencoded
Content-Length: 30
Connection: close

username=admin&password=secret
```

# JSON 
Помимо обычного кодирования _ключ=значение_ существуют и другие форматы, но самым популярным является формат JSON. У него достаточно много преимуществ, в числе которых:

-   JSON представляет собой строку, что и необходимо при передаче данных по сети
-   Не зависит от языка
-   С его помощью можно описывать сложные иерархические структуры
-   Легко читается человеком

	В данный момент он считается стандартом для обмена информацией между сервисами в интернете. Для отправки данных в этом формате используется заголовок _Content-Type: application/json_.

#  Transfer-Encoding (Чанки)

По [ссылке](https://www.httpwatch.com/httpgallery/chunked/chunkedimage.aspx) находится пример изображения, которое отрисовывается постепенно по мере того, как происходит передача данных. Для этого используется механизм передачи небольшими частями, чанками (англ. chunks), и специальный заголовок _Transfer-Encoding_ со значением _chunked_.

В стандартном ответе мы получаем все _body_ целиком и после этого его обрабатываем. Мы не можем обрабатывать его частями потому, что тогда будем вводить какие-то свои уникальные правила внутри протокола. Но при передаче чанками мы можем обрабатывать ответ до полного получения _body_.
```bush
telnet httpwatch.com 80

GET https://www.httpwatch.com/httpgallery/chunked/chunkedimage.aspx HTTP/1.1
Host: httpwatch.com
Connection: close
```
Заголовки как всегда отделяются от тела запроса переводом строки. В начале каждого чанка указывается его размер. За ним располагаются данные и в конце чанка делается перевод строки, затем идет следующий чанк и так далее. Таким образом можно передавать сколько угодно чанков, время ограничено только таймаутами внутри сервера.

Чтобы завершить передачу, нужно передать последний чанк, который должен быть нулевой длины. После него делается два перевода строки и запрос считается полностью переданным.

>[!note]
>## Формат сообщений
>
Для отделения записей размеров блоков (частей) от их содержания используется разделитель CRLF (как строка: «\r\n»; как байты в формате HEX: 0x0D, 0x0A). Длина блока — это размер содержания блока, разделители CRLF не учитываются.
>
Схематическое представление: `<длина блока в HEX><CRLF><содержание блока><CRLF>`
>
Последний блок строится по той же схеме, потому имеет следующий вид по причине отсутствия содержания: `0<CRLF><CRLF>`
>
[Стандарт](https://tools.ietf.org/html/rfc2616#section-3.7.1) также позволяет использовать в качестве разделителя только CR или только LF.

# _Query string_

![query string](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImMxNTBjNmFmODExY2QzNzRiZWQ2ZTNhZjA0YjcwYWM2LmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=7fd30965aecd2f95d9a43c44c78f763f1af074c9f00c29e0983678c38933869d)

Семантика HTTP-глаголов выражается не только в том, какой вам будет возвращен ответ, а еще и в том, как можно с ним работать. Глагол _GET_ считается **идемпотентным**. Это означает, что его повторное выполнение всегда возвращает один и тот же результат, т.е. это обычный запрос. Мы спрашиваем систему о чем-то, она возвращает нам данные и при этом не изменяет своего внутреннего состояния. Таким образом любой повторный запрос отработает точно так же — **детерминировано**

_POST_-запрос, напротив, не является идемпотентным и предназначен для изменения данных. Таким образом повторный запрос может приводить к другим результатам. Если первым _POST_-запросом мы удаляем данные, то вторым получим ошибку _404_. Такие запросы никогда не кешируются.

# Редиректы (Перенаправления)
![](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjVlODQ2NGFhOGNlMWJhMDc5MmE3NjQ5NWZhMjI3MzM3LmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=f0ec84ad4137b5159a5044fd690bf3351280332dacb45c836974d0416ec7188b)

Возвращается заголовок 300 (формат редиректов). В нашем примере мы видим _301 Moved Permanently_. Это означает, что ресурс, на который послали запрос, перемещен навсегда, и больше не имеет смысла сюда никогда заходить. Этим активно пользуются при SEO. Поисковики сохраняют все параметры страниц по старому адресу в индексе.

Редиректы бывают разных видов, например, временный редирект _302 Found_. Он используется, если что-то произошло: сайт не работает, заблокирован и т.д. В основном это технические истории.

# Базовая аутендификация 
HTTP обладает фичей, которая называется базовая аутентификация. Работает она следующим образом.

![Схема работы базовой аутентификации](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjE2MjViODNiNDg5MzE2NzkwN2Q5Zjg5OWM1MGE3ZDg2LmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=d9237844efca86e3523ca5b51a1e471684648b114a1941153ae53950b56bce6d)
Обычно, если ввести неправильные данные, то браузер запросит их повторно. А если нажать на _Сancel_, то мы получим ошибку с кодом 401. Т.е. при любой попытке зайти на страницу, которая требует базовой авторизации, будет получен ответ 401.

```
GET /securefiles/ HTTP/1.1
Host: www.httpwatch.com
Authorization: Basic aHR0cHdhdGNoDmY=
```

Заголовок _Authorization_, в котором есть обязательное слово `Basic` и после пробела закодированая фраза. Эта фраза состоит из имени пользователя и пароля —  `<username>:<password>`, закодированных в _base64_.
>[!warning]
Для кодировки используется 
printf 'username:password' | base64



# Cookies


![Механизм работы cookie](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImQxNjZkMDc3YTQyZjRkOTY1Mzc2MjljOTU1YzE4NmI3LmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=066e36e7f32aa758d7b151bd1aeb32d7b9cb1d8f63d274f4f5b20e3c7a4ebfa6)

### Сессионные куки

**Сессионные куки** в нашем запросе не устанавливаются, так как мы видим дополнительные параметры в заголовке _set-cookie_. Если бы их не было, то кука называлась бы сессионной. Основное их отличие от постоянных в том, что такая кука удаляется при закрытии браузера. Наглядный пример — это механизм работы галочки «запомнить меня». Если вы авторизуетесь и не отметите эту галочку, а потом закроете браузер и снова зайдете на сайт, то будете не авторизованы. Так происходит потому, что используется сессионная кука.
### Постоянные куки
Они сохраняются на жестком диске — место их хранения может быть разным в зависимости от браузера. Такие куки отличаются от сессионных тем, что можно управлять длиной их жизни при помощи параметра _expires_:

```
expires=Thu, 16-Jul-2020 03:39:50 GMT;
```

В параметре _expires_ указывается дата удаления куки, после которой она не будет отсылаться на сервер. Стоит сказать, что есть еще один параметр, который используется для тех же целей — _MAX-AGE_. В его значении указывается количество секунд, по истечении которых кука будет удалена:

```
MAX-AGE=2592000;
```

Так как часть браузеров не поддерживают _MAX-AGE_, некоторые фреймворки часто устанавливают сразу оба параметра и браузеры просто игнорируют тот, который им не нужен. Таким образом заголовок _set-cookie_, который содержит два параметра _MAX-AGE_ и _expires_, считается валидным. В стандарте также говорится, что регистр имени куки не имеет значения.

Параметры _domain_ и _path_ задают **область видимости куки** — это URL, на которые кука может отправляться. Если они не заданы, то по умолчанию кука будет пересылаться на сервер только для текущего пути и домена. В нашем примере в _path_ указан корень сайта, то есть кука будет отправляться для всех страниц:

```
domain=.hexlet.io; path=/;
```

Обратите внимание на одну важную деталь в этом примере. Если установлен _domain=.hexlet.io_, то кука будет работать не только для всех страниц сайта, но и для всех поддоменов — при этом наличие точки перед именем домена не имеет значения. Если мы совсем не установим параметр _domain_, то кука для поддоменов работать не будет, хотя по умолчанию значение домена будет _hexlet.io_.

Уникальность куки определяется тремя параметрами _key_ (имя куки), _domain_ и _path_. Это значит, что если какую-то куку нужно переустановить, то при следующем запросе в _set-cookie_ эти параметры должны совпадать. Если хотя бы один из них отличается, то будет установлена новая кука.

## HttpOnly cookie

Можно заметить, что в нашем примере установлен дополнительный параметр _HttpOnly_. HttpOnly-куки передаются с AJAX-запросами, но их нельзя получить через JavaScript на странице сайта. Это дополнительный уровень безопасности от XSS-атак.

## Отправка на сервер

Мы обновляем страницу в браузере. После этого происходит отправка следующего заголовка:

```
cookie: GCLB=CLiC7uWajOOrzAE; _hexlet_session2=gu3n8MCidqZ28VfjpzJuF74d4ohla6uYq9Q%2B2XBcalsa3VUCzURBWTXvscuzSI%2BF3lnHAN%2FUt6IJnXgkH%2B6jDKgyStVb8W%2BLHwIbypoxajN3fB5ksFT3Qu28RvDQpL6hBmqq7V2eFdfLMGtkmtcpfAUYNGffwaBAlQyQKnvhkCpEf5IIWkwWfe9Nt8dG3lIueeir9fGxZP7Fpcw9IP9HfgSansgXugtFI1rw06UhgrrK%2BEnaf4EmIgVdH6KYpDBKXpUUXz8vFRvkOMX5j%2BZNMTu%2BKDBzmGlFjcm1mCZl4ozZWDCocFO4CTW7z9LmzKYbcEGkUEhRbOu%2BTvLgVo80LilK--x3y6jxx%2FjYcLp5tr--9nrQ0XmAhtGAuIFvMYvWig%3D%3D
```

Все куки отправляются одним заголовком в формате _key=value; key=value_ без дополнительных параметров.