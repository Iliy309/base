# Для чего используется HTTP API—HTTP API

[](https://ru.hexlet.io/courses/http-api)

![Телефон отправляет запрос к HTTP API](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjY4NzE2NGJhYmRiMWYzYzMzNjVhZTBkMDI1MGNiYmMzLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=e4fabc49f003946071f1efe754b59d6acb2bfb4cc97cce18861abc6de95ec86e)

Не каждый сайт имеет API. К примеру, [гайды Хекслета](https://guides.hexlet.io/ru/?roistat_visit=7042678) содержат лишь набор статических HTML-страниц с текстом. То же самое можно сказать про многие другие сайты: визитки компаний, информационные сайты, каталоги.


**Вариант 1**. HTML-страницы формируются на сервере и отдаются в браузер напрямую. Любые ссылки обрабатываются напрямую браузером и загружаются прямыми запросами на сервер, которые обновляют страницу целиком.

В таком случае API не используется. Вся работа с данными и HTML происходит на сервере. Этот способ подходит там, где мало взаимодействия с пользователем и много страниц с текстом — как в Википедии или Google Поиске.

**Вариант 2**. Загруженная страница содержит JavaScript, который отслеживает и перехватывает клики по кнопкам и другие события. Страница в таком случае обновляется кодом, который загружен в браузер и выполняет запросы на сервер за нужными данными.

Такой способ нужен в местах с большим количеством форм или сложным взаимодействием, которое требует моментальной реакции. Таким способом реализованы системы бронирования, чаты, игры и редакторы.

_Вывод_ Сама структура API не сильно зависит от того, для чего мы его используем. Вполне может быть такое, что одно и тоже API используется для разных задач — для сайта, мобильного приложения и других сервисов.

## Chrome DevTools
Для удобства разработки и тестирования браузеры включают в себя **панель разработчика** — с ее помощью можно полностью проанализировать страницу, происходящие внутри процессы и HTTP-запросы.
Здесь нас интересует вкладка _Network_. На ней отображаются все запросы, которые выполняет браузер в процессе загрузки страницы. Также здесь показаны картинки, шрифты, файлы стилей, JavaScript и HTML самой страницы:

![Вкладка Сеть во время загрузки Code Basics](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImE0Njk2OTNlYzJjZjdjMmNmNzYwMTVhODMxZTljMmJjLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=57bb33ecdedad806d9c01a3f3eb30804ba87b53a453172fb6e589f92a7b096d1)

На каждый из загружаемых ресурсов можно нажать. Появится еще несколько вкладок с информацией, какой HTTP-запрос был отправлен и какой HTTP-ответ был получен. Здесь можно увидеть все заголовки и превью загруженного ресурса:

![Загрузка HTML для Code Basics](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjNkMmZiY2IxZjI5ZDY4NDlkZjU3NDlkOGY1ZWI5MzU4LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=93d23641cbfbfb87266e855df73b2fde38b4fe89125e692ce6044646113a7dca)

В этой же вкладке появляются запросы к HTTP API, которые выполняются на странице, использующей API.

Чтобы отделить запросы к HTTP API от всего остального, на вкладке _Network_ нужно нажать кнопку _Fetch/XHR_. Тогда в списке загружаемых ресурсов останутся ресурсы с типом _xhr_. Это и есть запросы к HTTP API.

# Обычно HTTP API построен по следующим правилам:

-   Данные передаются в формате JSON
-   Для каждого набора данных используется свой URL

Это далеко не единственный способ организации HTTP API, но один из самых распространенных.

Для примера возьмем сервис [DummyJSON](https://dummyjson.com/), созданный специально для экспериментов с API. Он включает в себя ненастоящие данные, с которыми можно попрактиковаться.

В документации сервиса описываются **ресурсы** – сущности, информацию о которых мы можем получать по API. Ниже их неполный список:

|URL |Описание|
| --- |---|
|/posts|Список постов|
|/comments|Список комментариев к постам|
|/users|Список пользователей|
|/todos|Список задач|

Каждая ссылка, по которой мы получаем какие-то данные в HTTP API, называется **эндпоинтом**.

Для получения списка пользователей нужно загрузить [https://dummyjson.com/users](https://dummyjson.com/users). Ее можно открыть даже в браузере. В ответ вернется такой текст:

```
{
    "users": [
        {
            "id": 2,
            "firstName": "Sheldon",
            "lastName": "Quigley",
            "maidenName": "Cole",
            "age": 28,
            "gender": "male",
            "email": "hbingley1@plala.or.jp",
            "phone": "+7 813 117 7139",
            "username": "hbingley1",
            "password": "1@#4asdfSDF!WER",
            "birthDate": "2003-08-02",
            "image": "https://robohash.org/doloremquesintcorrupti.png?size=50x50&set=set1",
            "bloodGroup": "O+",
            "height": 187,
            "weight": 74,
            "eyeColor": "Brown",
            "hair": {
            "color": "Blond",
            "type": "Curly"
        },
        {
            ...
        }
    ],
    "total": 100,
    "skip": 0,
    "limit": 30
}
```

Здесь мы работаем с ненастоящими данными. В реальном API мы бы еще подтвердили доступ, потому что нельзя отдавать такие данные всем подряд. К тому же, в нашем примере выводится пароль — в реальной жизни такого не бывает.

Формат, в котором данные передаются, называется **JSON**. Давайте остановимся на этом подробнее.

**Формат** – это способ описания данных. С ним можно работать двумя способами:

-   Упаковать данные — то есть сериализовать их
-   Извлечь данные — десериализовать их

Задача сериализации и десериализации возникает тогда, когда нам нужно передать данные из программы наружу — например, другим программам.

Данные внутри языков представляются каким-то способом, специфичным для данного языка и даже его конкретной версии. Поэтому для передачи данных и используются универсальные форматы, которые известны всем.

В случае HTTP API этот механизм работает так:

-   Сервис, который предоставляет HTTP API, извлекает данные из хранилища, формирует JSON и отдает его наружу
-   Затем этот JSON может прочитать любая программа с поддержкой JSON (а это большинство современных программ)

Поддержка JSON часто реализована прямо на уровне языков программирования. JSON – это всего лишь текст. У него есть понятная структура, которая прослеживается визуально. Отступы, пробелы и переносы для JSON не имеют значения.

Пример выше может выглядеть и так:

```
{"users":[{"id":2,"firstName":"Sheldon","lastName":"Quigley","maidenName":"Cole","age":28,"gender":"male","email":"hbingley1@plala.or.jp","phone":"+78131177139","username":"hbingley1","password":"1@#4asdfSDF!WER","birthDate":"2003-08-02","image":"https://robohash.org/doloremquesintcorrupti.png?size=50x50&set=set1","bloodGroup":"O+","height":187,"weight":74,"eyeColor":"Brown","hair":{"color":"Blond","type":"Curly"}}],"total":100,"skip":0,"limit":30}
```

Разберемся, чем это отличается от передачи данных в HTML.

HTML – это не формат данных, а язык разметки, с помощью которого формируется текст для браузеров. Браузеры считывают HTML и отображают его в виде веб-страницы. HTML не подразумевает работу с данными, которые содержатся внутри него. Теоретически это можно сделать, но на практике будет очень сложно.

JSON — это не единственный формат данных. До него популярным форматом был XML, и сейчас он встречается довольно часто. Так выглядит XML-файл:

```
<?xml version="1.0"?>
<Recipe>
   <Name>Lime Jello Marshmallow Cottage Cheese Surprise</Name>
   <Description>
     My grandma's favorite (may she rest in peace).
   </Description>
   <Ingredients>
      <Ingredient>
         <Qty unit="box">1</Qty>
         <Item>lime gelatin</Item>
      </Ingredient>
      <Ingredient>
         <Qty unit="g">500</Qty>
         <Item>multicolored tiny marshmallows</Item>
      </Ingredient>
   </Ingredients>
   <Instructions>
      <Step>
         Prepare lime gelatin according to package instructions
      </Step>
      <!-- And so on... -->
   </Instructions>
</Recipe>
```

XML похож на HTML, но решает другую задачу. XML – это формат данных, как и JSON. Разница лишь в том, что XML не предназначен для вывода.

## Структура JSON

Данные в формате JSON хранятся внутри объектов. **Объект** – это часть данных, ограниченная фигурными скобками, внутри которых задаются ключи и их значения:

```
{ "id": 3, "hasBranches": true, "name": "Hexlet", "country": "Finland" }
```

Ключи в JSON всегда обернуты кавычками. В качестве значений могут выступать числа, булевы значения, строки и `null`:

-   1, 3, 2.5
-   true, false
-   "one", "two"

Также значениями могут быть массивы:

```
{ "courses": ["php", "ruby", "python"] }
```

Причем весь JSON может быть только массивом:

```
["one", "two", "three"]
```

Объекты могут быть вложенными в другие объекты:

```
{ "id": 3, "hasBranches": true, "name": "Hexlet", "address": { "country": "Finland", "city": "Helsinki" } }
```

А еще объекты можно вложить в массивы:

```
{ "courses": [{ "id": 1, "name": "php" }, { "id": 2, "name": "javascript" }] }
```

## Метаданные

Если посмотреть на структуру ответа _/users_, то становится видно, что список пользователей передается как массив внутри объекта с дополнительными параметрами:

```
{
    "users": [],
    "total": 100,
    "skip": 0,
    "limit": 30
}
```

Зачем так сделано? Почему бы сразу не отдавать массив пользователей?

```
[{ ... }, { ... }]
```

Ответ здесь очень простой. Часто нужно передавать не только данные, но и **метаданные** — то есть данные о данных. Например, к метаданным относится общее количество пользователей. Если бы у нас был массив, то эту информацию было бы невозможно добавить без изменения структуры и перехода от массива к объекту.

Объект же позволяет добавлять новые данные, сохраняя обратную совместимость в структуре, не ломая ее. Нужно просто добавить новый ключ на верхний уровень, и все готово.

## Пагинация

Иногда данных слишком много: как на Хекслете, у которого сотни тысяч пользователей. JSON с таким объемом данных получится огромным и тяжелым.

Для решения этой задачи используют **пагинацию** — с ней данные отдаются не целиком, а небольшими наборами. Пагинацию мы встречаем в интернете на каждом шагу. Вспомните результаты поиска в Google — поисковик находит миллионы страниц, но показываются только первые десять результатов, а остальные скрывает на других страницах.

В API, с которым мы работаем, по умолчанию отдается 30 результатов. Это видно из возвращаемого JSON:

```
{
    "users": [],
    "total": 100,
    "skip": 0,
    "limit": 30
}
```

Как в таком случае получить вторые 30 человек? Нужно добавить параметр _skip_: [https://dummyjson.com/users?skip=30](https://dummyjson.com/users?skip=30). Так будет выглядеть JSON:

```
{
    "users": [],
    "total": 100,
    "skip": "30",
    "limit": 30
}
```

## Ограничение данных

Представим, что нам нужны не все данные, а только их часть. Для этого в нашем HTTP API есть параметр запроса _select_: [https://dummyjson.com/users?select=firstName,gender](https://dummyjson.com/users?select=firstName,gender). Так он выглядит:

```
{
     "users": [
        {
            "id": 1,
            "firstName": "Terry",
            "gender": "male"
        },
        {
            "id": 2,
            "firstName": "Sheldon",
            "gender": "male"
        },
        {
            "id": 3,
            "firstName": "Terrill",
            "gender": "male"
        }
    ]
}
```

## Одиночный ресурс

Эндпоинт _/users_ возвращает список пользователей. Если нам нужен один пользователь, то для этого понадобится другой эндпоинт — _/users/{id}_.

Этот эндпоинт называется **динамическим**, потому что у него есть меняющаяся часть. Вместо _{id}_ подставляется идентификатор конкретного пользователя, данные которого мы хотим получить.

Возьмем для примера [https://dummyjson.com/users/9](https://dummyjson.com/users/9) и посмотрим на результат:

```
{
    "id": 9,
    "firstName": "Demetrius",
    "lastName": "Corkery",
    "maidenName": "Gleason",
    "age": 22,
    "gender": "male",
    "email": "nloiterton8@aol.com",
    "phone": "+86 356 590 9727",
    "username": "nloiterton8",
    "password": "HTQxxXV9Bq4",
    "birthDate": "1971-03-11",
    "image": "https://robohash.org/excepturiiuremolestiae.png?size=50x50&set=set1",
    "bloodGroup": "A+",
    "height": 170,
    "weight": 97.1,
    "eyeColor": "Green",
    ...
}
```

## Вложенные ресурсы

Часто пользователи могут писать посты на сайте. Если мы захотим увидеть весь список постов, то используем эндпоинт _/posts_.

Чтобы увидеть посты конкретного пользователя, мы воспользуемся вложенными ресурсами: [https://dummyjson.com/users/3/posts](https://dummyjson.com/users/3/posts).

Этот эндпоинт вернет все посты пользователя с идентификатором 3:

```
{
    "posts": [
        {
            "id": 58,
            "title": "Balloons are pretty and come in different colors",
            "body": "Balloons are pretty and come in different colors, different shapes, different sizes, and they can even adjust sizes as needed. But don't make them too big or they might just pop, and then bye-bye balloon. It'll be gone and lost for the rest of mankind. They can serve a variety of purposes, from decorating to water balloon wars. You just have to use your head to think a little bit about what to do with them.",
            "userId": 3,
            "tags": [
                "american",
                "crime",
                "magical"
            ],
            "reactions": 9727
        },
    ],
    "total": 4,
    "skip": 0,
    "limit": 4
}
```

По такому же принципу устроена работа со всеми остальными ресурсами:

|URL|Описание|
|---|---|
|/users/{id}/posts|Список постов пользователя|
|/users/{id}/comments|Список комментариев пользователя|
|/users/{id}/todos|Список задач пользователя|

## Выводы

Это одно HTTP API, которое имеет свои правила по взаимодействию с эндпоинтами. В других HTTP API все будет по-другому — здесь каждый разработчик решает сам. Неизменным остается то, что мы работаем через HTTP и используем его возможности.


# CRUD
 Она обозначает четыре базовых операции над информацией:
-   Создание
-   Чтение
-   Обновление
-   Удаление

|Метод|URL|Операция|
|---|---|---|
|GET|/users|Список пользователей|
|GET|/users/1|Информация о пользователе|
|POST|/users/add|Добавление пользователя|
|PATCH|/users/1|Обновление пользователя|
|DELETE|/users/1|Удаление пользователя|

Как видите, в URL постоянно повторяется `1` — это идентификатор конкретного пользователя. Он будет меняться в зависимости от того, с каким пользователем мы работаем прямо сейчас.

Кстати, идентификатор необязательно должен быть числом. Здесь все зависит от того, что бэкенд считает идентификатором и как идентификаторы создаются в базе данных. Например, в MongoDB идентификатор состоит из чисел и букв.

Давайте вернемся к примеру выше и обратим внимание на использование методов HTTP. У методов есть определенный смысл:

-   GET нужен для извлечения данных
-   POST — для создания и отправки форм
-   PATCH — для обновления
-   DELETE — для удаления

При этом URL часто остается одним и тем же.

В API важно использовать подходящие методы. Любые HTTP-запросы обрабатываются веб-серверами и промежуточными прокси, которые могут находиться на пути к веб-серверу. И веб-сервер, и прокси знают про особенности HTTP. В зависимости от параметров запроса они могут делать различные оптимизации и кешировать результат.

**Кеширование** — это такая техника, которая позволяет веб-серверу или прокси сохранить ответ от сервера и отдавать его при следующих запросах без обращения к самому серверу.

Кеширование ускоряет доступ к ресурсам и разгружает серверы. Запрос GET можно кешировать для ускорения доступа, потому что GET никогда не меняет данные.

Методы POST, PATCH и DELETE кешировать нельзя — они должны постоянно приходить на сервер, так как они вносят изменения.

# Curl 
— это утилита командной строки, созданная в 1998 году. Она невероятно распространена и активно используется для скачивания файлов и в скриптах автоматизации. В документации по API у многих сервисов есть примеры того, как выполнить запрос с использованием curl

>[!warnning] Команды 
>Самый простой способ использовать curl — это выполнить GET-запрос к какому-то сайту:    
> * curl https://code-basics.com**
>
>В таком варианте curl распечатает на экран тело ответа — в нашем случае, HTML сайта. Его можно сохранить в файл, выполнив перенаправление:
 >* curl https://code-basics.com > code-basics.html*
 >
 >Если мы хотим посмотреть заголовки ответа, то запрос станет таким:
>* curl --head https://code-basics.com
>
>В таком случае curl отправляет HEAD-запрос, на который сервер должен вернуть заголовки без тела. По спецификации заголовки, возвращаемые в случае HEAD-запроса, должны совпадать с заголовками GET-запроса. Но на практике ответ зависит от настроек сервера. Поэтому для точности лучше выполнить GET-запрос:
> * curl --head -X GET https://code-basics.com
> 
>Если нужно увидеть не только ответ, но и запрос, то подойдет флаг _--verbose_. Он покажет все, включая тело ответа:
> * 
curl -v https://code-basics.com
> 
> Указание заголовков:
>* curl -H "Content-Type: application/json" https://dummyjson.com/users
>
>Указание тела в запросе \\ нужен для указания многострочного кода в терминале
>* curl -X POST https://dummyjson.com/users/add \
   -H "Content-Type: application/json" \
   -d '{ "firstName": "Sam", "age
   >
   >-M, --method
>-X, --reques 

# Виды API—HTTP API

В спецификации HTTP есть много правил и рекомендаций, но их все равно недостаточно для построения полноценного API.


## API по принципу «как придется»

Сюда попадают все API, которые делают по принципу «как получится». Обычно они встречаются во внутренних сервисах или публичных старых сервисах, созданных десятки лет назад.

Здесь нет никаких правил:

-   Каждый эндпоинт существует сам по себе
-   Активно используются параметры запроса
-   Игнорируются коды ответа и другие возможности самого HTTP

В теории такие API делать не стоит, но на практике они иногда встречаются.

## Архитектурный стиль REST

REST — это архитектурный стиль, который был заложен в сам протокол HTTP, ведь его придумал один из создателей HTTP.

API, построенный по этому принципу, вовсю использует возможности HTTP. Такое API активно опирается на заголовки, коды ответов, грамотно созданные эндпоинты. Например, [DummyJSON](https://dummyjson.com/) построен по принципам REST.

Можно сказать, что глобальная идея REST — использовать для проектирования API возможности, заложенные в HTTP изначально:


Однако REST не отвечает на те вопросы из начала урока. REST — это архитектурный стиль, а не конкретный стандарт. В эндпоинтах выше мы видим адреса и методы HTTP, но мы не знаем, какими будут данные в запросах и в ответах. Поэтому любое REST API имеет свои особенности, которые присущи только ему — у него есть свой способ обработки ошибок и своя структура возвращаемых данных.

Разработчики пытаются создать стандарт, который добавляет в REST все недостающие части. Самый удачный пример — [json:api](https://jsonapi.org/). Этот стандарт описывает конкретные структуры данных для разных типов запросов и ответов. Так может выглядеть извлечение конкретной фотографии:

```
{
  "type": "photos",
  "id": "1",
  "attributes": {
    "title": "Rails is Omakase"
  },
  "relationships": {
    "author": {
      "links": {
        "self": "/photos/1/relationships/author",
        "related": "/photos/1/author"
      },
      "data": { "type": "people", "id": "9" }
    }
  }
}
```

## Удаленный вызов процедур (Remote Procedure Call, RPC)

RPC API появились в интернете практически раньше всех остальных видов API. Здесь HTTP рассматривается как способ доставки API, но сам по себе не является частью API.

Как правило, RPC API работают с одним эндпоинтом — например, `/rpc`, на который отправляется GET или POST. RPC API используют небольшое количество заголовков и кодов ответов. Обработка ошибок, выполнение разных действий — все это в RPC зашито в само тело запроса и ответа.

Идея RPC в том, что мы просто вызываем обычные функции, а они каким-то магическим образом делают запросы на внешнюю систему, полностью или почти полностью скрывая от нас существование HTTP и сети в целом.

Запрос в JSON-RPC выглядит как JSON, в котором указывается, какую функцию и с какими параметрами нужно вызвать:

```
{
  "jsonrpc": "2.0",
  "method": "subtract",
  "params": { "minuend": 42, "subtrahend": 23 },
  "id": 3
}
```

В ответе приходит результат вызова этой функции:

```
{
  "jsonrpc": "2.0", "result": 19, "id": 3
}
```

Разновидностей RPC очень много, и они сильно отличаются между собой. Из наиболее известных можно назвать NFS, SOAP, XML-RPC, JSON-RPC, gRPC, GraphQL.

# OpenAPI—HTTP API

Архитектурный стиль REST оставляет много решений на откуп разработчикам. С одной стороны, это правильно, ведь задача REST — не зафиксировать спецификацию, а определить принципы построения хорошего HTTP API. В этом смысле REST — очень продуманная концепция, которая не зависит от моды и не меняется десятки лет.

С другой стороны, REST API дает много свободы и не указывает, как организуются ссылки, какие структуры данных отправляются и возвращаются. Это приводит к тому, что все REST API сильно отличаются друг от друга.

Это приводит к множеству проблем. В REST API нет:

-   Единого стандарта оформления документации
-   Автоматической проверки корректности вызовов и входящих параметров
-   Генерации кода тестов
-   Структур данных в языке для работы с данными API
-   Статического анализа и подсветки неправильных запросов в редакторе

Чтобы решить эти и другие проблемы, был разработан стандарт **OpenAPI** — это простой и языконезависимый способ описания API в формате, который понятен и машинам, и людям.

С его помощью выполняется автоматическая генерация документации, тестов, кода для выполнения запросов и проверки корректности данных:
