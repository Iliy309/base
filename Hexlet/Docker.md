```
# nginx взят просто для примера
docker run -it nginx bash

root@a6c26812d23b:/#
```

Этой командой мы говорим "запусти bash внутри контейнера используя образ nginx". Что это значит?

-   **Образ (Image)** — это слепок файловой системы, в который упаковано что-то, ради чего мы используем Docker. Например, это может быть PostgreSQL, nginx или наше приложение
-   **Контейнер (Container)** — это процесс операционной системы, подключенный к образу. Кроме того, контейнер изолирован от внешней среды и живет в своем окружении. В этом смысле контейнер похож на обычную виртуальную машину, но он более легковесный и зависит от основной операционной системы

При первом вызове данная команда начнет скачивать образ _nginx_, поэтому придется немного подождать. Когда образ скачается, запустится _bash_, и вы окажетесь **внутри контейнера** под суперпользователем (_root_).

Побродите по файловой системе, посмотрите директорию _/etc/nginx_. Как видите, ее содержимое не совпадает с тем, что находится у вас на компьютере. Эта файловая система появилась из образа _nginx_. Все, что вы сделаете здесь, никак не затронет вашу основную файловую систему, то есть можно смело удалять любые файлы внутри. После экспериментов не забудьте выйти командой `exit`, либо сочетанием клавиш `Ctrl + D`, либо просто закройте вкладку терминала.

Теперь посмотрим вариант вызова команды `cat`, выполненной уже в другом контейнере, но тоже запущенном из образа _nginx_:

```
# Общая структура
# docker run <имя образа> <команда> <параметры если есть>
docker run nginx cat /etc/nginx/nginx.conf

user  nginx;
worker_processes  1;

error_log  /var/log/nginx/error.log notice;
pid        /var/run/nginx.pid;
...
```

Команда выполняется практически мгновенно, так как образ уже загружен. В отличие от предыдущего старта, где запускается баш и начинается интерактивная сессия внутри контейнера, запуск команды `cat /etc/nginx/nginx.conf` для образа _nginx_ выведет на экран содержимое указанного файла (взяв его из файловой системы запущенного контейнера) и вернет управление в то место, где вы были. Вы не окажетесь внутри контейнера.

Последний вариант запуска будет таким:

```
# Обратите внимание на то, что после имени образа не указана никакая команда
# Такой подход работает в случае если команда на запуск прописана в самом образе
# -p — проброс портов, расскажем о нем в следующих уроках
docker run -p 8080:80 nginx
```

Данная команда не возвращает управление, потому что стартует nginx. Откройте браузер и наберите `localhost:8080`. Вы увидите как загрузилась страница _Welcome to nginx!_. Если в этот момент снова посмотреть в консоль, где был запущен контейнер, то можно увидеть, что туда выводится лог запросов к `localhost:8080`. Остановить nginx можно командой Ctrl + C.

Несмотря на то, что все запуски выполнялись по-разному и приводили к разным результатам, общая схема их работы одна. Docker при необходимости автоматически скачивает образ (первый аргумент после `docker run`) и на основе него стартует контейнер с указанной командой.

Попробуйте выполнить команду `docker run -it ubuntu bash` и наберите `ps auxf` внутри запущенного контейнера. Вывод будет таким:

```
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.1  0.1  18240  3300 pts/0    Ss   15:39   0:00 /bin/bash
root        12  0.0  0.1  34424  2808 pts/0    R+   15:40   0:00 ps aux
```

Как видно, процесса всего два, и у Bash PID равен 1. Из этого можно сделать несколько выводов:

-   Программа, которую мы запускаем при старте контейнера, становится корневым процессом. Внутри больше ничего нет, даже супервизора
-   Контейнер — это не один процесс, а дерево процессов, корнем которого является процесс запущенной программы, в случае выше это Bash. Находясь внутри, мы можем запускать другие процессы. Все они станут дочерними по отношению к Bash
  
  Когда мы выполняем команду `docker run <image name>`, то Docker проверяет наличие указанного образа на локальной машине и скачивает его по необходимости. Список образов, уже скачанных на компьютер, можно посмотреть командой `docker images`:

```
docker images

REPOSITORY                           TAG                 IMAGE ID            CREATED             SIZE
workshopdevops*web                   latest              cfd7771b4b3a        2 days ago          817MB
hexletbasics*app                     latest              8e34a5f631ea        2 days ago          1.3GB
mokevnin/rails                       latest              96487c602a9b        2 days ago          743MB
ubuntu                               latest              2a4cca5ac898        3 days ago          111MB
Ruby                                 2.4                 713da53688a6        3 weeks ago         687MB
Ruby                                 2.5                 4c7885e3f2bb        3 weeks ago         881MB
nginx                                latest              3f8a4339aadd        3 weeks ago         108MB
elixir                               latest              93617745963c        4 weeks ago         889MB
postgres                             latest              ec61d13c8566        5 weeks ago         287MB
```


Вторая колонка в выводе выше называется TAG. Когда мы выполняли команду `docker run nginx`, то на самом деле выполнялась команда `docker run nginx:latest`. То есть мы не просто скачиваем образ _nginx_, а скачиваем его конкретную версию. Latest — тег по умолчанию. Несложно догадаться, что он означает последнюю версию образа.

Важно понимать, что это всего лишь соглашение, а не правило. Конкретный образ вообще может не иметь тега _latest_, либо иметь, но он не будет содержать последние изменения, просто потому, что никто их не публикует. Впрочем, популярные образы следуют соглашению. Как понятно из контекста, теги в Docker изменяемы. Другими словами, вам никто не гарантирует, что скачав образ с одним и тем же тегом на разных компьютерах в разное время вы получите одно и то же. Такой подход может показаться странным и ненадежным, ведь нет гарантий, но на практике есть определенные соглашения, которым следуют все популярные образы. Тег latest действительно всегда содержит последнюю версию и постоянно обновляется, но кроме этого тега активно используется [семантическое версионирование](https://semver.org/). Рассмотрим [https://hub.docker.com/_/nginx](https://hub.docker.com/_/nginx)

```
1.13.8, mainline, 1, 1.13, latest
1.13.8-perl, mainline-perl, 1-perl, 1.13-perl, perl
1.13.8-alpine, mainline-alpine, 1-alpine, 1.13-alpine, alpine
1.13.8-alpine-perl, mainline-alpine-perl, 1-alpine-perl, 1.13-alpine-perl, alpine-perl
1.12.2, stable, 1.12
1.12.2-perl, stable-perl, 1.12-perl
1.12.2-alpine, stable-alpine, 1.12-alpine
1.12.2-alpine-perl, stable-alpine-perl, 1.12-alpine-perl
```

Теги с полной семантической версией (x.x.x) всегда неизменяемы, даже если в них встречается что-то еще — например, _1.12.2-alpine_. Такую версию смело можно брать для продакшен-окружения. Теги, подобные такому _1.12_, обновляются при изменении patch версии. То есть внутри образа может оказаться и версия _1.12.2_ и в будущем _1.12.8_. Точно такая же схема и с версиями, в которых указана только мажорная версия, например, _1_. Только в данном случае обновление идет не только по патчу, но и по минорной версии.

Как вы помните, команда `docker run` скачивает образ, если его нет локально, но эта проверка не связана с обновлением содержимого. Другими словами, если _nginx:latest_обновился, то `docker run` его не будет скачивать, он использует тот _latest_, который прямо сейчас уже загружен. Для гарантированного обновления образа существует другая команда: `docker pull`. Вот она всегда проверяет, обновился ли образ для определенного тега.

Кроме тегов имя образа может содержать префикс, например, `etsy/chef`. Этот префикс является именем аккаунта на сайте, через который создаются образы, попадающие в Registry. Большинство образов как раз такие, с префиксом. И есть небольшой набор, буквально сотня образов, которые не имеют префикса. Их особенность в том, что эти образы поддерживает сам Docker. Поэтому если вы видите, что в имени образа нет префикса, значит это официальный образ. Список таких образов можно увидеть здесь: [https://github.com/docker-library/official-images/tree/master/library](https://github.com/docker-library/official-images/tree/master/library)

Удаляются образы командой `docker rmi <imagename>`.

```
docker rmi Ruby:2.4

Untagged: Ruby:2.4
Untagged: Ruby@sha256:d973c59b89f3c5c9bb330e3350ef8c529753ba9004dcd1bfbcaa4e9c0acb0c82
```

Если в Docker присутствует хоть один контейнер из удаляемого образа, то Docker не даст его удалить по понятным причинам. Если вы все же хотите удалить и образ и все контейнеры, связанные с ним, используйте флаг `-f`.


# Управление контейнерами

[](https://ru.hexlet.io/courses/docker-basics)

![Docker Container LifeCycle](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6Ijk1NTg1NDkzNTZkYjBlY2Y1NWNkYzMzMDUzNGRmM2E4LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=476d993e73a9817463a60c3a09396b31b6b6efe2879598b726a2929bf02bba81)

Картинка описывает жизненный цикл (конечный автомат) контейнера. Кружками на нем изображены состояния, жирным выделены консольные команды, а квадратиками показывается то, что в реальности выполняется.

Проследите путь команды `docker run`. Несмотря на то, что команда одна, с точки зрения работы Docker выполняется два действия: создание контейнера и запуск. Существуют и более сложные варианты исполнения, но в этом разделе мы рассмотрим только базовые команды.

Запустим nginx так, чтобы он работал в фоне. Для этого после слова _run_ добавляется флаг `-d`:

```
docker run -d -p 8080:80 nginx

431a3b3fc24bf8440efe2bca5bbb837944d5ae5c3b23b9b33a5575cb3566444e
```

После выполнения команды Docker выводит идентификатор контейнера и возвращает управление. Убедитесь в том, что nginx работает, открыв в браузере ссылку `localhost:8080`. В отличие от предыдущего запуска, наш nginx работает в фоне, а значит не видно его вывода (логов). Посмотреть его можно командой `docker logs`, которой нужно передать идентификатор контейнера:

```
docker logs 431a3b3fc24bf8440efe2bca5bbb837944d5ae5c3b23b9b33a5575cb3566444e

172.17.0.1 - - [19/Jan/2018:07:38:55 +0000] "GET / HTTP/1.1" 200 612 "-" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36" "-"
```

Вы также можете подсоединиться к выводу лога в стиле `tail -f`. Для этого запустите `docker logs -f 431a3b3fc24bf8440efe2bca5bbb837944d5ae5c3b23b9b33a5575cb3566444e`. Теперь лог будет обновляться каждый раз, когда вы обновляете страницу в браузере. Выйти из этого режима можно набрав Ctrl + C, при этом сам контейнер остановлен не будет.

Теперь выведем информацию о запущенных контейнерах командой `docker ps`:

```
CONTAINER ID        IMAGE                            COMMAND                  CREATED             STATUS              PORTS                                          NAMES
431a3b3fc24b        nginx                            "nginx -g 'daemon of…"   2 minutes ago       Up 2 minutes        80/tcp                                         wizardly_rosalind
```

Расшифровка столбиков:

-   CONTAINER_ID — идентификатор контейнера. Так же, как и в git, используется сокращенная запись хеша
-   IMAGE — имя образа, из которого был поднят контейнер. Если не указан тег, то подразумевается _latest_
-   COMMAND — команда, которая выполнилась на самом деле при старте контейнера
-   CREATED — время создания контейнера
-   STATUS — текущее состояние
-   PORTS — проброс портов
-   NAMES — алиас. Docker позволяет кроме идентификатора иметь имя. Так гораздо проще обращаться с контейнером. Если при создании контейнера имя не указано, то Docker самостоятельно его придумывает. В выводе выше как раз такое имя у nginx

(_Команда `docker stats` выводит информацию о том, сколько ресурсов потребляют запущенные контейнеры)._

Теперь попробуем остановить контейнер. Выполним команду:

```
# Вместо CONTAINER_ID можно указывать имя
docker kill 431a3b3fc24b # docker kill wizardly_rosalind
431a3b3fc24b
```

Если попробовать набрать `docker ps`, то там этого контейнера больше нет. Он удален.

Команда `docker ps` выводит только запущенные контейнеры. Но кроме них могут быть и остановленные. Причем остановка может происходить как по успешному завершению, так и в случае ошибок. Попробуйте набрать `docker run ubuntu ls`, а затем `docker run ubuntu bash -c "unknown"`. Эти команды не запускают долгоживущий процесс, они завершаются сразу после выполнения, причем вторая с ошибкой, так как такой команды не существует.

Теперь выведем все контейнеры командой `docker ps -a`. Первыми тремя строчками вывода окажутся:

```
CONTAINER ID        IMAGE                            COMMAND                  CREATED                  STATUS                       PORTS                                          NAMES
85fb81250406        ubuntu                           "bash -c unkown"         Less than a second ago   Exited (127) 3 seconds ago                                                  loving_bose
c379040bce42        ubuntu                           "ls"                     Less than a second ago   Exited (0) 9 seconds ago                                                    determined_tereshkova
```

Здесь как раз два последних запуска. Если посмотреть на колонку STATUS, то видно, что оба контейнера находятся в состоянии Exited. То есть запущенная команда внутри них выполнилась, и они остановились. Разница лишь в том, что один завершился успешно (0), а второй с ошибкой (127). После остановки контейнер можно даже перезапустить:

```
docker start determined_tereshkova # будет другое имя
```

 Чтобы его посмотреть`docker logs determined_tereshkova`.
# Сеть
Если запустить nginx такой командой `docker run nginx`, то nginx не сможет принять ни один запрос, несмотря на то, что внутри контейнера он слушает _80_ порт (напомню, что каждый контейнер по умолчанию живет в своей собственной сети). Но если запустить его так `docker run -p 8080:80 nginx`, то nginx начнет отвечать на порту _8080_.

Флаг `-p` позволяет описывать, как и какой порт выставить наружу. Формат записи `8080:80`расшифровывается так: пробросить порт _8080_ снаружи контейнера в контейнер на порт _80_. Причем по умолчанию порт _8080_ слушается на `0.0.0.0`, то есть на всех доступных интерфейсах. Поэтому запущенный таким образом контейнер доступен не только через `localhost:8080`, но и снаружи машины (если доступ не запрещен как-нибудь еще). Если нужно выполнить проброс только на _loopback_, то команда меняется на такую: `docker run -p 127.0.0.1:8080:80 nginx`.

Docker позволяет пробрасывать столько портов, сколько нужно. Например, в случае nginx часто требуется использовать и `80` порт и `443` для HTTPS. Сделать это можно так: `docker run -p 80:80 -p 443:443 nginx` 

# Файловая система—Docker: Основы


Другая частая задача связана с доступом к основной файловой системе. Например, при старте nginx-контейнера ему можно указать конфигурацию, лежащую на основной ФС. Docker прокинет ее во внутреннюю ФС, и nginx сможет ее читать и использовать.

Проброс осуществляется с помощью опции `-v`. Вот как можно запустить баш сессию из образа Ubuntu, подключив туда историю команд с основной файловой системы: `docker run -it -v $HOME/.bash_history:/root/.bash_history ubuntu bash`. Если в открытом баше понажимать стрелку вверх, то отобразится история. Пробрасывать можно как файлы, так и директории. Любые изменения производимые внутри volume меняются как внутри контейнера, так и снаружи, причем по умолчанию доступны любые операции. Как и в случае портов, количество пробрасываемых файлов и директорий может быть любым.

При работе с Volumes есть несколько важных правил, которые надо знать:

-   Путь до файла или директории должен быть абсолютным
-   Если внутренний путь (то, что идет после `:`) не существует, то Docker создаст все необходимые директории и файлы. Если существует, то заменит старое тем, что было проброшено

Кроме пробрасывания части ФС, снаружи Docker предоставляет еще несколько вариантов создания и использования Volumes.


# Подготовка собственного образа—Docker: Основы


На Docker Hub выложено множество готовых образов, которые используются администраторами и разработчиками: интерпретаторы и компиляторы языков, веб-сервера, базы данных и многое другое. Большую часть из них можно использовать на серверах без изменений, передав какие-то переменные окружения. Но для любого разрабатываемого приложения нужно создавать свой собственный образ. В него войдет код приложения и все его зависимости. Даже когда нам будет нужно изменить всего лишь конфигурацию, например Nginx, все равно придется создать свой собственный образ, в который добавлен конфигурационный файл.

В этом уроке мы научимся создавать Docker-образ на примере JavaScript проекта: данный язык программирования достаточно распространен в среде разработчиков. Но все описанные принципы так же будут подходить и для других языков. Для создания образа будем использовать популярный микрофреймворк [fastify](https://github.com/fastify/fastify).

Для начала создадим каркас приложения с помощью готового шаблона:

```
cd /var/tmp # можно выбрать любую директорию
mkdir docker-fastify-example
cd docker-fastify-example
docker run --user $(id -u) -it -w /out -v `pwd`:/out node npm init fastify

Need to install the following packages:
  create-fastify
Ok to proceed? (y) y # введите y
generated .gitignore
generated README.md
generated app.js
generated .vscode/launch.json
generated plugins/README.md
generated routes/root.js
generated test/helper.js
generated plugins/sensible.js
generated plugins/support.js
generated routes/README.md
generated routes/example/index.js
generated test/routes/root.test.js
generated test/plugins/support.test.js
generated test/routes/example.test.js
--> project example generated successfully
run 'npm install' to install the dependencies
run 'npm start' to start the application
run 'npm run dev' to start the application with pino-colada pretty logging (not suitable for production)
run 'npm test' to execute the unit tests
```

Эта команда создаст шаблон приложения в директории _/out_ запущенного контейнера, которая, на самом деле, является директорией _/var/tmp/docker-fastify-example_ на нашей машине. В итоге у нас получается такая структура проекта:

```
. # docker-fastify-example
├── README.md
├── app.js
├── package.json
├── plugins
├── routes
└── test
```

Для запуска этого приложения, нам нужно выполнить две основные задачи: установить зависимости и запустить сервер. Без Docker это выглядит так:

```
# Если не стоит npm,
# то сюда еще входит установка Node.js
npm install
npm start # или npm run dev в режиме разработки
```

Установку зависимостей нужно выполнить еще до создания образа, так как во время первой установки формируется файл _package-lock.json_. Он нужен для фиксации зависимостей: с его помощью мы гарантируем, что в образе будут использоваться ровно те зависимости, которые мы подключали во время разработки. Сделать это можно следующим образом:

```
# внутри директории docker-fastify-example
docker run -it -w /out -v `pwd`:/out node npm install

added 398 packages, and audited 560 packages in 45s
```

Теперь директория с приложением выглядит так:

```
.
├── README.md
├── app.js
├── node_modules # тут хранятся зависимости
├── package-lock.json # новый файл
├── package.json
├── plugins
├── routes
└── test
```

## Сборка и публикация Docker-образа

Docker создает образ на основе файла _Dockerfile_, в котором описываются необходимые команды. Мы начнем сразу с примера:

```
FROM node:18

WORKDIR /app

COPY package.json .
COPY package-lock.json .

RUN npm ci

COPY . .

ENV FASTIFY_ADDRESS 0.0.0.0

# Команда, которая запускается автоматически
# при старте контейнера
CMD ["npm", "start"]
```

В основном, команды _Dockerfile_ интуитивно понятны. Видно, что мы "упаковываем" приложение в образ, выполняем установку зависимостей и описываем то, как его запустить. Подробнее о командах мы поговорим позже, а сейчас посмотрим, как собирается, запускается и пушится образ в Docker Hub.

Для сборки образа в директории с _Dockerfile_ нужно выполнить команду указанную ниже:

```
# -t, --tag - имя образа и тега. По умолчанию latest
# Точка в конце важна, подробнее про нее дальше
docker build -t hexlet/docker-fastify-example .

[+] Building 26.4s (12/12) FINISHED
 => [internal] load build definition from Dockerfile
 => => transferring dockerfile: 190B
 => [internal] load .dockerignore
 => => transferring context: 2B
 => [internal] load metadata for docker.io/library/node:18
 => [auth] library/node:pull token for registry-1.docker.io
 => [internal] load build context
 => => transferring context: 63.29MB
 => [1/6] FROM docker.io/library/node:18@sha256:e5b7b3
 => [2/6] WORKDIR /app
 => [3/6] COPY package.json .
 => [4/6] COPY package-lock.json .
 => [5/6] RUN npm ci
 => [6/6] COPY . .
 => exporting to image
 => => exporting layers
 => => writing image sha256:52f6fe
 => => naming to docker.io/library/docker-fastify-example
```

Сборка образа занимает какое-то время: нужно подождать, пока выполнятся все команды. Как результат, в списке образов появляется образ с именем _hexlet/docker-fastify-example_и тегом _latest_. Его можно запустить и убедиться в работоспособности:

```
# По умолчанию Fastify стартует на 3000 порту
# Docker запускает команду npm start
docker run -it -p 3000:3000 hexlet/docker-fastify-example

{"level":30,"time":1651503036761,"pid":22,"hostname":"a9b1ea7fc320","msg":"Server listening at http://0.0.0.0:3000"}
```

Для полной проверки, откройте в браузере ссылку [http://localhost:3000](http://localhost:3000/) и убедитесь что сайт открылся. Остался последний шаг — загрузить образ на Docker Hub. Для этого понадобится подготовительная работа:

1.  Регистрация [https://hub.docker.com/](https://hub.docker.com/)
2.  Подключение к аккаунту через запуск команды `docker login` в терминале. Docker попросит ввести имя пользователя и пароль
3.  Создание репозитория с именем _docker-fastify-example_ в [личном кабинете](https://hub.docker.com/repository/create)

Теперь, чтобы загрузить образ в Docker Hub, мы должны дать ему правильное имя. По соглашению, часть имени Docker-образа до символа _/_, должна совпадать с именем вашего пользователя Docker Hub. Чтобы так сделать, вам необходимо запустить команду сборки еще раз:

```
docker build -t <имя вашего пользователя>/docker-fastify-example .
```

Теперь можно _пушить_:

```
docker build -t <имя вашего пользователя>/docker-fastify-example .
# По умолчанию отправляется тег latest
docker push <имя вашего пользователя>/docker-fastify-example
```

## Теги

Теги у Docker-репозиториев изменяемые. Если изменить образ и снова его запушить с тем же тегом, образ поменяется. Для тега _latest_ это ожидаемое поведение, а вот для версий нет. За этим нужно следить самостоятельно и не менять образ для уже существующих тегов. Если меняется образ, то правильно создавать новый тег:

```
# Используем тег
docker build -t <имя вашего пользователя>/docker-fastify-example:v2 .
docker push <имя вашего пользователя>/docker-fastify-example:v2
```

## Команды Dockerfile

_Dockerfile_ состоит из команд, которые выполнятся сверху вниз по очереди, формируя файловую систему образа. Каждая последующая команда "видит" результаты предыдущей команды. Ниже мы разберем наиболее популярные команды, которые встречаются в большинстве образов.

### FROM

```
# Варианты

# По умолчанию тег latest
FROM ubuntu

# С явно указанным тегом
FROM node:18
```

Образ — это в первую очередь файловая система, которая формируется на базе команд описанных в _Dockerfile_. Docker берет какую-то первоначальную файловую систему и затем изменяет ее в соответствии с описанием. Получившаяся структура файлов и становится образом. Откуда берется первоначальная файловая система?

Практически все образы в Docker формируются не с нуля, а на базе уже существующих образов. Образы формируют дерево, в котором одни образы наследуют файловые системы других образов начиная с базового образа [scratch](https://hub.docker.com/_/scratch).

```
# Иерархия образов
docker-fastify-example
  FROM node
    FROM buildpack-deps:bullseye
      FROM buildpack-deps:bullseye-scm
        FROM buildpack-deps:bullseye-curl
      FROM debian:bullseye
        FROM scratch
```

Команда `FROM` задает образ, чья файловая система берется за основу. Все последующие команды, которые изменяют файловую систему, работают уже с ней. Потому команда `FROM`идет первой в _Dockerfile_.

### WORKDIR

```
WORKDIR /app
```

Команда `WORKDIR` задает рабочий каталог, относительно которого выполняются все действия во время формирования образа и при входе в контейнер:

```
docker run -it hexlet/devops-fastify-app bash
root@02d29c66ea06:/app# # мы оказались внутри /app
```

`WORKDIR` автоматически создает директорию, если ее еще нет.

### COPY

```
# файлы

COPY package.json .
# Аналогично
# COPY package.json package.json

COPY package-lock.json .

# Копирование всех файлов внутрь
COPY . .
```

Команда `COPY` копирует файлы и директории с хост-машины внутрь Docker-образа. Она принимает два параметра: первый — что копируем, второй — куда копируем и под каким именем. Второй параметр может принимать три варианта:

-   Абсолютный путь, копирование происходит ровно по нему
-   Относительный путь, копирование происходит относительно установленной рабочей директории `WORKDIR`
-   Точка, файл или директория копируется как есть в рабочую директорию

Если точка идет первым параметром, то это обозначает что копироваться будет директория целиком.

Для полного понимания принципов работы команды `COPY`, нужно представлять что такое контекст. Помните, когда мы указывали точку во время сборки образа? Это и есть контекст:

```
docker build -t hexlet/docker-fastify-example .
```

Контекст — это директория, относительно которой работает первый параметр в `COPY`. Обычно контекстом указывают ту директорию, которая содержит _Dockerfile_. Но это не обязательно, ведь контекстом может быть и другая директория:

```
# Указана директория уровнем выше
# Dockerfile должен лежать в текущей директории, из которой идет запуск
docker build -t something ..
```

Во время сборки образа, контекст целиком копируется внутрь системных директорий Docker, из которых в образ переносится все, что указано в команде `COPY`. Из-за этого иногда возникают проблемы. Контекст может содержать директории, которые не должны попадать в образ, например, `.git`, или зависимости установленные локально (_node_modules_), так как они все равно устанавливаются заново во время сборки. Чтобы избежать их попадания во внутрь, нужно создать файл _.dockerignore_ и указать там те директории и файлы, которые не должны быть частью контекста. Принцип работы файла такой же, как и у _.gitignore_.

```
node_modules
.git
logs
tmp
```

Игнорирование таких директорий и файлов дает дополнительный плюс. Чем меньше размер контекста, тем быстрее он копируется. Если не следить за его размером, то процесс копирования может увеличиться до десятков секунд и даже минут.

### RUN

```
# Если базовый образ Ubuntu, то доступен apt
RUN apt-get update && apt-get install -q curl

RUN npm install
```

Команда `RUN` выполняет переданную строчку в терминале от пользователя _root_. С ее помощью вносятся основные изменения в файловую систему, добавляются пакеты, ставятся зависимости и так далее. Команд `RUN` может быть добавлено любое количество, обычно делают по одной команде на одно действие.

`RUN` выполняется в не интерактивном режиме, это значит, что если выполняемая команда запросит пользовательский ввод, например разрешение на установку чего-либо, то мы не сможем выбрать ответ _yes_. Поэтому все команды в `RUN` запускают в неинтерактивном режиме:

```
# -q - ставить автоматически не задавая вопросов
RUN apt-get install -q curl
```

### CMD

`CMD` задает команду, которая выполняется при запуске контейнера по умолчанию. Она используется только в том случае, если контейнер был запущен без указания команды

```
# Используется CMD
docker run -it hexlet/docker-fastify-example # npm start
# CMD не используется, так как явно указан bash
docker run -it hexlet/docker-fastify-example bash
```

### ENV

```
ENV FASTIFY_ADDRESS 0.0.0.0
ENV VERSION 1
```

Задает переменные окружения. Команды, выполняющиеся после `ENV`, видят эти переменные и могут их использовать.

С этой командой нужно быть острожнее. Переменные окружения созданы для того, чтобы их можно было менять, а их указание в Dockerfile фиксирует значения. По этому случаю, в Dockerfile обычно указывают только те переменные окружения, которые не зависят от среды запуска, как в примере выше. Нам в любом случае надо указать что сервер должен запускаться на 0.0.0.0 иначе его будет невозможно увидеть снаружи. В большинстве ситуаций переменные окружения передаются снаружи для конкретного запуска:

```
docker run -it -p 3000:3000 -e NODE_ENV=production hexlet/docker-fastify-example
```

# Docker Compose
Docker Compose позволяет управлять набором контейнеров, каждый из которых представляет собой один сервис проекта. Управление включает в себя сборку, запуск с учетом зависимостей и конфигурацию. Конфигурация Docker Compose описывается в файле docker-compose.yml, лежащем в корне проекта.

## Пример файла _docker-compose.yml_

```
# Версия схемы, которую мы используем.
# Зависит от установленной версии docker
# https://docs.docker.com/compose/compose-file/
version: "3"
# Определяем список сервисов — services
# Эти сервисы будут частью нашего приложения
services:

  app: # Имя сервиса
    build:
      # Контекст для сборки образа,
      # в данном случае, текущая директория
      context: .
      # Имя Docker-файла из которого будет собран образ
      dockerfile: Dockerfile
      # Команда, которая будет выполнена после старта сервиса
    command: make start
    ports: # Проброс портов
      - "3000:8000"
    # Перечисляем тома (volumes)
    # Они будут подключены к файловой системе сервиса
    # Например, все что находится в . мы увидим в директории /app
    volumes:
      # Текущая директория пробрасывается в директорию /app внутри контейнера
      # Путь внутри контейнера (после двоеточия) обязательно должен быть абсолютным
      - ".:/app"
      - "/tmp:/tmp"
    # Сервис будет запущен, только после старта db
    depends_on:
      - db

  db:
    # Имя образа. Здесь мы используем базу данных Postgres
    image: postgres:latest
    environment:
      # А так задаются переменные окружения
      POSTGRES_PASSWORD: password
    volumes:
      - pgdata:/var/lib/postgresql/data

  volumes:
    pgdata:
```

## Команды для работы с Docker Compose

```
# Собирает сервисы, описанные в конфигурационных файлах
docker compose build

# Запускает собранные сервисы
docker compose up

# Запуск контейнеров на фоне с флагом -d
docker compose up -d

# Если какой-то из сервисов завершит работу,
# то остальные будут остановлены автоматически
docker compose up --abort-on-container-exit

# Запустит сервис application и выполнит внутри команду make install
docker compose run application make install

# А так мы можем запустить сервис и подключиться к нему с помощью bash
docker compose run application bash

# Со флагом --rm запускаемые контейнеры будут автоматически удаляться
docker compose run --rm application bash

# Останавливает и удаляет все сервисы,
# которые были запущены с помощью up
docker compose down

# Останавливает, но не удаляет сервисы, запущенные с помощью up
# Их можно запустить снова с помощью docker-compose start
docker compose stop

# Перезапускает все остановленные и запущенные сервисы
docker compose restart
```