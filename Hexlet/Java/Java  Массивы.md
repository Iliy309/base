# Синтаксис—Java:

Массивы представляют собой последовательность элементов одного типа, например чисел или строк. Задача массива — представить такие списки в виде единой структуры, которая позволяет работать с ними как с единым целым, будь то курсы на Хекслете или друзья в вашей любимой социальной сети.

## Определение массива

Начнем с создания. Для создания массива надо знать тип элементов в массиве и имя новой переменной которая будет ссылаться на массив:

```
// Массив - ссылочный тип
int[] numbers = {1, 2, 3};
String[] cars = {"kia", "bmw", "ford"};

// Массив может быть даже пустым
int[] emptyArray = {};
```

В примере создаются и сразу инициализируются (наполняются значениями) два массива. Один состоит из чисел, другой из строк. Тип массива задается как тип хранящихся элементов, соединенный с парными скобками, например, так `int[]`.

Обратите внимание на именование переменных, содержащих массивы. Они во множественном числе. Это подчеркивает природу переменной и делает код проще для анализа.

Массивы в Java фиксированного размера, поэтому если мы хотим создать пустой массив, но не знаем заранее что должно быть внутри, мы можем создать пустой массив нужной длины и затем заполнить его нужными значениями:

```
// Это особый синтаксис создания массива, а не объектов по типу
// Обратите внимание на то, что скобки квадратные, а не круглые
int[] numbers = new int[3];
String[] cars = new String[3];
// И так далее для всех остальных типов
```

Здесь 3 - нужный размер массива, в переменной `numbers` будет зарезервировано место для трех переменных которые можно будет записать в массив в дальнейшем.

## Вывод на экран

Массивы относятся к ссылочным типам данных. Эту тему мы обсудим позже, но прямо сейчас нужно знать как распечатать на экран такие данные. Обычный способ не работает:

```
String[] cars = {"kia", "bmw", "ford"};
System.out.println(cars); // => java.lang.String;@27bc2616
```

Для печати нужно использовать метод `Arrays.toString()`, который формирует из массива строку. Затем эту строку можно вывести на экран:

```
import java.util.Arrays;

String[] cars = {"kia", "bmw", "ford"};
System.out.println(Arrays.toString(cars));
// => ["kia", "bmw", "ford"]
```

## Получение данных

Элементы в массиве упорядочены слева направо. Каждый элемент имеет порядковый номер, называемый **индексом**. Индексация массива начинается с нуля. То есть первый элемент массива доступен по индексу `0`, второй — по индексу `1` и так далее. Для извлечения элемента из массива по индексу используется свой синтаксис:

```
String[] animals = {"cats", "dogs", "birds"};
animals[0]; // "cats"
animals[1]; // "dogs"

// Последний индекс в массиве всегда меньше размера массива на единицу
// В этом массиве три элемента, но последний индекс равен двум
animals[2]; // "birds"
```

Узнать размер массива можно, обратившись к его свойству `length`.

```
String[] animals = {"cats", "dogs", "birds"};
animals.length; // 3
```

В реальных задачах индекс часто вычисляется динамически, поэтому обращение к конкретному элементу происходит с использованием переменных:

```
var i = 1;
String[] animals = {"cats", "dogs", "birds"};
animals[i]; // "dogs"
```

И даже так:

```
var i = 1;
var j = 1;
String[] animals = {"cats", "dogs", "birds"};
animals[i + j]; // "birds"
```

Такой вызов возможен по одной простой причине — внутри скобок ожидается _выражение_. А там, где ожидается выражение, можно подставлять все, что вычисляется. В том числе вызовы метода:

```
String[] animals = {"cats", "dogs", "birds"};
animals[someMethod()]; // "dogs"
```

Довольно часто в задачах с использованием массивов нужно взять последний элемент. Для этого вычисляется последний индекс массива по формуле _размер_массива - 1_, по которому и можно обратиться к последнему элементу:

```
String[] animals = {"cats", "dogs", "birds"};
animals[animals.length - 1]; // "birds"
```

# Модификация—Java
Примитивные типы данных, с которыми мы работали до сих пор, невозможно изменить. Любые функции и методы над ними возвращают новые значения, но не могут ничего сделать со старым.

```
var name = "Hexlet";
name.toUpperCase(); // "HEXLET"
// Значение name не поменялось
System.out.println(name); // 'Hexlet'
```

С массивами это правило не работает. Элементы массива можно изменять записывая туда другие значения. Синтаксис изменения элемента массива практически такой же, как и при обращении к элементу массива. Разница лишь в наличии присваивания:

```
import java.util.Arrays;

String[] animals = { "cats", "dogs", "birds" };
// Меняется первый элемент массива
animals[0] = "horses";
System.out.println(Arrays.toString(animals));
// => { "horses", "dogs", "birds" }

// Если индекса не существует, то получим ошибку
animals[5] = "monkeys";
| Exception java.lang.ArrayIndexOutOfBoundsException:
| Index 5 out of bounds for length 3
```

Точно так же можно инициализировать новый массив:

```
// Создается массив из 5 чисел
int[] numbers = new int[5];

// Порядок заполнения не важен
numbers[1] = 8;
numbers[0] = 3;
```

Созданный, но не инициализированный массив, наполняется значениями по умолчанию. Для каждого типа это свое значение:

```
boolean : false
int     : 0
double  : 0.0
String  : null
```

Например, для строк:

```
String[] cars = new String[2];
System.out.println(cars[0]); // => null
```

## Изменение размера массива

Массивы в Java имеют фиксированную длину. Это связано с тем, как хранятся массивы в памяти. Каждый раз когда нужно изменить размер массива, что-то добавить или удалить, придется создавать новый массив куда копируются нужные значения из старого. В следующих уроках мы рассмотрим как конкретно это происходит, а сейчас поработаем уже с готовыми методами. Обработка массивов хорошо реализована в библиотеке [Apache Commons Lang](https://mvnrepository.com/artifact/org.apache.commons/commons-lang3).

```
import org.apache.commons.lang3.ArrayUtils;
import java.util.Arrays;

String[] animals = { "cats", "dogs", "birds" };

// Добавление элементов

var animals2 = ArrayUtils.add(animals, "horse");
System.out.println(Arrays.toString(animals2));
// => [cats, dogs, birds, horse]

// Исходный массив не поменялся
System.out.println(Arrays.toString(animals));
// => [cats, dogs, birds]

// Удаление элементов

// Удаляем элемент с index = 1
var animals3 = ArrayUtils.remove(animals, 1);
System.out.println(Arrays.toString(animals3));
// => [cats, birds]

// Удаляем элемент с index = 0
var animals4 = ArrayUtils.remove(animals, 0);
System.out.println(Arrays.toString(animals4));
// => [dogs, birds]
```

# Цикл For—Java
Работа с массивами почти всегда завязана на одновременную обработку всех его элементов. Это нужно при выводе списков на экран, при выполнении различных расчетов или проверке данных. Во всех этих случаях нужен механизм для перебора элементов массива. Самый простой способ сделать это – использовать цикл.

## Обход

Циклы напрямую с массивами не связаны, но у циклов есть счетчик, который может выступать в качестве индекса массива. Поэтому соединить их не составляет никакого труда:

```
// Создаем массив
String[] userNames = {"petya", "vasya", "evgeny"};

// Определяем цикл
// Начальное значение счетчика var i = 0 – вычисляется один раз перед началом выполнения
// Условие остановки i < userNames.length – выполняется перед каждой итерацией
// Изменение счетчика i += 1 – выполняется после каждой итерации
for (var i = 0; i < userNames.length; i++) {
    // Этот код выполняется для каждого элемента
    System.out.println(userNames[i]);
}

// => "petya"
// => "vasya"
// => "evgeny"
```

[https://replit.com/@hexlet/java-arrays-for-print](https://replit.com/@hexlet/java-arrays-for-print)

В данном коде создаем массив из трех элементов — имен. Далее в цикле обходим массив и выводим на экран все имена так, что каждое имя оказывается на новой строке (`System.out.println()` автоматически делает перевод строки).

Рассмотрим этот этап подробнее. При обходе массива циклом `for` счетчик, как правило, играет роль индекса в массиве. Он инициализируется нулем и увеличивается до `userNames.length - 1`, что соответствует индексу последнего элемента. Именно поэтому мы используем строгое сравнение `<` (_меньше_) в условном выражении `i < userNames.length`, а не `<=` (_меньше либо равно_).

А что, если нам нужно вывести значения в обратном порядке? Для этого есть два способа. Один — идти в прямом порядке, то есть от нулевого индекса до последнего, и каждый раз вычислять нужный индекс по такой формуле `размер массива - 1 - текущее значение счетчика`.

```
String[] userNames = {"petya", "vasya", "evgeny"};

for (var i = 0; i < userNames.length; i++) {
    var index = userNames.length - 1 - i;
    System.out.println(userNames[index]);
    // Можно даже так
    // var userName = userNames[userNames.length - 1 - i];
    // System.out.println(userName);
}

// => "evgeny"
// => "vasya"
// => "petya"
```

Другой способ подразумевает обход в обратном порядке, от верхней границы до нижней, то есть от последнего индекса массива к первому (нулю, так как индексирование начинается с нуля). В такой ситуации код меняется на следующий:

```
String[] userNames = {"petya", "vasya", "evgeny"};

// Начальное значение i соответствует последнему индексу в массиве
for (var i = userNames.length - 1; i >= 0; i--) {
    System.out.println(userNames[i]);
}
// => "evgeny"
// => "vasya"
// => "petya"
```

При таком обходе проверка остановки должна быть именно на `>=`, иначе элемент с индексом 0 не попадет в цикл.

## Изменение

Во время обхода массива его можно не только читать, но и модифицировать. Предположим, что перед нами стоит задача нормализации списка электронных адресов — например, приведение их к нижнему регистру. Тогда код будет выглядеть так:

```
import java.util.Arrays;

String[] emails = {"VASYA@gmAil.com", "iGoR@yandex.RU", "netiD@hot.CoM"};

System.out.println(Arrays.toString(emails));
// => [VASYA@gmAil.com, iGoR@yandex.RU, netiD@hot.CoM]

for (var i = 0; i < emails.length; i++) {
    var email = emails[i];

    var normalizedEmail = email.toLowerCase();
    // Заменяем значение
    emails[i] = normalizedEmail;
}

System.out.println(Arrays.toString(emails));
// => [vasya@gmail.com, igor@yandex.ru, netid@hot.com]
```

[https://replit.com/@hexlet/java-arrays-for-update](https://replit.com/@hexlet/java-arrays-for-update)

Ключевая строчка: `emails[i] = normalizedEmail;`. В ней происходит перезапись элемента под индексом `i`.

Цикл `for` можно комбинировать с массивами в любых вариантах. Массив не обязательно перебирать полностью и от начала до конца. Можно например смотреть только каждый второй элемент или двигаться до половины. Все это зависит от конкретной задачи.

Точно так же массивы сочетаются с `while`. Единственное что нужно массивам – индекс.

# Агрегация—Java
Распространенный вариант использования циклов с массивами — **агрегация**. Агрегацией называются любые вычисления, которые, как правило, строятся на основе всего набора данных, например, поиск максимального, среднего, суммы и так далее. Процесс агрегации не требует знания нового синтаксиса, но влияет на алгоритм решения задач. Поэтому имеет смысл рассмотреть его отдельно. Начнем с поиска максимального.

```
class MyArrayUtils {
    public static Integer calculateMax(int[] numbers) {
        // Если массив пустой, то у него не может быть максимального
        // В подобных ситуациях принято возвращать null
        if (numbers.length == 0) {
            return null;
        }

        // Сравнение элементов нужно начать с какого-то первого элемента
        var max = numbers[0]; // Принимаем за максимальное первый элемент
        // Обход начинаем со второго элемента
        for (var i = 1; i < numbers.length; i++) {
            var currentElement = numbers[i];
            // Если текущий элемент больше максимального,
            // то он становится максимальным
            if (currentElement > max) {
                max = currentElement;
            }
        }

        // Не забываем вернуть максимальное число
        return max;
    }
}

int[] emptyArray = {};
System.out.println(MyArrayUtils.calculateMax(emptyArray)); // => null

int[] numbers = { 3, 2, -10, 38, 0 };
System.out.println(MyArrayUtils.calculateMax(numbers)); // => 38
```

[https://replit.com/@hexlet/java-arrays-aggregation-max](https://replit.com/@hexlet/java-arrays-aggregation-max)

Почему это пример агрегации? Здесь мы видим _вычисление_, которое включает в себя сравнение всех элементов для поиска одного, которое станет результатом этой операции.

Обратите внимание, что начальным значением `max` взят первый элемент, а не, скажем, число `0`. Ведь может оказаться так, что все числа в массиве меньше `0`, и тогда мы получим неверный ответ.

Теперь рассмотрим поиск суммы:

```
class MyArrayUtils {
    public static int calculateSum(int[] numbers) {
        // Начальное значение суммы
        var sum = 0;
        for (var i = 0; i < numbers.length; i++) {
            // Поочередно складываем все элементы
            sum += numbers[i];
        }

        return sum;
    }
}

// Сумма элементов всегда возвращает какое-то число
// Если массив пустой, то сумма его элементов 0
int[] emptyArray = {};
System.out.println(MyArrayUtils.calculateSum(emptyArray)); // => 0

int[] numbers = { 3, 2, -10, 38, 0 };
System.out.println(MyArrayUtils.calculateSum(numbers)); // => 33

// Процесс вычислений
var sum = 0;
sum = sum + 3; // 3
sum = sum + 2; // 5
sum = sum + -10; // -5
sum = sum + 38; // 33
sum = sum + 0; // 33
```

[https://replit.com/@hexlet/java-arrays-aggregation-sum](https://replit.com/@hexlet/java-arrays-aggregation-sum)

Алгоритм поиска суммы значительно проще, но обладает парой важных нюансов.

Чему равна сумма элементов пустого массива? С точки зрения математики такая сумма равна `0`. Что в принципе совпадает со здравым смыслом. Если у нас нет яблок, значит у нас есть `0` яблок (количество яблок равно нулю). Функции в программировании работают по этой логике.

Второй момент связан с начальным элементом суммы. У переменной `sum` есть начальное значение равное 0. Зачем вообще задавать значение? Любая повторяющаяся операция начинается с какого-то значения. Нельзя просто так объявить переменную и начать с ней работать внутри цикла. Это приведет к неверному результату. Представим что мы хотим посчитать не сумму, а произведение чисел:

```
// Начальное значение не задано
// Автоматически присвоен 0
int mult;

// первая итерация цикла
mult = mult * 2; // ?
```

В результате такого вызова, внутри `mult` окажется `0`. Почему для умножения нужна единица? Очень легко проверить, что все остальные варианты приведут к неверному результату. Если начальное значение будет равно 0, то результатом умножения всегда будет 0.

В математике существует понятие **нейтральный элемент операции** (у каждой операции свой элемент). Это понятие имеет очень простой смысл. Операция с этим элементом не изменяет то значение, над которым проводится операция. В сложении любое число плюс ноль дает само число. При вычитании то же самое. Даже у конкатенации есть нейтральный элемент – это пустая строка: `"" + "one"` будет `"one"`.

Агрегация далеко не всегда означает, что коллекция элементов сводится к некоторому простому значению. Результатом агрегации может быть сколь угодно сложная структура, например, массив. Подобные примеры часто встречаются в реальной жизни. Самый простой пример – это список уникальных слов в тексте.

# Цикл for-each

`for` относится к низкоуровневым циклам. Он требует задания счетчика, правил его изменения и условия остановки. Было бы значительно удобнее обходить элементы коллекции напрямую, без счетчика. Многие языки программирования решают это введением специального вида цикла. В Java тоже есть такой: _for-each_.

```
String[] userNames = {"petya", "vasya", "evgeny"};

for (var name: userNames) {
    System.out.println(name);
}
// => "petya"
// => "vasya"
// => "evgeny"
```

С _for_ этот пример выглядит так:

```
for (var i = 0; i < userNames.length; i++) {
    var name = userNames[i];
    System.out.println(name);
}
```

[https://replit.com/@hexlet/java-arrays-for-of-example](https://replit.com/@hexlet/java-arrays-for-of-example)

Как видно из примера, код, использующий _for-each_, получается значительно чище, чем с использованием цикла _for_. _for-each_ знает о том, как перебирать элементы и знает о том, когда они закончатся.

Этот цикл отлично подходит для задач агрегации:

```
class MyArrayUtils {
    public static int calculateSum(int[] numbers) {
        // Начальное значение суммы
        var sum = 0;
        for (var number : numbers) {
            sum += number;
        }

        return sum;
    }
}

int[] numbers = {3, 2, -10, 38, 0};
System.out.println(MyArrayUtils.calculateSum(numbers)); // => 33
```

С помощью _for-each_ можно обходить строку посимвольно. В этом поможет метод `toCharArray()`:

```
var greeting = "Hello";
for (var symbol : greeting.toCharArray()) {
    System.out.println(symbol);
}
// => 'H'
// => 'e'
// => 'l'
// => 'l'
// => 'o'
```

## Применимость

В большинстве задач, использующих цикл, предпочтительнее _for-each_ . Иногда его бывает недостаточно, и требуется ручное управление обходом. В таких случаях можно возвращаться к использованию _for_. Например, когда нужно идти не по каждому элементу массива, а через один:

```
for (var i = 0; i < items.length; i += 2) {
    // какой-то код
}
```

Иногда нужно обходить массив в обратном порядке. _for-each_ здесь бессилен и снова нужен _for_:

```
for (var i = items.length - 1; i >= 0; i--) {
    // какой-то код
}
```

Другие задачи вообще с массивами напрямую не связаны. К последним относятся ситуации, когда нужно перебирать числа в определенном диапазоне. В этом случае нет массива, по которому можно было бы пройтись с помощью _for-each_.

```
for (var i = 5; i < 10; i++) {
    // какой-то код
}
```

Ну и наконец, встречаются задачи, в которых нужно во время обхода менять исходный массив:

```
for (var i = 0; i < items.length; i++) {
    items[i] = /* что-то делаем */
}
```

# Удаление элементов массива

В Java не существует простого способа удалить элемент из массива. Изменение массива трансформируется в создание нового массива, в котором отсутствуют удаляемые элементы. Ниже пример реализации метода `remove()`, который удаляет элемент по определенному индексу:

```
import java.util.Arrays;

class MyArrayUtils {
    public static int[] remove(int[] values, int index) {
      // Создаем пустой массив размером на один меньше чем исходный
      // так как мы удаляем один элемент
      var result = new int[values.length - 1];

      for (var i = 0; i < values.length; i++) {
          if (i != index) { // Копируем все кроме index
              // Элементы стоящие дальше index смещаются влево
              var newIndex = i < index ? i : i - 1;
              result[newIndex] = values[i];
          }
      }

      return result;
    }
}

int[] numbers = {1, 5, 8, 100};

System.out.println(Arrays.toString(MyArrayUtils.remove(numbers, 2)));
// => [1, 5, 100]

// Исходный массив не поменялся
System.out.println(Arrays.toString(numbers));
// => [1, 5, 8, 100]

System.out.println(Arrays.toString(MyArrayUtils.remove(numbers, 0)));
// => [5, 8, 100]
```

[https://replit.com/@hexlet/java-arrays-removing-compact](https://replit.com/@hexlet/java-arrays-removing-compact)

Главное, на что нужно обратить внимание, — не происходит ли модификаций исходного массива `numbers`. Вместо этого создается новый массив `result`, который наполняется только подходящими под условие значениями. Именно так нужно воспринимать фразу "удалить из массива что-то".

По сути, код выше — пример агрегации. Только в отличие от предыдущих примеров, в которых результатом был примитивный тип, здесь результат — массив. Это совершенно нормально. Как вы увидите в дальнейшем, результат может быть и более сложной структурой. Сама операция прореживания (удаления элементов по определенным условиям) массива обычно называется **фильтрацией**.

# Управляющие инструкции

В циклах java доступны для использования две инструкции, влияющие на их поведение: `break` и `continue`. Их использование не является необходимым, но все же они встречаются на практике и поэтому про них нужно знать.

## Break

Инструкция `break` производит _выход из цикла_ (Не из метода!). Встретив ее, Java перестает выполнять текущий цикл и переходит к инструкциям, идущими сразу за циклом.

```
String[] values = {"one", "two", "stop", "three", "four", "five"};

for (var value : values) {
    if (value.equals("stop")) {
        break;
    }
    System.out.println(value);
}
System.out.println("after loop");

// => "one"
// => "two"
// => "after loop"
```

То же самое можно получить без `break`, используя цикл `while`:

```
String[] values = {"one", "two", "stop", "three", "four", "five"};

var i = 0;
// Нужна проверка на границу массива,
// иначе можно получить индекс выходящий за последний элемент
while (i < values.length && values[i] != "stop") {
    System.out.println(values[i]);
    i++;
}
```

## Continue

Инструкция `continue` позволяет пропустить итерацию цикла. Теперь выведем на экран только слово _stop_:

```
String[] values = {"one", "two", "stop", "three", "four", "five"};

for (var value : values) {
    // В условии отрицание
    if (!value.equals("stop")) {
        continue;
    }
    System.out.println(value);
}

// => "stop"
```

Эту проверку проще сделать через условие вхождения:

```
String[] values = {"one", "two", "stop", "three", "four", "five"};

for (var value : values) {
    if (value.equals("stop")) {
        System.out.println(value);
    }
    // Ничего не делаем если это не "stop"
}

// => "stop"
```

# Вложенные массивы

Кроме плоских массивов, Java поддерживает вложенные массивы. С их помощью представляют табличные данные, по которым нужно выполнять какие-то вычисления. Например, почасовую разбивку температур за неделю можно представить в виде подобной таблицы. Дальше мы можем построить график, посчитать среднее и даже предсказать погоду.

Базовый синтаксис определения таких массивов:

```
import java.util.Arrays;

// Три строки и два столбца
// Количество [] определяет уровень вложенности
// В данном случае массив двухмерный (2D)
int[][] weather = {{14, 15}, {17, 18}, {13, 14}};

// Внутри первого уровня массивы
weather[0]; // [14, 15]
weather[1]; // [17, 18]
weather[2]; // [13, 14]

// Внутри второго уровня значения
weather[0][0]; // 14
weather[1][1]; // 18

// Для печати вложенных массивов deepToString()
System.out.println(Arrays.deepToString(weather));
```

[https://replit.com/@hexlet/java-arrays-nested-arrays-multidimensional-array](https://replit.com/@hexlet/java-arrays-nested-arrays-multidimensional-array)

Возможно, с непривычки вы не всегда сразу точно увидите, как добраться до нужного элемента, но это всего лишь вопрос тренировок.

Чуть сложнее выглядит определение без инициализации:

```
// 3 строки и 2 столбца
int[][] weather = new int[3][2];
```

Вложенные массивы можно изменять напрямую, просто обратившись к нужному элементу:

```
// Наполняем как массив выше

// Первая строка
weather[0][0] = 14;
weather[0][1] = 15;

// Вторая строка
weather[1][0] = 17;
weather[1][1] = 18;

// Третья строка
weather[2][0] = 13;
weather[2][1] = 14;
```

[https://replit.com/@hexlet/java-arrays-nested-arrays-access](https://replit.com/@hexlet/java-arrays-nested-arrays-access)

Вложенность никак не ограничивается. Можно создавать массив массивов массивов и так далее.

```
int[][][] nested = {{{ 1, 2}, {3, 4}}, {{ 5, 6}, {7, 8}}};
```

## Пример использования

Для чего же могут понадобиться вложенные массивы? Таких примеров довольно много: начиная от математических концепций, например, матриц, заканчивая представлением игровых полей. Помните игру крестики-нолики? Это как раз тот самый случай:

Разберем такую задачку. Дано игровое поле для крестиков-ноликов. Нужно написать метод, который проверяет, есть ли на этом поле хотя бы один крестик или нолик, в зависимости от того, что попросят проверить.

```
// Инициализируем поле
// Значением по умолчанию - null
// Оно означает что в этой ячейке ничего нет
String[][] field = new String[3][3];

// Делаем ход
field[1][2] = "x";
// [
//     [null, null, null],
//     [null, null, "x"],
//     [null, null, null]
// ]
```

Теперь реализуем метод, который выполняет нужную проверку. В этом методе нам понадобится библиотека Apache Commons Lang и метод [ArrayUtils.contains](https://commons.apache.org/proper/commons-lang/javadocs/api-release/org/apache/commons/lang3/ArrayUtils.html#contains-int:A-int-). Она содержит метод, проверяющий вхождение элемента в массив.

```
import org.apache.commons.lang3.ArrayUtils;

class TickTackToe {
    public static boolean didPlayerMove(String[][] field, String sym) {
        // Обходим поле. Каждый элемент — это строчка в игровом поле.
        for (var row : field) {
            // метод contains проверяет присутствует ли элемент в массиве
            if (ArrayUtils.contains(row, sym)) {
                // Если присутствует, значит мы нашли то, что искали.
                return true;
            }
        }

        // Если поле было просмотрено, но ничего не нашли,
        // значит ходов не было
        return false;
    }
}
```

Проверим:

```
TickTackToe.didPlayerMove(field, "x"); // true
TickTackToe.didPlayerMove(field, "o"); // false

```

>[!warning]
> Очень интересный пример многомерных массиво и надо запомнить
> 
 public static String getSuperSeriesWinner(int[][] scores) {  
    int result = 0;  
    for (int[] score: scores) {  
        result += Integer.signum(score[0] - score[1]);  
        System.out.println(Integer.signum(score[0] - score[1]));  
    }  
    if (result > 0) {  
        return "canada";  
    }  
    if (result < 0) {  
        return "ussr";  
    }  
    return "draw";  
} 

# StringBuilder—Java

Генерация строк в циклах — задача, часто возникающая на практике. Типичный пример — метод, помогающий генерировать HTML-списки. Он принимает на вход массив элементов и возвращает HTML-список из них:

```
String[] items = {"milk", "butter", "bread"};

HtmlBuilder.buildList(items);
// Так выглядит список в HTML
// Теги <li> для каждого элемента внутри одного тега <ul>
// <ul>
//     <li>milk</li>
//     <li>butter</li>
//     <li>bread</li>
// </ul>
```

Как можно решить эту задачу "в лоб":

1.  Создать переменную `result` и записать в нее `<ul>`.
2.  Пройтись циклом по элементам коллекции и дописать в результирующую строку очередной элемент `<li>`.
3.  Добавить в конце `</ul>` и вернуть `result` из функции.

```
class HtmlBuilder {
    public static String buildList(String[] items) {
        var result = "<ul>";
        for (var item : items) {
            result = result + "<li>" + item + "</li>";
        }
        result = result + "</ul>";

        return result;
    }
}
```

Такой способ вполне рабочий, но для большинства языков программирования максимально неэффективный. Дело в том, что конкатенация порождает новую строчку вместо старой, — и подобная ситуация повторяется на каждой итерации. Причем строка становится все больше и больше. Копирование строк приводит к серьезному расходу памяти и влияет на производительность.

Правильный способ для динамической сборки строк в Java - использование класса `StringBuilder`. Он позволяет собирать строку по кусочкам без лишнего копирования. Перепишем наш пример:

```
class HtmlBuilder {
    public static String buildList(String[] items) {
        // Инициализируем с начальной строкой "<ul>"
        var result = new StringBuilder();
        result.append("<ul>");
        // Или можно сразу
        // var result = new StringBuilder("<ul>");
        for (var item : items) {
            // append дополняет строку
            result.append("<li>");
            result.append(item);
            result.append("</li>");
        }
        result.append("</ul>");

        // toString собирает все части в одну строку
        return result.toString();
    }
}
```

Размер кода практически не изменился, но способ формирования результата стал другим. Вместо перезаписи строки, создается объект, который "накапливает" внутри себя части новой строки. Затем этот объект превращается в строку с помощью метода `toString()`.

# Обработка строк через преобразование в массив

_Дана строка текста. Нужно сделать заглавной первую букву каждого слова в тексте. Для простоты считаем что мы работаем с текстом, который не содержит знаков препинания._

```
var text = "hello hexlet";
MyStringUtils.capitalizeWords(text); // "Hello Hexlet"
```

Решить ее можно многими способами. Чем больше называет человек — тем лучше. Разберем решение через массив. Для этого воспользуемся методом строки `split()`, который разделяет строку на массив используя указанный разделитель:

```
class MyStringUtils {
    public static String capitalizeWords(String sentence) {
        // split разделяет строку по пробелу
        var words = sentence.split(" ");
        // ...
    }
}
```

Следующим шагом нужно обойти массив получившихся слов и преобразовать первую букву каждого слова к верхнему регистру. Сделаем это с помощью метода [StringUtils.capitalize()](https://commons.apache.org/proper/commons-lang/javadocs/api-3.3/org/apache/commons/lang3/StringUtils.html#capitalize(java.lang.String)). Затем, соединим получившиеся слова в строку, которую и вернем наружу.

```
import org.apache.commons.lang3.StringUtils;

class MyStringUtils {
    public static String capitalizeWords(String sentence) {
        // split разделяет строку по пробелу
        var words = sentence.split(" ");
        for (var i = 0; i < words.length; i++) {
            // Приводим к верхнему регистру
            // И заменяем слово в массиве
            words[i] = StringUtils.capitalize(words[i]);
        }
        // Соединяет массив используя разделитель
        return String.join(" ", words);
    }
}
```

[https://replit.com/@hexlet/java-arrays-strings-capitalize-words](https://replit.com/@hexlet/java-arrays-strings-capitalize-words)

Так как строки неизменяемые, то `capitalize()` просто возвращает новое значение, но не меняет старое. Поэтому нужно не забыть выполнить замену старого слова на новое: `words[i] =`.

В конце появляется массив из которого нужно снова собрать строку. Сделать это проще всего с помощью метода [String.join()](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/String.html#join(java.lang.CharSequence,java.lang.Iterable)), который соединяет элементы массива в строку используя указанный соединитель. В нашем случае пробел.

У этой задачи есть и другое решение, с помощью класса `StringJoiner`. Этот класс работает как `StringBuilder`, но дополнительно позволяет указывать соединитель:

```
import org.apache.commons.lang3.StringUtils;

class MyStringUtils {
    public static String capitalizeWords(String sentence) {
        // split разделяет строку по пробелу
        var words = sentence.split(" ");
        // Указываем соединитель
        var result = new StringJoiner(" ");
        for (var word : words) {
            // Приводим к верхнему регистру
            // Добавляем в StringJoiner
            result.add(StringUtils.capitalize(word));
        }
        // Соединяет части строки используя соединитель
        return result.toString();
    }
}
```

# Вложенные циклы

Во многих языках программирования есть очень полезная функция _flatten_. В определённых задачах она сильно упрощает жизнь и сокращает количество кода. Эта функция принимает на вход многомерный массив и выпрямляет его – сводит все к одному массиву, раскрывая каждый вложенный. Посмотрим на пример:

```
int[][] matrix = {{1, 2, 3}, {4, 5, 6}};
App.flatten(matrix); // [1, 2, 3, 4, 5, 6]
```

Реализуем этот метод самостоятельно. В общем случае метод раскрывает массивы на всех уровнях вложенности. Но мы сделаем вариант метода, в котором происходит раскрытие только первого уровня. Для простоты наш метод будет выпрямлять матрицу – прямоугольную таблицу с числами. То есть количество элементов во всех вложенных массивах будет одинаково

Логика работы метода выглядит так:

1.  Инициализируем массив-результат, в который запишутся все значения
2.  Итерируем (проходим) по основному массиву и берем текущий элемент
3.  Проходим по текущему элементу. Начинаем вложенный цикл, внутри которого идём по массиву и добавляем каждый его элемент в массив-результат
4.  Возвращаем массив-результат

```
class App {
    public static int[] flatten(int[][] matrix) {
        var rowsCount = matrix.length;

        if (rowsCount == 0) {
            return new int[0];
        }

        var columnsCount = matrix[0].length;

        // Определяем, какое количество элементов будет в массиве-результате
        var elementsCount = rowsCount * columnsCount;

        // Инициализируем массив-результат
        int[] elements = new int[elementsCount];
        var index = 0;

        // Проходим по основному массиву
        for (var row: matrix) {
            // Проходим по вложенному массиву
            for (var element: row) {
                // Добавляем каждый элемент в массив-результат
                elements[index] = element;
                index++;
            }
        }

        // Возвращаем массив результат
        return elements;
    }
}

int[][] matrix = {{1, 2, 3}, {4, 5, 6}};
var result = App.flatten(matrix);
System.out.println(Arrays.toString(result));
// => [1, 2, 3, 4, 5, 6]
```

[https://replit.com/@hexlet/java-arrays-nested-loops-1](https://replit.com/@hexlet/java-arrays-nested-loops-1)

Чисто технически во вложенных циклах нет ничего особенного. Их можно вкладывать внутрь любого блока и друг в друга сколько угодно раз. Но прямой связи между внешним и вложенным циклами нет. Внутренний цикл может использовать результаты внешнего, а может и работать по своей собственной логике независимо.

Вложенные циклы коварны. Их наличие может резко увеличить сложность кода, так как появляется множество постоянно изменяющихся переменных. Становится тяжело уследить за происходящими внутри процессами. Кроме того, вложенные циклы могут указывать на использование неэффективного алгоритма решения задачи. Это не всегда так, но вероятность такая есть.

Как избавиться от вложенных циклов? Есть три варианта. Первый – ничего не делать, иногда вложенные циклы это нормально, особенно в низкоуровневых алгоритмах. Второй – переписать алгоритм так, чтобы вложенного цикла не осталось вообще, даже в вызываемых методах. Когда это невозможно – использовать третий вариант. Вынести вложенный цикл в отдельный метод, либо заменить на уже готовый метод. Например, в библиотеке [Apache Commons Lang](https://commons.apache.org/proper/commons-lang/javadocs/api-release/org/apache/commons/lang3/ArrayUtils.html#contains-int:A-int-) есть метод `ArrayUtils.contains()`, который внутри себя представляет не что иное, как обход массива в цикле.

```
import org.apache.commons.lang3.ArrayUtils;

// Этот метод заменяет собой цикл
// Но не забывайте что внутри все равно остается полный обход массива
int[] coll = {1, 2, 3, 4, 5};
ArrayUtils.contains(coll, 4); // true
```

Пример выноса вложенного цикла на flatten в отдельный метод:

```
class App {
    private static void append(int[] result, int[] current, int index) {
        // Изменяет первый массив напрямую
        // В данном случае такая реализация оправдана
        for (var item: current) {
            result[index] = item;
            index++;
        }
    }

    public static int[] flatten(int[][] matrix) {
        var rowsCount = matrix.length;

        if (rowsCount == 0) {
            return new int[0];
        }

        var columnsCount = matrix[0].length;
        var elementsCount = rowsCount * columnsCount;

        int[] elements = new int[elementsCount];
        var index = 0;

        for (var row: matrix) {
            // Нет присваивания так как меняется сам result
            append(elements, row, index);
            index += columnsCount;
        }

        return elements;
    }
}

int[][] matrix = {{1, 2, 3}, {4, 5, 6}};
var result = App.flatten(matrix);
System.out.println(Arrays.toString(result));
// => [1, 2, 3, 4, 5, 6]
```
# Теория Множеств

Теория множеств – крайне важная математическая концепция для любых разработчиков. Данные, с которыми работают программы, часто представляются как множества, а значит к ним применимы правила теории множеств. В первую очередь это касается различных операций над множествами, например, пересечения или объединения.

Это не значит, что нужно знать эту теорию от и до. Напротив, достаточно изучить ее основные понятия и некоторые операции. Этого хватит для эффективного решения подавляющего числа задач. Сама теория множеств относится к интуитивно понятным концепциям. Она хорошо ложится на здравый смысл и понятна людям даже без особой математической подготовки.

## Краткая терминология

Основное понятие теории множеств, как не удивительно — **множество**. Множеством обозначают набор объектов произвольной природы, рассматривающихся как единое целое. Простейший пример — цифры. Множество всех цифр включает в себя 10 элементов (от 0 до 9).

Но не каждый набор объектов можно назвать множеством. Существует важное условие – все элементы множества должны быть уникальными. Например, числа _1, 1 и 3_ не могут называться множеством, а _1, 3, 5_ могут.

Множества между собой могут находиться в определенных отношениях. Например, множество натуральных чисел является подмножеством целых чисел, которые в свою очередь являются подмножеством рациональных чисел и так далее. Понятие «подмножество» означает, что все элементы одного множества также входят в другое множество, называемое **надмножеством**.

Представление множеств кружками довольно удобно. Можно быстро оценить как друг с другом соотносятся разные множества.

Но математические объекты, такие как числа, не единственные возможные объекты множеств. Множеством можно назвать группу людей, стоящих на остановке в ожидании своего автобуса, или жильцов квартир одного дома, города или страны.

## Операции над множествами

На практике, представление данных в виде множеств полезно тогда, когда мы хотим что-то сделать с ними. Простой пример. Когда в Фейсбуке вы заходите на страницу другого человека, то Фейсбук показывает вам блок с общими друзьями. Если принять, что ваши друзья и друзья вашего друга — два множества, то общие друзья — множество, полученное как пересечение исходных множеств друзей.

Пересечение — один из ярких примеров операции над множествами, которая в программировании встречается повсеместно. То же самое можно сказать и о некоторых других операциях. Важно, что результатом всех этих операций являются множества, а значит они подчиняются тем же правилам, что и исходные множества. Например, сохраняется уникальность элементов.

В Java нет встроенных методов для работы с массивами как со множествами. Поэтому мы написали [свою библиотеку](https://github.com/hexlet-components/java-arrays-as-sets) для демонстрации. Ниже примеры показаны на ней

### Пересечение

Пересечением множеств называется множество, в которое входят элементы, встречающиеся во всех данных множествах одновременно.

Пример с общими друзьями:

```
import io.hexlet.utils.ArraysAsSets;

// Друзья одного человека
String[] friends1 = {"vasya", "kolya", "petya"};

// Друзья другого человека
String[] friends2 = {"igor", "petya", "sergey", "vasya", "sasha"};

// Общие друзья
ArraysAsSets.intersection(friends1, friends2);
// ["vasya", "petya"]
```

### Объединение

Объединением множеств называется множество, в которое входят элементы всех данных множеств. 

```
String[] friends1 = {"vasya", "kolya", "petya"};
String[] friends2 = {"igor", "petya", "sergey", "vasya", "sasha"};

ArraysAsSets.union(friends1, friends2);
// ["vasya", "kolya", "petya", "igor", "sergey", "sasha"]
```

Каждый друг в объединении встречается ровно один раз.

### Дополнение (разность)

Разностью двух множеств называется множество, в которое входят элементы первого множества, не входящие во второе. В программировании такая операция часто называется _diff_ (разница).

```
String[] friends1 = {"vasya", "kolya", "petya"};
String[] friends2 = {"igor", "petya", "sergey", "vasya", "sasha"};

ArraysAsSets.difference(friends1, friends2);
// ["kolya"]
```

# Сортировка массивов

Сортировка массивов — базовая алгоритмическая задача, которую нередко спрашивают на собеседованиях. Однако в реальном коде массивы сортируют, используя уже готовые методы стандартной библиотеки. В java сортировка выполняется с помощью метода `java.util.Arrays.sort()`:

```
import java.util.Arrays;
import org.apache.commons.lang3.ArrayUtils;

class Main {
    public static void main(String[] args) {
        int[] numbers = {8, 3, 10};
        // sort изменяет массив, а не возвращает новый
        Arrays.sort(numbers); // сортировка по возрастанию
        System.out.println(Arrays.toString(numbers)); // => [3, 8, 10]

        // В обратную сторону можно через ArrayUtils.reverse() выполненный после sort()
        // Тоже изменяет массив
        ArrayUtils.reverse(numbers);
        System.out.println(Arrays.toString(numbers)); // => [10, 8, 3]
    }
}
```

Тогда для чего задают подобные вопросы? Обычно собеседующий хочет узнать следующее:

1.  Насколько кандидат вообще в курсе о существовании алгоритмов
2.  Способен ли он программировать (составлять программу сам, думая своей головой)
3.  Как работает его алгоритмическое мышление

Знание алгоритмов действительно влияет на то, как мы думаем и насколько быстро соображаем. И хотя невозможно знать все алгоритмы, нужно хотя бы иметь представление о самых ключевых и в идеале уметь их реализовывать. В [нашем списке](https://ru.hexlet.io/pages/recommended-books)рекомендуемых книг есть как минимум одна книга, полностью посвященная алгоритмам.

Кроме того, Роберт Мартин в своей книге "Идеальный программист" рассказывает о подходе [Ката](https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D1%82%D0%B0) — понятии, взятом из боевых искусств.

> Принцип изучения боевого искусства на основе ката состоит в том, что повторяя ката многие тысячи раз, практик боевого искусства приучает свое тело к определенного рода движениям, выводя их на бессознательный уровень. Таким образом, попадая в боевую ситуацию, тело работает "само" на основе рефлексов, вложенных многократным повторением ката. Также считается, что ката обладают медитативным воздействием.

Роберт Мартин рекомендует время от времени решать классические алгоритмические задачки для поддержания формы. Эта тема стала настолько популярной, что если загуглить _java github kata_, то вы увидите множество репозиториев с подобными задачками.

## Сортировка

Способов сортировать массив достаточно много. Самый популярный для обучения — [пузырьковая сортировка (bubble sort)](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D0%BF%D1%83%D0%B7%D1%8B%D1%80%D1%8C%D0%BA%D0%BE%D0%BC).

Алгоритм состоит из повторяющихся проходов по сортируемому массиву. За каждый проход элементы последовательно сравниваются попарно и, если порядок в паре неверный, выполняется обмен элементов. Проходы по массиву повторяются N-1 раз или до тех пор, пока на очередном проходе не окажется, что обмены больше не нужны, что означает — массив отсортирован. При каждом проходе алгоритма по внутреннему циклу, очередной наибольший элемент массива ставится на свое место в конце массива рядом с предыдущим «наибольшим элементом», а наименьший элемент перемещается на одну позицию к началу массива («всплывает» до нужной позиции, как пузырек в воде. Отсюда и название алгоритма).

```
class MyArrayUtils {
    // метод изменяет входящий массив items
    public static void bubbleSort(int[] items) {
        var stepsCount = items.length - 1;
        // Объявляем переменную swapped, значение которой показывает был ли
        // совершен обмен элементов во время перебора массива
        boolean swapped;
        // do..while цикл. Работает почти идентично while
        // Разница в проверке. Тут она делается не до выполнения тела, а после
        // Такой цикл полезен там, где надо выполнить тело хотя бы раз в любом случае
        do {
            swapped = false;
            // Перебираем массив и меняем местами элементы, если предыдущий
            // больше, чем следующий
            for (var i = 0; i < stepsCount; i++) {
                if (items[i] > items[i + 1]) {
                    // temp – временная константа для хранения текущего элемента
                    var temp = items[i];
                    items[i] = items[i + 1];
                    items[i + 1] = temp;
                    // Если сработал if и была совершена перестановка,
                    // присваиваем swapped значение true
                    swapped = true;
                }
            }
            // Уменьшаем счетчик на 1, т.к. самый большой элемент уже находится
            // в конце массива
            stepsCount--;
        } while (swapped); // продолжаем, пока swapped == true
    }
}

int[] numbers = {3, 2, 10, -2, 0};
MyArrayUtils.bubbleSort(numbers);
System.out.println(Arrays.toString(numbers)); // => [-2, 0, 2, 3, 10]
```

[https://replit.com/@hexlet/java-arrays-sorting-bubble](https://replit.com/@hexlet/java-arrays-sorting-bubble)

Весь код этого метода делится на два уровня:

1.  Внутренний цикл _for_, который проходит по массиву от начала до конца, меняя элементы попарно, если нужно сортировать
2.  Внешний цикл _do...while_, который определяет, когда нужно остановиться. Обратите внимание, что в худшем случае этот цикл выполнится `items.length` раз, что совпадает с теоретическим худшим случаем этого алгоритма, при котором самый большой или маленький элемент находятся в противоположных концах массива от сортированного варианта

Пузырьковая сортировка – самый простой и интуитивно понятный алгоритм сортировки. Очень полезно уметь реализовывать по памяти. Попробуйте сделать это на собственном компьютере, не подсматривая в теорию.

# Big O

Когда заходит речь про алгоритмы, нельзя не упомянуть понятие «сложность алгоритма» (обозначается как Big O). Оно дает понимание того, насколько эффективен алгоритм.

Как вы помните, алгоритмов сортировок существует [много](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8#%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%BE%D0%B2_%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8). Все они выполняют одну и ту же задачу, но при этом отличаются друг от друга. В информатике алгоритмы сравниваются друг с другом по их алгоритмической сложности. Эта сложность оценивается как количество выполняемых операций алгоритмом для достижения своей цели. Например разные способы сортировки требуют очень разного количества "проходов" по массиву перед тем как массив будет полностью отсортирован. Понятно, что конкретное количество операций зависит от входных данных, например, если массив уже отсортирован, то количество операций будет минимальным (но они все равно будут, потому что алгоритм должен убедиться в том, что массив отсортирован).

Big O как раз придумана для описания алгоритмической сложности. Она призвана показать, как сильно увеличится количество операций при увеличении размера данных.

Вот некоторые примеры того, как записывается сложность: _O(1)_, _O(n)_, _O(nlog(n))_.

![Sorting Big O](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImVmZTRjNzViZmE4ZmRlOGE3OWM3YzkxZjE1MzQ0ODdkLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=1ff88f01640fbf5c68dbb2e46153e41e558fe8e465615cedb7932d7be68f21ea)

_O(1)_ описывает константную (постоянную) сложность. Такой сложностью обладает операция доступа к элементу массива по индексу. Сложность (в алгоритмическом смысле) доступа к элементу не зависит от размеров массива и является величиной постоянной. А вот функция, которая печатает на экран все элементы переданного массива, используя обычный перебор, имеет сложность _O(n)_ (линейная сложность). То есть количество выполняемых операций, в худшем случае, будет равно количеству элементов массива. Именно это количество символизирует символ _n_ в скобках.

Что такое худший случай? В зависимости от того в каком состоянии находятся начальный массив, количество операций будет разным даже при условии, что массив одного и того же размера. Чтобы проще понять, возьмем в качестве аналогии Кубик Рубика. Количество операций (действий) которые нужно проделать для сборки Кубика Рубика зависит от того, в каком положении находятся его грани перед сборкой. В некоторых случаях действий понадобится мало, в других много. И вот та ситуация, в которой таких действий понадобится больше всего и называется худшим случаем. Алгоритмическая сложность всегда оценивается по худшему случаю для выбранного алгоритма.

Еще один пример — вложенные циклы. Вспомните как работает поиск пересечений в неотсортированных массивах. Для каждого элемента из одного массива проверяется каждый элемент другого массива (либо через цикл, либо с помощью метода `includes()`, чья сложность _O(n)_, ведь в худшем случае он просматривает весь массив). Если принять, что размеры обоих массивов одинаковы и равны _n_, то получается, что поиск пересечений имеет квадратичную сложность или _O(n^2)_ (n в квадрате).

Существуют как очень эффективные, так и абсолютно неэффективные алгоритмы. Скорость работы подобных алгоритмов падает с катастрофической скоростью даже при небольшом количестве элементов. Нередко более быстрые алгоритмы быстрее не потому, что они лучше, а потому что они потребляют больше памяти или имеют возможность запускаться параллельно (и если это происходит, то работают крайне эффективно). Как и все в инженерной деятельности, эффективность — компромисс. Выигрывая в одном месте, мы проиграем где-то в другом.

![Big O](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImY3ZTg2MmEzMDljNDc4MzkwN2Q5ZGY0ZmNhYjJmNWE3LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=e6a65c6f97660656cf501a541592df4a495ca3cddc72c773d1ee507e950e2b43)

Big O, во многом, теоретическая оценка, на практике все может быть по-другому. Реальное время выполнения зависит от множества факторов среди которых: архитектура процессора, операционная система, язык программирования, доступ к памяти (последовательный или произвольный) и многое другое.

Вопрос эффективности кода довольно опасен. В силу того, что многие начинают учить программирование именно с алгоритмов (особенно в университете), им начинает казаться, что эффективность — это главное. Код должен быть быстрым.

Такое отношение к коду гораздо чаще приводит к проблемам, чем делает его лучше. Важно понимать, что эффективность — враг понимаемости. Такой код всегда сложнее, больше подвержен ошибкам, труднее модифицируется, дольше пишется. А главное, настоящая эффективность редко когда нужна сразу или вообще не нужна. Обычно тормозит не код, а, например, запросы к базе данных или сеть. Но даже если код выполняется медленно, то вполне вероятно, что именно тот участок, который вы пытаетесь оптимизировать, вызывается за все время жизни программы всего лишь один раз и ни на что не влияет, потому что работает с небольшим объемом памяти, а где-то в это время есть другой кусок, который вызывается тысячи раз, и приводит к реальному замедлению.

> Программисты тратят огромное количество времени, размышляя и беспокоясь о некритичных местах кода, и пытаются оптимизировать их, что исключительно негативно сказывается на последующей отладке и поддержке. Мы должны вообще забыть об оптимизации в, скажем, 97% случаев. Поспешная оптимизация является корнем всех зол. И, напротив, мы должны уделить все внимание оставшимся 3%. — Дональд Кнут

Перед тем, как пытаться что-то оптимизировать, обязательно прочитайте [небольшую онлайн-книжку](http://optimization.guide/), которая хорошо объясняет суть всех оптимизаций.

# Реализация массивов

Когда мы говорим про примитивные типы данных, такие как int или double, то, на интуитивном уровне, все довольно понятно. Под каждое значение выделяется некоторое количество памяти в соответствие с типом, в которой и хранится само значение. А как должна выделиться память под хранение массива? И что такое массив в памяти? На уровне хранения понятия «массив» не существует. Массив представляется цельным куском памяти, размер которого вычисляется по формуле «количество элементов» * «количество памяти под каждый элемент». Из этого утверждения есть два интересных вывода:

-   Размер массива — это фиксированная величина. Те динамические массивы, с которыми мы имеем дело, во многих языках реализованы уже внутри языка, а не на уровне железа
-   Все элементы массива имеют один тип и занимают одно и то же количество памяти. Благодаря этому появляется возможность простым умножением (по формуле, описанной ниже) получить адрес той ячейки, в которой лежит нужный нам элемент. Именно это происходит под капотом, при обращении к элементу массива под определенным индексом

![Массив в Java](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImE1NTg3YzUyODE4M2UzOTZhZDZjZjkwMjgxMzk5MTBiLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=5535377927d66d6295df14cfd991b857c57223decbe1b63ebc258ec9f2be9d6f)

Фактически, индекс в массиве — смещение относительно начала куска памяти, содержащего данные массива. Адрес, по которому расположен элемент под конкретным индексом, рассчитывается так: начальный адрес + индекс * количество памяти, занимаемое одним элементом:

```
// Инициализация массива из пяти элементов типа int
// int занимает 4 байта
// Общее количество памяти выделенное под массив int * 5 = 4 * 5 = 20 байт
int[] numbers = {19, 10, 8, 17, 9};
numbers[3]; // 17
```

Адрес элемента, соответствующего индексу 3, вычисляется так: начальный адрес + 3 * 4 (размер типа данных int). Начальный адрес — это адрес ячейки памяти, начиная с которой располагается массив. Он формируется во время выделения памяти под массив. Ниже пример расчета адресов памяти под разные элементы массива numbers:

Рассмотрим еще раз определение массива:

```
// Первый элемент
// Начальный адрес + 4 * 0 = начальный адрес
numbers[0]; // 19

// Начальный адрес + 4 * 1 = начальный адрес + 4
// То есть сместились на 4 байта
numbers[1]; // 10

// Начальный адрес + 4 * 2 = начальный адрес + 8
// То есть сместились на 8 байт
numbers[2]; // 8

// Последний элемент
// Начальный адрес + 4 * 4 = начальный адрес + 16
// То есть сместились на 16 байт
// И сам элемент занимает 4 байта. В сумме как раз 20
numbers[4]; // 9
```

Теперь должно быть понятно, почему индексы в массиве начинаются с нуля. 0 — означает отсутствие смещения.