# Hello world

Изучать язык программирования по традиции начинают с программы "Hello, World!", которая выводит этот текст на экран. На языке Java эта программа будет выглядеть так:

![Hello World](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjIyMDU5Njc3M2RmNTc1MmY4ZWZmNjg4YzM4YjMzOGNhLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=72656d915cb261af77dff059291feedcc06d56cc76db85fb3e2128880811e5de)

```
class App {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
```

[https://replit.com/@hexlet/java-basics-hello-world](https://replit.com/@hexlet/java-basics-hello-world)

Текст _Hello, World!_ появится на экране благодаря команде `System.out.println()`, где `println()` — это сокращение от английского _print line_. Она выводит на экран значение, указанное в скобках `("Hello, World!")` — в данном случае строку. Сама строка обрамляется двойными кавычками `""`. Если этого не сделать, то компилятор укажет на синтаксическую ошибку:

```
# Например, вот так
App.java:5: error: unclosed character literal
System.out.println('Hello, World!');
```

Сама команда находится внутри нескольких конструкций, которые нужны для работы даже простейших программ на Java. В данном случае это класс `App` и метод `main()`.

Сейчас мы не будем на них останавливаться, так как для их понимания нужно уметь немного программировать. Поэтому во многих заданиях они даются «как есть», то есть вам не придется их задавать самостоятельно. Когда придет время, мы их разберем.

## JShell

Двигаясь по урокам, вы постоянно будете встречаться с примерами кода и описаниями его работы. Чтобы их лучше понимать и уметь пользоваться языком, нужно постоянно практиковаться и экспериментировать.

Поэтому по возможности запускайте все примеры из теории и проводите эксперименты с непонятными моментами.

С Java проще всего начать на сайте [onecompiler](https://onecompiler.com/jshell), который позволяет запускать построчно код прямо в браузере. Попробуйте перейти туда прямо сейчас и набрать такой код:

```
System.out.println(85 * 3);
```

## Комментарии

Практически все языки программирования позволяют оставлять в коде комментарии. Они никак не используются кодом и нужны исключительно для людей: чтобы программист оставлял пометки для себя и для других программистов.

Комментарии в Java бывают трех видов:

-   **Однострочные комментарии** начинаются с `//`. После этих двух символов может следовать любой текст, вся строка не будет анализироваться и исполняться.
    
    Комментарий может занимать всю строку:
    
    ```
    // For Winterfell!
    ```
    
    Также комментарий может находиться на строке после какого-нибудь кода:
    
    ```
    System.out.println("I am the King"); // => For Lannisters!
    ```
    
-   _Многострочные комментарии_ начинаются с `/*` и заканчиваются на `*/`. Принято каждую строку начинать с символа `*`, хотя технически это и необязательно:
    
    ```
    /*
    * The night is dark and
    * full of terrors.
    */
    System.out.println("I am the King"); // => I am the King
    ```
    
-   **Документирующие комментарии** начинаются с `/**` и заканчиваются на `*/`. Уже для них обязательно каждую строку начинать с символа `*`.
    
    Документирующие комментарии — это подвид многострочных. При этом несут дополнительную функцию — их можно собрать при помощи специальной утилиты javadoc и выдать в качестве документации к вашему коду. Мы поговорим о них позже – когда разберем классы и методы.


# Инструкции 

![Инструкции](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjMxYmU5OTM3MWQxNjc4MDcwOThiYmEyZTMwZDkyYTE2LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=667f04b088c90ecb67b6fc1a034f27abd5749e94989eb83a6f16d68f1da9278e)

Инструкция — это команда для компьютера. Код на Java — это набор инструкций, которые, обычно, отделяются друг от друга символом `;`. Вот пример кода с двумя инструкциями:

```
System.out.println("Mother of Dragons");
System.out.println("Dracarys!");
```

При запуске этого кода на экран последовательно выводятся два предложения:

```
Mother of Dragons
Dracarys!
```

Почему это важно знать? Инструкция — это единица исполнения. Программа, которая запускает код на Java, выполняет инструкции строго по очереди. Разработчики должны понимать этот порядок и уметь мысленно разделять программу на независимые части, удобные для анализа.

Теоретически инструкции можно написать последовательно друг за другом без переноса на новую строчку:

```
System.out.println("Mother of Dragons."); System.out.println("Dracarys!");
```

Результат на экране будет таким же, но на практике такой подход считается плохим.

# Ошибки оформления, синтаксиса и линтера

В человеческих языках грамматика важна, но текст с ошибками чаще всего можно понять и прочитать. В программировании все строго. Любое мельчайшее нарушение, и программа не запустится.

Примером может быть забытая `;`, неправильно расставленные скобки и другие детали. Подобные ошибки называются **синтаксическими**, потому что они нарушают правила синтаксиса языка.

Если программа на Java написана синтаксически некорректно, то компилятор выводит на экран:

-   Сообщение об ошибке
-   Указание на файл
-   Строчка в файле, где по его мнению произошла ошибка

Ниже пример кода с синтаксической ошибкой:

```
System.out.println("alala
```

Если запустить код выше, то мы увидим следующее сообщение:

```
|  Error:
|  unclosed string literal
|  System.out.println("alala
```

С одной стороны, ошибки синтаксиса — самые простые, потому что они связаны исключительно с грамматическими правилами написания кода, а не с самим смыслом кода. Их легко исправить — нужно лишь найти нарушение в записи.

С другой стороны, компилятор не всегда может четко указать на это нарушение. Поэтому бывает, что забытую скобку нужно поставить не туда, куда указывает сообщение об ошибке.

## Ошибки линтера

Теперь, когда мы уже научились писать простые программы, можно немного поговорить о том, как их писать.

Код программы следует оформлять определенным образом, чтобы он был достаточно понятным и простым в поддержке.

Специальные наборы правил — **стандарты** — описывают различные аспекты написания кода. Конкретно в Java самым распространенным стандартом является стандарт от [Sun](https://checkstyle.sourceforge.io/checks.html).

В любом языке программирования существуют утилиты — так называемые **линтеры**. Они проверяют код на соответствие стандартам. В Java это [checkstyle](https://github.com/checkstyle/checkstyle). Взгляните на пример:

```
System.out.println( "Hello, World!" ); System.out.println("I'm a developer!") ;
```

Линтер будет ругаться на нарушение сразу в нескольких местах:

-   '(' is followed by whitespace. [ParenPad]
-   ')' is preceded with whitespace. [ParenPad]
-   ';' is preceded with whitespace. [NoWhitespaceBefore]
-   Only one statement per line allowed. [OneStatementPerLine]

Проанализируем данные ошибки:

-   Правило **ParenPad**, указанное в квадратных скобках, требует отсутствия пробелов после открывающейся и перед закрывающейся круглыми скобками
-   Правило **NoWhitespaceBefore** указывает, что перед точкой с запятой не нужно устанавливать лишний пробел
-   Каждую новую инструкцию принято записывать с новой строки. На это указывает правило _OneStatementPerLine_

Соблюдение данных правил не влияет на результат, но помогает писать код понятнее и проще для восприятия.

Код с учетом этих правил выглядит так:

```
System.out.println("Hello, World!");
System.out.println("I'm a developer!");
```

Теперь линтер ругаться не будет. Какой мы делаем вывод? Линтер помогает писать код, который будет легче читать и анализировать.

# Арифметические операции

![Счетные палочки](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjVhZDlmYjE1MmMwMmJmYmUwYjdkNmUxYWUwY2U5YTQ1LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=23e45b1dddb31bcf764ab04def631372501d493a3f8528241e80ecbfc3f1a256)

На базовом уровне компьютеры оперируют только числами. Даже в прикладных программах на высокоуровневых языках внутри много чисел и операций над ними.

К счастью, для старта достаточно знать обычную арифметику — с нее и начнем.

Для сложения двух чисел в математике мы пишем, например, _3 + 4_. В программировании — то же самое. Вот программа, складывающая два числа:

```
class App {
    public static void main(String[] args) {
        3 + 4;
    }
}
```

Если запустить эту программу на выполнение, то она тихо отработает и завершится. На экран ничего не будет выведено. Операция сложения, как и остальные операции, сама по себе ничего не делает, кроме сложения.

Чтобы воспользоваться результатом сложения, его нужно вывести на экран:

```
System.out.println(3 + 4);

// После запуска на экране появится результат:
// => 7
```

Кроме сложения доступны следующие операции:

-   `*` — умножение
-   `/` — деление
-   `-` — вычитание
-   `%` — [остаток от деления](https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D1%81_%D0%BE%D1%81%D1%82%D0%B0%D1%82%D0%BA%D0%BE%D0%BC)

Теперь давайте выведем на экран результат деления, результат возведения в степень и результат вычисления остатка от деления:

```
System.out.println(8 / 2); // => 4
System.out.println(3 * 3 * 3); // => 27
System.out.println(7 % 2); // => 1
```

## Операторы

Перед тем, как двигаться дальше, разберем базовую терминологию. Знак операции, такой как `+`, называют оператором. **Оператор** — просто символ, который выполняет операцию, например, сложение:

```
System.out.println(8 + 2); // => 10
```

В этом примере `+` — это оператор, а числа _8_ и _2_ — это **операнды**.

В случае сложения у нас есть два операнда:

-   Один слева
-   Другой справа от знака _+_

Операции, которые требуют наличия двух операндов, называются **бинарными**. Если пропустить хотя бы один операнд, то программа завершится с синтаксической ошибкой. Например:

```
`3 + ;`
```

Операции бывают не только бинарными. Бывают еще:

-   Унарные — с одним операндом
-   Тернарные — с тремя операндами

Причем операторы могут выглядеть одинаково, но обозначать разные операции:

```
System.out.println(-3); // => -3
```

Выше пример применения унарной операции к числу _3_. Оператор «минус» перед тройкой говорит интерпретатору — возьми число _3_ и найди противоположное, то есть _-3_.

Это немного может сбить с толку, потому что _-3_ — это одновременно и число само по себе, и оператор с операндом, но у языков программирования такая структура.

## Коммутативная операция

Мы все помним со школы: «от перемены мест слагаемых сумма не меняется». Это один из базовых и интуитивно понятных принципов арифметики — **коммутативный закон**.

Бинарная операция считается коммутативной, если вы получаете тот же самый результат, поменяв местами операнды. Очевидно, что сложение — коммутативная операция:

```
3 + 2 = 2 + 3
```

А вот вычитание — это не коммутативная операция:

```
2 - 3 ≠ 3 - 2
```

В программировании этот закон работает точно так же, как в арифметике. Более того, большинство операций не являются коммутативными. Отсюда вывод: всегда обращайте внимание на порядок того, с чем работаете.

## Композиция операций

А что, если понадобится вычислить такое выражение: _3 + 5 - 2_? Именно так мы и запишем:

```
System.out.println(3 + 5 - 2); // 3 + 5 - 2 => 8 - 2 => 6
```

Обратите внимание, что компьютер производит арифметические вычисления в правильном порядке: сначала деление и умножение, потом сложение и вычитание. Иногда этот порядок нужно изменить — об этом немного далее.

Или другой пример:

```
System.out.println(2 * 4 * 5 * 10); // 2 * 4 * 5 * 10 => 8 * 5 * 10 => 40 * 10 => 400
```

Как видно, операции можно соединять друг с другом и таким образом вычислять все более сложные составные выражения. Чтобы представить себе то, как происходят вычисления внутри интерпретатора, давайте разберем пример:

```
2 * 4 * 5 * 10
```

В этом примере:

1.  Сначала вычисляем _2 * 4_ и получаем выражение _8 * 5 * 10_
2.  Затем умножаем _8 * 5_. В итоге имеем _40 * 10_
3.  В конце концов происходит последнее умножение, и получается результат _400_

## Приоритет операций

Посмотрите внимательно на выражение _2 + 2 * 2_ и посчитайте в уме ответ. Правильный ответ: _6_. Если у вас получилось _8_, то этот урок для вас.

В школьной математике мы изучали понятие «приоритет операции». Приоритет определяет, в какой последовательности должны выполняться операции.

Например, умножение и деление имеют больший приоритет, чем сложение и вычитание:

```
2 + 3 * 2 = 8
```

Но нередко вычисления должны происходить в порядке, отличном от стандартного приоритета. В сложных ситуациях приоритет можно задавать круглыми скобками, точно так же, как в школе, например:

```
(2 + 2) * 2
```

Скобки можно ставить вокруг любой операции. Они могут вкладываться друг в друга сколько угодно раз. Вот пара примеров:

```
System.out.println(3 * (4 - 2)); // => 6
System.out.println(7 * 3 + (4 / 2) - (8 + (2 - 1))); // => 14
```

Иногда выражение сложно воспринимать визуально. Тогда можно сделать его понятнее, расставив скобки, хотя они и не повлияют на приоритет:

Было:

```
System.out.println(8 / 2 + 5 - -4 / 2); // => 11
```

Стало:

```
System.out.println(((8 / 2) + 5) - (-4 / 2)); // => 11
```

Запомните: код пишется для людей, потому что код будут читать люди, а машины будут только исполнять его. Для машин нет «более» понятного или «менее» понятного кода, независимо от того, является ли код корректным или нет.

## Числа с плавающей точкой

В математике существуют разные виды чисел, например:

-   **Натуральные** — это целые числа от 1 и больше
-   **Рациональные** — это числа с точкой, например, 0.5

С точки зрения устройства компьютеров, между этими видами чисел — пропасть. Попробуем сложить два рациональных числа:

```
0.2 + 0.1 = 0.3
```

А теперь посмотрим, что на это скажет Java:

```
0.2 + 0.1; // 0.30000000000000004
```

Операция сложения двух рациональных чисел внезапно привела к неточному вычислению результата. Тот же самый результат выдадут и другие языки программирования.

Такое поведение обуславливается ограничениями вычислительных мощностей. В отличие от чисел, объем памяти конечен — при этом бесконечное количество чисел требовало бы бесконечного количества памяти для своего хранения.

С натуральными числами эта проблема решается простым ограничением по верхней границе. Есть некоторое максимальное число, которое можно ввести:

```
System.out.println(Integer.MAX_VALUE);
// => 2147483647
```

С рациональными числами такой финт не пройдет. Дело в том, что они не выстроены в непрерывную цепочку, между _0.1_ и _0.2_ лежит бесконечное множество чисел.

А как тогда хранить рациональные числа? Подавляющее число языков программирования в этом случае опирается на единый стандарт, который описывает как организовывать память в таких случаях.

Разработчикам важно понимать, что операции с плавающими числами неточны, но эту точность можно регулировать. Это значит, что при решении задач с подобными числами необходимо прибегать к специальным трюкам, которые позволяют добиться необходимой точности.

[https://replit.com/@hexlet/java-basics-arithmetics](https://replit.com/@hexlet/java-basics-arithmetics)

# Строки
![Строки](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImQyNzU1NGQ4OWM4ZGQwNDQxYjRjMGFkNDE3MGI4ZDkwLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=47ac0f8fe1dc0e3c027fb580887ee8d7ef974f129cf957060c0e90c652326612)

## Кавычки

```
"Hello"
"Goodbye"
"G"
" "
""
```

Какие из этих пяти вариантов — строки? С первыми двумя все понятно: это точно строки, мы уже работали с подобными конструкциями. А что насчет остальных?

Любой одиночный символ в кавычках — это строка. Пустая строка `""` — это тоже строка. То есть строкой мы считаем все, что находится внутри кавычек, даже если это пробел, один символ или вообще отсутствие символов.

Представьте, что вы хотите напечатать строчку _dragon's mother_. Апостроф перед буквой **s** — это такой же символ, как одинарная кавычка. Попробуем. Такой вариант программы отработает корректно:

```
System.out.println("Dragon's mother");
```

А что, если мы хотим создать такую строку:

```
Dragon's mother said "No"
```

В ней есть и одинарные, и двойные кавычки. Как быть в этой ситуации? Если просто попытаться вывести такую строку, то мы получим ошибку:

```
// Завершится с синтаксической ошибкой
System.out.println("Dragon's mother said "No"");
```

С точки зрения Java, здесь странная конструкция из двух трех компонентов:

-   Строки _"Dragon's mother said "_
-   Строки _""_
-   Слова _No_ между ними, которые не рассматривается как строка, потому что оно не в кавычках

Привычным способом эту строчку не вывести. Для вывода таких строк используют **символ экранирования**: `\`.

Если поставить `\` перед кавычкой, это будет означать, что кавычку нужно рассматривать не как начало или конец строки, а как ее часть:

```
System.out.println("Dragon's mother said \"No\"");
```

## Экранирующие последовательности

Мы хотим показать диалог Матери Драконов со своим ребенком:

```
- Are you hungry?
- Aaaarrrgh!
```

Если вывести на экран строку с таким текстом:

```
System.out.println("- Are you hungry?- Aaaarrrgh!");
```

Получится так:

```
- Are you hungry?- Aaaarrrgh!
```

Не то, что мы хотели. Строки расположены друг за другом, а не одна ниже другой. Нам нужно как-то сказать интерпретатору «нажать на Enter» — сделать перевод строки после вопросительного знака. Это можно сделать, используя символ перевода строки: `\n`:

```
System.out.println("- Are you hungry?\n- Aaaarrrgh!");
```

результат:

```
- Are you hungry?
- Aaaarrrgh!
```

`\n` — это специальный символ. В литературе его часто обозначают как _LF_ (Line Feed). Возможно, вы сейчас подумали, что это опечатка, ведь здесь мы видим два символа `\` и `n`, но это не так. С точки зрения компьютера — это один невидимый символ перевода строки:

```
// Мы это не изучали, но вы должны знать правду
// Ниже код, который возвращает длину строки
"a".length();    // 1
"\n".length();   // 1 !!!
"\n\n".length(); // 2 !!!
```

Почему так сделано? `\n` — всего лишь способ записать символ перевода строки, но сам перевод строки по своему смыслу – это один символ, правда, невидимый.

Именно поэтому и возникла такая задача. Нужно было как-то представить его на клавиатуре. А поскольку количество знаков на клавиатуре ограничено и отдано под самые важные, то все специальные символы реализуются в виде таких обозначений.

Символ перевода строки не является чем-то специфичным для программирования. Все, кто хоть раз печатал на компьютере, использовал перевод строки, нажимая на Enter.

Во многих редакторах есть опция, позволяющая включить отображение невидимых символов. Эта опция помогает понять, где они находятся, хотя это всего лишь схематичное отображение, ведь у этих невидимых символов нет графического представления:

```
- Привет!¶
- О, привет!¶
- Как дела?
```

Устройство, которое выводит соответствующий текст, учитывает этот символ. Например, принтер при встрече с LF протаскивает бумагу вверх на одну строку, а текстовый редактор переносит весь последующий текст ниже, также на одну строку.

`\n` — это пример **экранирующей последовательности** (escape sequence). Их еще называют управляющими конструкциями. Хотя таких символов не один десяток, в программировании часто встречаются всего несколько.

Кроме перевода строки, к таким символам относятся:

-   Табуляция — разрыв, получаемый при нажатии на кнопку Tab
-   Возврат каретки (только в Windows)

Программистам часто нужно использовать перевод строки `\n` для правильного форматирования текста:

```
System.out.println("Gregor Clegane\nDunsen\nPolliver\nChiswyck");
```

На экран выведется:

```
Gregor Clegane
Dunsen
Polliver
Chiswyck
```

Обратите внимание на следующие моменты:

1.  Не имеет значения, что стоит перед или после `\n`: символ или пустая строка. Перевод будет обнаружен и выполнен в любом случае
    
2.  Помните, что строка может содержать один символ или вообще ноль символов. А еще строка может содержать только `\n`. Проанализируйте следующий пример:
    
    ```
    System.out.println("\n");
    System.out.println("Dunsen");
    ```
    
    Здесь мы сначала выводим строку «перевод строки», а потом делаем вывод обыкновенной строки. Программа выведет на экран:
    
    ```
    
    Dunsen
    ```
    
    Почему перед строкой _Dunsen_ появилось две пустые строки, а не одна? Дело в том, что `System.out.println()` при выводе значения автоматически добавляет в конец символ перевода строки.
    
    Таким образом, один перевод строки мы указали явно, передав этот символ экранирующей последовательности аргументом в функцию, а второй перевод строки добавлен самой функцией автоматически.
    
    Еще пример кода:
    
    ```
    System.out.println("Polliver");
    System.out.println("Gregor Clegane");
    System.out.println();
    System.out.println("Chiswyck\n");
    System.out.println("Dunsen");
    ```
    
    Вывод будет таким:
    
    ```
    Polliver
    Gregor Clegane
    
    Chiswyck
    
    Dunsen
    ```
    
    Сейчас у вас достаточно знаний, чтобы самостоятельно разобраться и понять, почему вывод сформировался именно таким образом.
    
3.  Если нам понадобится вывести `\n` именно как текст (два отдельных печатных символа), то можно воспользоваться уже известным нам способом экранирования, добавив еще один `\` в начале. То есть последовательность `\\n` отобразится как символы `\` и `n`, идущие друг за другом:
    
    ```
    System.out.println("Joffrey loves using \\n");
    ```
    
    на экран выйдет:
    
    ```
    Joffrey loves using \n
    ```
    

Небольшое, но важное замечание про Windows. В Windows для перевода строк по умолчанию используется `\r\n` — это связано с историческими причинами. Такая комбинация хорошо работает только в Windows, но создает проблемы при переносе в другие системы: например, когда в команде разработчиков есть пользователи как Windows, так и Linux.

Дело в том, что последовательность `\r\n` имеет разную трактовку в зависимости от выбранной кодировки. Поэтому в среде разработчиков принято всегда использовать `\n` без `\r`, так как LF всегда трактуется одинаково и отлично работает в любой системе. Не забудьте настроить ваш редактор на использование `\n`.

## Конкатенация

Программы постоянно оперируют строками. Все, что мы видим на сайтах или в мобильных приложениях, так или иначе представлено в виде текста. Этот текст чаще всего **динамический** — полученный из разных частей, которые соединяются вместе. Операция соединения строк в программировании называется **конкатенацией** и выглядит так:

```
// Оператор такой же, как и при сложении чисел,
// но здесь он имеет другой смысл (семантику)
System.out.println("Dragon" + "stone");
// => Dragonstone
```

Склеивание строк всегда происходит в том же порядке, в котором записаны операнды. Левый операнд становится левой частью строки, а правый — правой. Вот еще несколько примеров:

```
System.out.println("Kings" + "wood"); // => Kingswood
// Обратный порядок слов
System.out.println("road" + "Kings"); // => roadKings
// Конкатенировать можно абсолютно любые строки
System.out.println("King's" + "Landing"); // => King'sLanding
```

В последнем примере название города получилось с ошибкой: _King's Landing_ нужно писать через пробел. Но в наших начальных строках не было пробелов, а пробелы в самом коде вокруг символа `+` не имеют значения, потому что они не являются частью строк.

Из этой ситуации есть три выхода:

```
// Ставим пробел в левой части
System.out.println("King's " + "Landing"); //  => King's Landing
// Ставим пробел в правой части
System.out.println("King's" + " Landing"); //  => King's Landing
// Добавляем пробел отдельно
System.out.println("King's" + " " + "Landing"); //  => King's Landing
```

Пробел — такой же символ, как и другие. Чем больше пробелов, тем шире отступы:

```
System.out.println("King's " + " Landing");   // => King's  Landing
System.out.println("King's  " + "  Landing"); // => King's    Landing
```

[https://replit.com/@hexlet/java-basics-strings#Main.java](https://replit.com/@hexlet/java-basics-strings#Main.java)

# Переменные

Представьте себе задачу — нужно напечатать на экран фразу _Father!_ два раза. Эту задачу можно решить в лоб:

```
System.out.println("Father!"); // => Father!
System.out.println("Father!"); // => Father!
```

В простейшем случае так и стоит поступить, но если фраза _Father!_ начнет использоваться чаще, да еще и в разных частях программы, то придется ее везде повторять. Проблемы с таким подходом начнутся тогда, когда понадобится изменить нашу фразу, а такое происходит довольно часто. Нам придется найти все места, где использовалась фраза _Father!_ и выполнить необходимую замену. А можно поступить по-другому. Вместо копирования нашего выражения, достаточно создать переменную с этой фразой:

```
// greeting – переводится как приветствие
// var – нужен только при определении переменной
var greeting = "Father!";
System.out.println(greeting);
System.out.println(greeting);
```

Код выше состоит из таких компонентов:

![Определение переменной](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImMyNzJiMGIzMGM5ZGUxODA3MTg4ZjVmM2U0ZWIwNDk0LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=a0c28a287be204c10684177cda9bcb3e32d07eb13af589d186f3b299f6a318ba)

В строчке `var greeting = "Father!"` происходит присваивание значения `"Father!"`переменной с именем `greeting`.

Когда переменная создана, можно начать ее использовать. Она подставляется в те места, где раньше стояла наша фраза. Во время выполнения кода в строке `System.out.println(greeting)` вместо переменной подставляется ее содержимое, а затем выполняется код. В результате вывод нашей программы будет таким:

```
Father!
Father!
```

Для имени переменной используется любой набор допустимых символов, к которым относятся буквы английского алфавита, цифры, знаки `-` и `_`. При этом цифру нельзя ставить в начале. Имена переменных регистрозависимы, то есть имя `hello` и имя `heLLo` - это два разных имени и две переменные. Ниже пример с двумя разными переменными:

```
var greeting1 = "Father!";
System.out.println(greeting1);
System.out.println(greeting1);
var greeting2 = "Mother!";
System.out.println(greeting2);
System.out.println(greeting2);
```

```
Father!
Father!
Mother!
Mother!
```

[https://replit.com/@hexlet/java-basics-variables-1](https://replit.com/@hexlet/java-basics-variables-1)

Для удобства анализа программы переменные принято создавать как можно ближе к тому месту, где они используются.

## Изменение переменной

Само слово «переменная» говорит, что ее можно менять. И действительно, с течением времени внутри программы, значения переменных могут изменяться:

```
var greeting = "Father!";
System.out.println(greeting);
System.out.println(greeting);
// var уже не используется, так как переменная была определена выше
greeting = "Mother!";
System.out.println(greeting);
System.out.println(greeting);
```

[https://replit.com/@hexlet/java-basics-variables-2](https://replit.com/@hexlet/java-basics-variables-2)

Java — статически типизированный язык. Это значит, что тип переменной задается при определении и больше не меняется.

В примере выше мы присвоили строку при создании переменной. Компилятор запоминает тип и проверяет все последующие изменения переменной. Если попробовать этой же переменной присвоить число, то мы получим следующую ошибку:

```
greeting = 5;
# Error:
# incompatible types: int cannot be converted to java.lang.String
# несовместимые типы: число не может быть превращено в строку
```

Компилятор делает такую проверку без запуска кода на выполнение, именно поэтому такой вид типизации называют **статическим**. В JavaScript, Ruby, PHP, Python и других динамических языках подобное поведение не является ошибкой, переменная может легко изменить свой тип в процессе работы.

## Ошибки при работе с переменными

Порядок инструкций в коде с переменными имеет огромное значение. Переменная должна быть определена до того, как будет использована. Ниже пример ошибки, которую очень часто допускают новички:

```
System.out.println(greeting);
var greeting = "Father!";
```

Запуск программы выше завершается с ошибкой:

```
Error: java: cannot find symbol
symbol: variable greeting
```

Ошибка **cannot find symbol** означает, что в коде используется переменная, которая не определена. Причем в самой ошибке об этом говорят прямо: `variable greeting`.

Кроме неправильного порядка определения, еще встречаются банальные опечатки, причем как при использовании переменной, так и при ее объявлении.

Еще одна распространенная ошибка — попытаться объявить уже объявленную переменную:

```
var greeting = "Father!";
var greeting = "Father!";
```

Так делать нельзя. Придется создать новую переменную.

Количество подобных ошибок уменьшается за счет использования правильно настроенного редактора. Такой редактор подсвечивает имена, которые используются без объявления, и предупреждает о возможных проблемах.

## Выражения в определениях

Переменные полезны не только для хранения и переиспользования информации, но и для упрощения сложных вычислений.

Давайте рассмотрим пример: нужно перевести евро в рубли через доллары. Подобные конвертации через промежуточную валюту часто делают банки при покупках за рубежом.

Для начала переведем 50 евро в доллары. Допустим, что один евро — 1.25 доллара:

```
var dollarsCount = 50 * 1.25;
System.out.println(dollarsCount);
```

В предыдущем блоке мы записывали в переменную конкретное значение. А здесь справа от знака равно находится **выражение**:

```
var dollarsCount = 50 * 1.25;
```

Программа вычислит результат _62.5_ и запишет его в переменную. С точки зрения программы не важно, что написано: _62.5_ или _50 * 1.25_. Оба варианта — выражения, которые надо вычислить. И они вычисляются в одно и то же значение _62.5_.

Любая строка — выражение. Причем и конкатенация строк — тоже выражение. Когда программа видит выражение, она вычисляет его и **возвращает** результат.

Вот несколько примеров выражений. В комментариях справа от каждого выражения записано итоговое значение:

```
62.5            // 62.5
50 * 1.25       // 62.5
120 / 10 * 2    // 24
"Hexlet"         // "Hexlet"
"Good" + "will" // "Goodwill"
```

В тех местах, где ожидается выражение, можно поставить любое вычисление — так работают правила построения кода. Причем вычисление может быть не только математическое, но и строковое — например, конкатенация. При этом программа останется работоспособной.

По этой причине невозможно описать и показать все случаи использования всех операций. Программы состоят из множества комбинаций выражений, и понимание этой концепции — один из ключевых шагов на вашем пути.

Вернемся к нашей валютной программе. Запишем стоимость доллара в рублях, как отдельную переменную. Вычислим цену 50 евро в долларах, умножив их на 1.25. Допустим, что 1 доллар — 60 рублей:

```
var rublesPerDollar = 60;
var dollarsCount = 50 * 1.25; // 62.5
var rublesCount = dollarsCount * rublesPerDollar; // 3750
System.out.println(rublesCount); // => 3750
```

А теперь давайте добавим к выводу текст с помощью конкатенации:

```
var rublesPerDollar = 60;
var dollarsCount = 50 * 1.25; // 62.5
var rublesCount = dollarsCount * rublesPerDollar; // 3750
System.out.println("The price is " + rublesCount + " rubles");
// => The price is 3750 rubles
```

[https://replit.com/@hexlet/java-basics-variables-3](https://replit.com/@hexlet/java-basics-variables-3)

Любая переменная может быть частью любого выражения. В момент вычисления вместо имени переменной подставляется ее значение. Значение `dollarsCount` вычисляется до того, как она начнет использоваться в других выражениях. Когда подходит момент использования переменной, Java знает значение, потому что уже вычислил его.

## Переменные и конкатенация

Переменные и конкатенацию можно объединять. Синтаксически ничего не меняется, ведь мы умеем конкатенировать — то есть склеивать две строки:

```
var what = "Kings" + "road";
System.out.println(what); // => Kingsroad
```

Значит, мы сумеем конкатенировать строку и одну переменную, в которой записана строка:

```
var first = "Kings";
var what = first + "road";
System.out.println(what); // => Kingsroad
```

Можно даже конкатенировать две переменные, в которых записаны строки:

```
var first = "Kings";
var last = "road";
var what = first + last;
System.out.println(what); //=> Kingsroad
```

[https://replit.com/@hexlet/java-basics-variables-4](https://replit.com/@hexlet/java-basics-variables-4)

## Константы

Некоторые данные никогда не меняются — например, математические постоянные. Возьмем число _π_. Приближенно оно всегда равно _3.14_ и не может измениться.

Для обращения к подобным данным в Java принято использовать константы:

```
final var PI = 3.14;
System.out.println(PI); // 3.14
```

[https://replit.com/@hexlet/java-basics-variables-5](https://replit.com/@hexlet/java-basics-variables-5)

В отличие от переменных, в начале определения константы используют ключевое слово `final`. Оно сообщает компилятору запрет на изменение. Любая попытка поменять константу приведет к ошибке.

Константы принято именовать буквами в верхнем регистре с `_` в качестве разделителя. Константа, как и переменная, может использоваться в любом выражении. Единственное ограничение — константу нельзя изменить, что звучит довольно логично.

# Именование

![Именование](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjE0YjY2MzA2OWY5MzQ5MTE2YTVkMzQyOTMxYzUxN2ExLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=2d81b9af53915a58d0bef8c3dc1e11a7acc362c1a4b35d49904e8526f598ba9b)

Представим себе, что программа из прошлого урока выглядит так:

```
var x = "Father!";
System.out.println(x);
System.out.println(x);
```

Она по-прежнему работает, но в ней изменилось имя переменной на `x`. Компьютеру без разницы, как мы называем переменные. Названия важны для программистов, ведь мы гораздо чаще читаем код, чем пишем. Причем не свой, а написанный другими людьми. От качества и понятности имен переменных зависит половина успеха в анализе кода.

Лучше посидеть и придумать название, которое описывает суть переменной, чем назвать ее как попало, а в будущем переделывать. Постарайтесь давать им такие имена, чтобы они были максимально понятны без контекста, без изучения окружающего кода.

Существует общепринятое правило: не используйте транслит для имен, только английский язык. Если вы испытываете сложности с английским, то пользуйтесь переводчиком. Со временем, копаясь в чужом коде, вы сформируете правильные понятия для именования.

Среди разработчиков есть шутка: «самое сложное в программировании — названия переменных и инвалидация кеша». Придумывать названия и правда сложно. Как бы вы назвали переменную, в которой хранится «количество неоплаченных заказов от клиентов, имеющих задолженность в предыдущем квартале»?

## Именование переменных

`greeting` — пример простого имени, но не все имена так просты. Довольно часто они составные, то есть включают в себя несколько слов. Например, «имя пользователя». В разных языках применяются разные стили кодирования, и имя переменной будет отличаться.

В именовании переменных можно выделить четыре основных подхода, которые иногда комбинируют друг с другом. Все эти подходы проявляют себя, когда имя переменной состоит из нескольких слов:

-   kebab-case — составные части переменной разделяются дефисом (`my-super-var`)
-   snake_case — для разделения используется подчеркивание (`my_super_var`)
-   CamelCase — каждое слово в переменной пишется с заглавной буквы (`MySuperVar`)
-   lowerCamelCase — каждое слово в переменной пишется с заглавной буквы, кроме первого (`mySuperVar`)

В Java используется CamelCase и его вариация lowerCamelCase, при котором первая буква первого слова — строчная.

Именно lowerCamelCase применяется для переменных. Это значит, что имена соединяются друг с другом, при этом все имена кроме первого становятся с заглавной буквы: `userName`. С тремя словами это выглядит так: `mySuperVariable`.

Посмотрим, как это выглядит в коде:

```
var firstName = "John";
System.out.println(firstName); // => John

var playerNumber = 24;
System.out.println(playerNumber); // => 24
```

## Магические числа

Вспомним один из прошлых уроков:

```
// Перевод евро в рубли через доллары
var euros = 1000;
var dollars = euros * 1.25; // 1250
var rubles = dollars * 60; // 75000
System.out.println(rubles); // => 75000
```

С точки зрения профессиональной разработки, такой код «пахнет». Так описывают код, который не соответствует так называемым лучшим практикам (best practices). И причина здесь вот в чем: уже сейчас, глядя на числа _60_ и _1.25_, вы скорее всего задаетесь вопросом: «что это за числа?».

А представьте, что будет через месяц! А как его поймет новый программист, не видевший код ранее? В нашем примере контекст восстанавливается благодаря грамотному именованию. Но в реальной жизни код значительно сложнее, и поэтому догадаться до смысла чисел зачастую невозможно.

Этот эффект вызывают **магические числа** (magic numbers) — числа, происхождение которых невозможно понять без глубокого знания происходящего внутри участка кода.

Выход из ситуации прост: достаточно создать переменные с правильными именами, как все встанет на свои места:

```
var dollarsInEuro = 1.25;
var roublesInDollar = 60;

var euros = 1000;
var dollars = euros * dollarsInEuro; // 1250
var rubles = dollars * roublesInDollar; // 75000
System.out.println(rubles); // => 75000
```

Обратите внимание на следующие детали:

-   Мы использовали именование _lowerCamelCase_
-   Две новые переменные отделены от последующих вычислений пустой строчкой. Эти переменные имеют смысл и без вычислений, поэтому такое отделение уместно, оно повышает читаемость
-   Получился хорошо именованный и структурированный код, но он длиннее прошлой версии. Так часто бывает, и это нормально, потому что код должен быть читабельным
- 
# Типы данных

![Число в виде строки](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjE5MDg2MWI5NTRlY2U1YzdhZWRmNTA1NWYzOWI5MDE3LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=bcc00f4bceb606dbe4eeace54b2b34bf1182d0bfc66f14d34412926665cbf382)

Внутри высокоуровневых языков программирования данные разделяются по типам. Например, строки относятся к типу _String_, а числа — к типу _int_.

Зачем нужны типы? Для защиты программы от трудноотловимых ошибок. Типы определяют две вещи:

-   Допустимые значения. Например, числа в Java делятся на две группы типов: целые _int_ и рациональные _float_. Такое разделение связано с техническими особенностями работы аппаратуры.
-   Набор допустимых операций. Например, операция умножения имеет смысл для типа «целые числа». Но не имеет смысла для типа «строки»: умножать слово «мама» на слово «блокнот» — бессмыслица.

Язык программирования распознает типы. Поэтому Java не позволит нам умножать строку на строку. Но позволит умножать целое число на другое целое число. Наличие типов и таких ограничений в языке защищает программы от случайных ошибок:

```
"one" * "two"
Error:
bad operand types for binary operator '*'
    first type:  java.lang.String
    second type: java.lang.String
```

Каким образом Java понимает, что за тип данных перед ним? Любое значение где-то инициализируется. В зависимости от способа инициализации, становится понятно, что именно находится перед нами.

Например, число — это просто число, не обернутое в кавычки или другие парные символы. А вот строки всегда ограничены двойными кавычками. Например, значение `"234"`считается строкой, хотя внутри нее записаны цифры:

```
// Компилятор понимает что тут число
var age = 33;
```

По-английски строки в программировании называются _strings_, а строчки текстовых файлов называются _lines_. Например, в коде выше одна строчка (_lines_) и ноль строк (_strings_). В русском языке иногда может быть путаница, поэтому во всех уроках мы будем говорить использовать такие термины:

-   **Строка** — для обозначения типа данных _strings_
-   **Строчка** — для обозначения _lines_ (строчек в текстовых файлах)

Типов данных в Java много, плюс можно создавать свои. Постепенно мы познакомимся со всеми необходимыми и научимся их правильно использовать.

## Явная типизация

До сих пор при определении переменных мы использовали ключевое слово `var`, что может удивить тех, кто имеет какой-то опыт на Java. Обычно определение переменных показывают так:

```
int x = 3;
String greeting = "Hello Hexlet!";

// Error: incompatible types: java.lang.String cannot be converted to int
int ops = "test";
```

Пришло время раскрыть карты! Java — это статически типизированный язык. В таких языках тип переменной фиксируется при ее объявлении. В большинстве языков для этого перед именем переменной указывается ее тип — в примере выше это число (int) и строка (String).

Раньше на Java создавали переменные только так, до тех пор пока не появился `var`. `var` – специальное ключевое слово, которое включает механизм **вывода типов**. Вывод типов автоматически определяет тип присваиваемого значения и связывает его с переменной. В примерах выше очевидно, где какой тип, тогда зачем его явно прописывать?

Вывод типов в Java появился в 2018 году, но в некоторых других языках он существует не один десяток лет. Первый язык с выводом типов называется ML и появился он аж в 1973 году. С тех пор вывод типов был добавлен в Ocaml, Haskell, C#, F#, Kotlin, Scala и множество других языков.

Вывод типов предпочтителен в большинстве ситуаций, однако бывает такое, что выводимый тип нас не устраивает. Тогда мы можем указать тип явно.

## Какие бывают типы

В этом уроке мы рассмотрим систему типов в Java с высоты птичьего полета, не погружаясь в детали. Но сначала ответим на вопрос, зачем вообще про них знать?

В коде мы все время оперируем данными. Эти данные имеют разную природу, могут быть по-разному организованы, что влияет на удобство работы с ними. Типы преследуют нас на каждом шагу, поэтому без них программирование на Java возможно только на очень базовом уровне.

С другой стороны, не пытайтесь запомнить всю эту информацию про типы наизусть — она дается лишь для общего представления. Все важное о типах вы и так выучите в процессе программирования. Глобально, типы данных в Java делятся на две большие группы:

-   **Примитивные** — предопределены в Java
-   **Ссылочные** или **не примитивные** — создаются самим программистом, за исключением _String_ и _Array_

У этих групп есть различия, которые мы разберем позже, когда познакомимся с `null` и объектно-ориентированным программированием. Пока достаточно знать, что имена примитивных типов начинаются с нижнего регистра (`int`), а ссылочных с верхнего (`String`).

Всего в Java восемь примитивных типов данных:

-   _byte_
-   _short_
-   _int_
-   _long_
-   _float_
-   _double_
-   _boolean_
-   _char_

Рассмотрим первые четыре типа. Это целые числа разного размера:

-   _byte_ — занимает в памяти 1 байт, значит может хранить числа от -128 до 127
-   _short_ — занимает в памяти 2 байта
-   _int_ — занимает в памяти 4 байта
-   _long_ — занимает в памяти 8 байт

Посмотрим на примере такого кода:

```
byte x = 3; // Отработает без проблем

// Error: incompatible types: possible lossy conversion from int to byte
byte y = 270;
```

Определение переменной `y` завершилось с ошибкой, потому что мы указали тип _byte_, но присвоили переменной значение _270_, которое выходит за множество допустимых значений.

Возникает закономерный вопрос. Зачем аж четыре типа для хранения чисел? Почему бы не сделать один, в который влезает почти любое большое число?

Технически так сделать можно, но мы находимся в мире инженерных решений. У любого решения всегда есть обратная сторона, поэтому невозможно сделать идеально — придется чем-то пожертвовать. В данном случае, объемом занимаемой памяти. Если оставить только _long_, то программа, активно оперирующая числами, начнет занимать слишком много места в оперативной памяти, что может быть критично.

Такая же логика использовалась для типов _float_ и _double_. Они оба отвечают за рациональные числа. Разница лишь в том, что _double_ — это двойной _float_, то есть в памяти он занимает в два раза больше места.

Создатели Java полагаются на разумность программистов, на их способность правильно подобрать нужные типы в зависимости от задачи. Для каких-то экстремальных приложений так и происходит, но в типичной разработке все просто. Программисты выбирают _int_ для целых чисел и _double_ для рациональных.

Рассмотрим оставшиеся типы данных.

Тип _boolean_ отвечает за логические значения `true` и `false`. Им посвящен целый раздел, там мы про него и поговорим.

Особняком стоит тип _char_ — символ. Это не строка, у него другой способ определения — через одиночные кавычки:

```
char ch = 'a';

// Error: incompatible types: java.lang.String cannot be converted to char
char ch2 = "b";
```

Строка, состоящая из одного символа — это не символ. Кажется, нелогично, но с точки зрения типов все так и должно быть, со временем вы это прочувствуете.

Извлечение символа из строки извлекает как раз символ, а не строку, состоящую из одного символа:

```
"hexlet".charAt(1); // 'e'
```

Хорошо, а где тип данных _String_ — строка? Дело в том, что она не является примитивным типом. Внутри она представляет собой массив символов. Несмотря на это техническое различие, строки используются наравне с примитивными типами без особых отличий.

## Значение по умолчанию

Примитивные данные всегда имеют значение, даже если они определяются без инициализации:

```
int a;
System.out.println(a); // => 0
```

У каждого примитивного типа есть свое значение по умолчанию:

```
byte    0
short   0
int     0
long    0
float   0.0
double  0.0
char    ''
boolean false
```

## Значение null

Особняком в Java стоит значение `null`. В Java оно не является типом. Это просто конкретное значение со специальным смыслом и логикой работы. Начнем с примера:

```
// Определение переменной без инициализации значением
// С var такое не сработает, так как невозможно вывести тип
String a;
```

Что находится внутри переменной `a`? Если мы ее распечатаем, то увидим `null`. Значение `null` используется для ссылочных типов, когда значение не определено.

Как такое возможно? Представьте, что мы хотим извлечь из базы данных пользователя, а его там нет. Что вернет нам запрос в базу? Вот именно для таких ситуаций и нужен `null`.

Их гораздо больше, чем может показаться на первый взгляд. Чем дальше мы будем двигаться, тем чаще он начнет встречаться:

```
var user = // тут делаем запрос в базу
// Если данных нет, то user станет null
// Запись выше равносильна
var user = null;
```

Из вышесказанного следует важный вывод. Любой ссылочный тип данных может принимать значение `null`. То есть, `null` является значением любого ссылочного типа. А вот примитивные типы и `null` не совместимы. Примитивное значение всегда должно быть определено:

```
// Error: incompatible types: <nulltype> cannot be converted to int
int x = null;
```

## Явное преобразование типов

В программировании регулярно встречаются задачи, когда один тип данных нужно преобразовать в другой. Простейший пример – работа с формами на сайтах.

Данные формы всегда приходят в текстовом виде, даже если значение число. Вот как его можно преобразовать:

```
// станет int
var number = Integer.parseInt("345");
System.out.println(number); // => 345
```

Если нужно конвертировать из примитивного типа в примитивный, то все проще. Достаточно перед значением в скобках указать желаемый тип. В результате значение справа преобразуется в значение другого типа, указанного слева:

```
var result = (int) 5.1;
System.out.println(result); // => 5
```

Преобразование типов можно использовать внутри составных выражений:

```
// Дополнительные скобки помогают визуально отделить части выражения друг от друга
var result = 10 + ((int) 5.1);
System.out.println(result); // => 15
```

[https://replit.com/@hexlet/java-basics-data-types](https://replit.com/@hexlet/java-basics-data-types)

# Вызов методов

![Метод](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjM3MjY5ZTNmZWJkNDNjZTViNzI0MWIyZGEzM2Q4Y2Y3LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=ac59fc964ff7fe1affad54bf0dc60d84e75eefa63df95583ecadf611b18600ad)

Сложение, конкатенация, нахождение остатка от деления и остальные ранее рассмотренные операции – все это довольно базовые возможности языков программирования.

Математика не ограничена арифметикой, кроме нее есть и множество других разделов со своими операциями — например, геометрия. То же самое касается и строк: их можно переворачивать, менять регистр букв, удалять лишние символы — и это только самое простое. На более высоком уровне есть прикладная логика конкретного приложения.

Программы списывают деньги, считают налоги, формируют отчеты. Количество подобных операций бесконечно и индивидуально для каждой программы. И все они должны быть как-то выражены в коде.

## Как выражаются операции

Для выражения любой произвольной операции в программировании существует понятие **функция**. Функции бывают как встроенные в язык, так и добавленные программистом. С одной встроенной функцией мы уже знакомы — это `println()`.

Функции — одна из ключевых конструкций в программировании, без них невозможно сделать практически ничего. Сначала мы научимся пользоваться уже созданными функциями, а уже потом научимся создавать свои собственные.

Здесь нужно сделать небольшую оговорку. В Java невозможно создать обычную функцию, как это позволяет делать большинство других языков. Все функции Java создаются только внутри классов, которые мы пока не разбирали. А функции, которые определены внутри классов принято называть **методами**. Поэтому в дальнейшем мы будем придерживаться этой терминологии.

Начнем с простых методов для работы над строками. Ниже пример вызова метода `length()`, который считает количество символов в строке:

```
"Hexlet".length(); // 6
"ABBA".length(); // 4
```

**Методы** — это действия, которые нужно выполнить над данными, к которым они применяются. В программировании **объектами** называют данные, у которых есть методы. В реальности все чуть сложнее, но пока нам достаточно и такого определения. В Java все не примитивные (ссылочные) типы данных — это объекты. Рассмотрим еще несколько примеров с добавлением переменных:

```
var company = "Hexlet";

var companyLength = company.length();
System.out.println(companyLength); // => 6

// Приводим к верхнему регистру
company.toUpperCase(); // "HEXLET"
```

[https://replit.com/@hexlet/java-basics-methods-calling](https://replit.com/@hexlet/java-basics-methods-calling)

Основное в работе с методами – понять принцип возврата значения. Методы почти никогда не выводят данные на экран, они их возвращают. Благодаря этому свойству, мы можем разбить нашу программу на кусочки, из которых потом составляется что-то сложное.

В примерах выше результат вызова каждого метода записывается в переменные. Но это не обязательно, мы можем использовать методы напрямую:

```
var company = "Hexlet";
System.out.println(company.length()); // => 6
```

Постепенно мы начнем знакомиться со все большим количеством встроенных методов в язык. Этих методов настолько много, что их невозможно запомнить. Хорошая новость в том, что это и не требуется. Никто не помнит названий методов наизусть.

Главное — примерно представлять себе, что требуется, а дальше можно использовать подсказки редактора, документацию и Google. Программисты постоянно сидят в документации разбираясь с тем, как что работает.

## Параметры методов

Метод `length()` не требует никаких уточнений. Он всегда работает однозначно и извлекает полную длину строки.

Но так бывает не всегда. Например, если мы хотим извлечь первый символ из строки, то нам нужно явно указать, что символ первый. Для этого в вызовы методов можно передавать параметры:

```
var searchEngine = "google";
// Возвращает первый символ (тип char)
searchEngine.charAt(0); // 'g'
```

Почему символ первый, а указан 0? В программировании отсчет начинается с нуля. Поэтому первый символ находится на нулевой позиции — «индекс 0».

Соответственно, у последнего символа индекс равен длине строки — 1:

```
// google length => 6
searchEngine.charAt(5); // 'e'
```

## Несколько параметров

Параметров может быть больше, чем один. Например, метод `replace()` работает с двумя, где первый — что заменить, а второй – на что:

```
searchEngine.replace("go", "mo"); // "moogle"
```

## Значения по умолчанию

Параметры могут содержать значение по умолчанию там, где это значение используется чаще всего.

Такая возможность в языках добавлена, чтобы избавить программиста от рутины. Простой пример – метод, извлекающий из строки подстроку, то есть часть строки.

Этот метод принимает на вход:

-   Первым параметром индекс, с которого надо начать извлекать подстроку
-   Вторым параметром — индекс, до которого нужно извлекать символы

По умолчанию берется строка до конца:

```
"hexlet".substring(1);    // "exlet"
"hexlet".substring(1, 2); // "e"
"hexlet".substring(1, 3); // "ex"
"hexlet".substring(3, 6); // "let"
```

[https://replit.com/@hexlet/java-basics-methods-calling-1](https://replit.com/@hexlet/java-basics-methods-calling-1)

# Вызов метода — выражение, неизменяемость строк

В программировании выражение — нечто возвращающее результат, который можно использовать.

Мы уже знаем достаточно много о выражениях и о принципах их построения. Сложение, вычитание, конкатенация, а также другие математические и строковые операции — все это выражения:

```
1 + 5 * 3;
"He" + "Let";
// Переменные могут быть частью выражения
rate * 5;
```

Особенность выражений в том, что они возвращают результат, который можно использовать — например, присвоить переменной или вывести на экран:

```
// Тут выражение это 1 + 5
var sum = 1 + 5;
System.out.println(1 + 5);
```

Но не все в программировании является выражением. Определение переменной — это инструкция, она не может быть частью выражения. То есть такой код выдаст ошибку:

```
// Бессмысленный код, который не сработает
10 + var sum = 1 + 5;
```

Как вы увидите дальше, выражения можно комбинировать, получая все более сложное поведение в самых неожиданных местах и неожиданным образом. Вы будете лучше понимать, как можно соединять части кода, чтобы получить нужный результат.

Поговорим о методах. Вызов метода — это выражение или нет? Мы знаем, что методы возвращают результат, то есть да, они выражения. Из этого автоматически следует много интересного.

Например, мы можем использовать вызов метода прямо в математических операциях. Вот как можно получить индекс последнего символа в слове:

```
// Индексы начинаются с нуля
var name = "Java";
// Вызов метода и вычитание вместе!
var lastIndex = name.length() - 1;
System.out.println(lastIndex); // => 3
```

В этом коде нет нового синтаксиса. Мы всего лишь соединили уже известные части, опираясь на их природу. Можно пойти еще дальше:

```
System.out.println(name.length() - 1); // => 3
```

Все это справедливо для любых методов, в том числе строковых:

```
var name = "Java";
// toUpperCase() – переводит слово в верхний регистр
System.out.println("Привет " + name.toUpperCase()); // => Привет JAVA
```

## Неизменяемость строк

Подумаем, что выведет на экран следующий код:

```
var company = "hexlet";
company.toUpperCase(); // в верхний регистр
System.out.println(company); // => ?
```

Кажется, что ответом будет `"HEXLET"`, но это не так. Эта программа выведет `"hexlet"`(проверьте на [tryjshell](https://onecompiler.com/jshell)). Почему?

Дело в том, что строки в Java неизменяемы. Не существует способа и методов, способных изменить саму строку. Любой метод строки может только вернуть новую строку.

Основная причина, почему так сделано – производительность. Строки, и другие примитивные типы данных нельзя менять практически ни в одном современном языке.

Вторая причина связана с простотой кода. Когда мы не изменяем данные, а создаем новые данные на основе старых, то код проще анализировать и модифицировать. Особенно если с данными происходит много манипуляций, с этим вам еще предстоит столкнуться.

Но как же поступать, если данные нужно поменять? Для этого достаточно заменить значение переменной:

```
var language = "JAVA";
language = language.toLowerCase();
System.out.println(language); // => java
```

С другой стороны, именно в такой ситуации можно создать новую переменную с другим именем:

```
var language = "JAVA";
var processedLanguage = language.toLowerCase();
System.out.println(processedLanguage); // => java
```

[https://replit.com/@hexlet/java-basics-methods-as-expressions](https://replit.com/@hexlet/java-basics-methods-as-expressions)

Такой подход нередко предпочтительнее по соображениям читаемости. Переменные, которые постоянно меняются, сложнее анализировать. В итоге все зависит от задачи. С опытом придет понимание, какой подход лучше.

# Цепочки вызовов методов
Обработка данных может состоять из достаточно большого количества шагов, которые нужно выполнить.

Возьмем для примера такую задачу: сформировать адрес страницы в интернете на основе введенного пользователем названия статьи. Такая задача часто возникает при публикации статей в блогах. Подобные адреса выглядят так:

```
https://ru.hexlet.io/blog/posts/iz-vahtovika-v-programmirovanie
```

Последняя часть здесь _iz-vahtovika-v-programmirovanie_ создана автоматически кодом, который мы написали на Хекслете. Кстати, у нее есть специальное название – это [слаг](https://en.wikipedia.org/wiki/Clean_URL#Slug).

Какие шаги нужно выполнить, чтобы получить подобную строку? Вот лишь некоторые из них:

-   Перевести все в нижний регистр, чтобы случайно не создавались дубли одинаковых страниц в поисковых системах
-   Очистить название от пробельных символов на концах. Там они могут случайно появиться при вводе названия
-   Выполнить транслитерацию. Лучше, когда в адресах только символы латинского алфавита
-   Вырезать все специальные символы, такие как вопросы, восклицательные знаки и тому подобное
-   Заменить все пробелы на дефисы

Часть шагов тут требует новых для нас знаний, поэтому мы их опустим. Остальные шаги будут выглядеть примерно так:

```
// Название, введенное пользователем. Для простоты на английском
var name = " How much is the fish?   \n";
// вырезаем концевые пробелы и перенос строки
name = name.trim();
// Удаляем вопрос
name = name.replace("?", "");
// Заменяем пробелы на дефис
name = name.replace(" ", "-");
// Переводим в нижний регистр
name = name.toLowerCase();
System.out.println(name); // => how-much-is-the-fish
```

Если внимательно посмотреть на этот код, то можно заметить общий шаблон. Метод возвращает данные, которые мы присваиваем переменной, и дальше по цепочке обрабатывает их.

Этот шаблон можно упростить, убрав промежуточное перезаписывание переменной:

```
var name = " How much is the fish?   ";
name = name.trim().replace("?", "").replace(" ", "-").toLowerCase();
System.out.println(name); // => how-much-is-the-fish
```

Благодаря тому, что каждый метод возвращает новую строку, мы можем продолжать обрабатывать ее, вызывая методы подряд. Если цепочка методов становится слишком длинной, то ее можно разбить на несколько строк:

```
name = name.trim()
    .replace("?", "")
    .replace(" ", "-")
    .toLowerCase();
```

[https://replit.com/@hexlet/java-basics-methods-chain](https://replit.com/@hexlet/java-basics-methods-chain)

Несмотря на удобство этого механизма, им не стоит злоупотреблять. Промежуточные переменные могут упростить понимание кода.

# Детерминированность

![Двое сидят и разговаривают о детерминированной функции](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImViNTFlOGFhZDhhOTA2YmY3YjVkYjc5YjY0OTMzYWNhLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=b9dd9fa4fc21e818280c7439771dc547a29aa892ccfc2efb63fd91ecf40f8bf9)

Независимо от того, какой язык программирования используется, методы внутри него обладают некоторыми фундаментальными свойствами. Зная эти свойства, легче прогнозировать поведение методов, способы их тестирования и место их использования. К таким свойствам относится детерминированность. Метод называется детерминированным тогда, когда для одних и тех же входных параметров он возвращает один и тот же результат. Например, метод, извлекающий символ из строки — детерминированный.

```
"wow".charAt(1); // 'o'
"wow".charAt(1); // 'o'
```

Сколько бы раз мы не вызывали этот метод, передавая туда значение `1`, он всегда вернет `'o'`. В свою очередь метод, возвращающий случайное число, не является детерминированным, так как у одного и того же входа (даже если он пустой, то есть параметры не принимаются) мы получим всегда разный результат. Насколько он разный - не важно, даже если хотя бы один из миллиона вызовов вернет что-то другое, этот метод автоматически считается недетерминированным.

```
// Метод, возвращающий случайное число
Math.random(); // 0.09856613113197676
Math.random(); // 0.8839904367241888
```

[https://replit.com/@hexlet/java-basics-pure-functions](https://replit.com/@hexlet/java-basics-pure-functions)

Зачем это нужно знать? Детерминированность серьезно влияет на многие аспекты. Детерминированные функции удобны в работе, их легко оптимизировать, легко тестировать. Если есть возможность сделать функцию детерминированной, то лучше ее такой и сделать.

## Побочные эффекты

`System.out.println()` — обычный метод. Внимание, вопрос: что возвращает метод `println()`? Ответ: что бы он не возвращал, этот возврат не имеет смысла. `println()`выводит что-то на экран, но это не возврат значения — это просто какое-то действие, которое выполняет метод.

Вывод на экран и возврат значения из метода — разные и независимые операции. Технически вывод на экран равносилен записи в файл (немного особый, но все-таки файл). С точки зрения программы вывод на экран — это так называемый **побочный эффект**. Побочным эффектом называют действия, которые соприкасаются с внешним окружением. К таким действиям относятся любые сетевые взаимодействия, взаимодействие с файловой системой (чтение и запись файлов), вывод информации на экран, печать на принтере и так далее.

Побочные эффекты — один из основных источников проблем и ошибок в программных системах. Код с побочными эффектами сложен в тестировании и ненадежен. При этом без побочных эффектов программирование не имеет смысла. Без них было бы невозможно получить результат работы программы (записать в базу, вывести на экран, отправить по сети и так далее).

Понимание принципов работы с побочными эффектами очень сильно влияет на стиль программирования и способность строить качественные программы. Эта тема полностью раскроется в последующих курсах.

# Стандартная библиотека
![Стандартная библиотека Java](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjdlMGYzNTUzNjMyMTM0YzU2NGNmOWIxZGIzMDViNmNlLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=1d9ad57af8cb945399c3696111a26612fdfbe288c7acd7430c09b6be1c882796)

Java, как и любой другой язык, поставляется с набором полезных методов. Все вместе они составляют так называемую **стандартную библиотеку**. В нее обычно входят тысячи методов, которые невозможно выучить — этого и не нужно делать. Подразумевается, что любой программист знает, где искать документацию по ним и примерно представляет себе, чего он хочет достичь. А дальше — дело техники. Если отнять у программистов интернет, то большинство не сможет ничего запрограммировать.

Для новичков эта информация часто выглядит так: «Сходи туда, не знаю куда, принеси то, не знаю что». То есть непонятно, как узнавать про эти методы, когда ты ничего не знаешь вообще. Как ни странно, не существует способа раз и навсегда познать все, что нужно познать. Любой разработчик в процессе своего профессионального взросления знакомится со все более интересными методами, решающими его задачи более элегантно, и таким образом пополняет свой арсенал.

>[!Notes]
>-   Всегда четко отслеживайте, с каким типом данных вы сейчас работаете. Почти всегда вы найдете необходимый метод в соответствующем разделе документации — например, для работы со строками нужно изучать строковые методы
>-   Периодически открывайте раздел со стандартными методами по изучаемой тематике и просто пробегайтесь по ним, изучая сигнатуры и способы использования
>-   Чаще читайте чужой код, особенно код библиотек, которые вы используете. Он весь доступен на GitHub
>  [Как искать техническую информацию](https://guides.hexlet.io/ru/how-to-search/?roistat_visit=7508315)

# Какие бывают методы


Одна из базовых тем в Java, на которой строится код – классы и объекты. Они появляются буквально с первых строчек кода, но изучить их и начать использовать не совсем просто. Поэтому изучение объектов и классов растягивается на множество уроков. В этом уроке мы чуть больше окунемся в устройство языка. Не переживайте, если пазл все еще не складывается — это нормально. Классы, объекты и методы – сложная тема, требующая времени.

Мы уже сталкивались с методами, встроенными в Java, в разных формах:

```
System.out.println();
varname.toLowerCase();
varname.substring();
Integer.parseInt();
ChronoUnit.DAYS.between();
```

Все подобные вызовы можно разбить на две группы:

1.  Вызовы методов у объектов, таких как строки
2.  Вызовы статических методов, которые не связаны с конкретными объектами

## Вызовы методов у объектов

Из объектов мы пока сталкивались только со строками, но принцип одинаковый для любых объектов:

```
// Синтаксис создания объекта
// new – создает новый объект класса
var user = new User();

// Извлекает имя у пользователя
user.getName();

// Пример с другими объектами

// Извлекает текущий день
currentdate.getDayOfMonth();
// Проверка того, что файл существует
file.exists();
```

Такие методы выполняют действия над объектами, у которых они вызываются, и часто не принимают никаких аргументов. Объекты для простоты можно воспринимать как данные, которые доступны внутри метода. Например, метод строки `toLowerCase()` внутри себя берет исходную строку, преобразует ее и возвращает результат наружу.

Кстати, `System.out.println()` — это метод объекта `out`, который лежит внутри класса `System`.

## Вызовы статических методов

Но не все вызовы методов связаны с объектами: иногда действие есть, а объекта нет. В таких случаях используются **статические методы**.

Что это может быть? Математические операции над числами или какие-то действия, которые не относятся к конкретному объекту, а имеют отношение ко всем объектам данного типа. В таком случае метод почти всегда опирается на данные, которые приходят в виде параметров:

```
// Получение случайного числа, вызов напрямую из класса Math
Math.random();

// Чтение данных по указанному пути
Files.readString(path);
```

Классы `Math` и `Files` в данном случае нужны только для вызова, потому что методы определены внутри них. Java не позволяет определять методы вне классов.

Честно говоря, не все так просто. Всегда можно придумать какой-то объект, над которым происходит вычисление. Также верно и обратное: всегда можно обойтись без объектов. Есть языки, в которых объектов нет вообще. В итоге все решает тот, кто проектирует конкретную часть кода:

```
// Без объекта, статический метод
Files.readString(path);

// Хотя можно было бы и через объект файла
path.read();
```

# Определение методов
Определение собственных методов значительно упрощает написание и поддержку программ. Например, методы позволяют объединять составные операции в одну.

К примеру, отправка письма на сайте — это достаточно сложный процесс, включающий в себя взаимодействие с интернетом. Можно определить метод и скрыть всю сложность за одной простой конструкцией:

```
// Место откуда берется метод
import com.example.Mailer;

var email = "support@hexlet.io";
var title = "Помогите";
var body = "Я написал историю успеха, как я могу получить скидку?";

// Mailer – имя класса, в котором определен метод send()
// Один маленький вызов — и много логики внутри
Mailer.send(email, title, body);
```

Внутри себя подобный вызов выполняет довольно много логики. Он соединяется с почтовым сервером, формирует правильный запрос на основе заголовка и тела сообщения, а затем все это отправляет, не забыв закрыть соединение.

## Как создавать методы

Создадим наш первый метод. Его задача — вывести на экран текущую дату:

```
Today is: 2021-10-25
```

```
import java.time.LocalDate;

// Определение метода
// Определение не вызывает и не выполняет метод
// Мы лишь говорим, что теперь такой метод существует
public class App {
    public static void showCurrentDate() {
        // Встроенный метод в Java для получения текущего времени и даты
        var currentDate = LocalDate.now();
        var text = "Today is: " + currentDate;
        System.out.println(text);
    }
}

// Вызов метода
// Обязательно указывать имя класса
App.showCurrentDate(); // => Today is: 2021-10-25
```

[https://replit.com/@hexlet/java-basics-methods-definition](https://replit.com/@hexlet/java-basics-methods-definition)

Определение метода в Java включает в себя много действий, которые мы постепенно разберем.

Их можно разделить на две группы:

-   То, что влияет на работу самого метода
-   То, как этот метод видим за пределами класса

За видимость отвечает слово _public_. Оно дает возможность вызывать методы снаружи класса, как в примере выше. Кроме него существует _private_, который разбирается на Хекслете в курсе по [ООП в Java](https://ru.hexlet.io/courses/java-oop-basics).

За работу метода отвечают:

-   _static_ — отвязывает метод от объекта и делает возможным его вызов напрямую из класса
-   _void_ используется, если метод ничего не возвращает. Например, такое определение у метода `System.out.println()`. Если метод возвращает какие-то данные, то вместо _void_указывается тип возвращаемых данных

В отличие от обычных данных, методы выполняют действия, поэтому их имена практически всегда должны быть глаголами: «построить что-то», «нарисовать что-то», «открыть что-то».

Все, что описывается внутри фигурных скобок `{}`, называется **телом метода**. Внутри тела можно описывать любой код. Считайте, что это маленькая самостоятельная программа, набор произвольных инструкций.

Тело выполняется ровно в тот момент, когда запускается метод. Причем каждый вызов метода запускает тело независимо от других вызовов. Кстати, тело может быть пустым:

```
// Минимальное определение метода
public class App {
    public static void noop() {
        // Тут мог бы быть код, но его нет
        // Обратите внимание на отступы
        // Для читаемости, любой код внутри тела сдвигается вправо на 4 пробела
    }
}
App.noop();
```

Понятие «создать метод» имеет много синонимов: «реализовать», «определить» и даже «заимплементить». Все эти термины встречаются в повседневной практике на работе.

# Метод main

Возможно вы удивитесь, но на протяжении всех предыдущих уроков, мы создавали свой собственный метод. Каркас метода был заранее написан, а от вас требовалось добавить его тело. Практика выглядела так:

```
public class App {
    public static void main(String[] args) {
        // BEGIN
        // А здесь вы писали свой код
        // END
    }
}
```

Зачем мы создавали метод? Java так устроена, что в ней невозможно выполнять код вне методов. Вы не можете просто написать код на уровне файла и запустить его. Компилятор выдаст ошибку:

```
// Файл с таким кодом не компилируется
System.out.println("Хотя казалось бы");
```

А вот такой код уже сработает:

```
public class App {
    public static void main(String[] args) {
        System.out.println("Хотя казалось бы");
    }
}
```

В работе вы часто будете видеть примеры вне методов. Почему мы и другие так делают? Исключительно для удобства.

Если на каждую строчку добавлять обертку в виде класса и метода, то объем шума и материала вырастет значительно. Всегда учитывайте это, ведь создатели этих материалов рассчитывают на то, что вы понимаете как работает Java.

Видите код, который вызывается без методов, всегда добавляйте обертку, как показано выше. Тогда вы легко сможете запустить этот код, например, локально.

## Метод main

Почему метод в наших примерах называется `main`? Мы ведь могли написать какой-то такой пример:

```
public class App {
    // run - имя выбрано произвольно
    // имя может быть любым, как захочет автор кода
    public static void run() {
        // здесь какой-то код
    }
}
```

Мы могли бы так сделать, и все бы работало, но есть один момент. В таком виде метод `main`, как мы его определяем, имеет особенное значение для Java.

Java автоматически его вызывает, когда программа запускается из консоли:

```
# В файле App находится класс с именем App
java App.java # компилирует и запускает на исполнение
# Внутри запустится метод App.main, если он определен
```

Любой другой метод автоматически не вызывается. Именно поэтому мы везде используем `main`, ведь так можно легко перенести код из тренажера к себе в редактор и запустить его на выполнение.

Обязательно ли его определять? Нет, Java не накладывает никакого ограничения на то, какие и сколько методов вы определите в классе. Так же как и нет ограничения на количество и имена классов.

Для простоты мы всегда используем имя `App`, но в реальном коде вы встретите тысячи разных имен и классов. Правда с условием, что в одном файле находится ровно один класс:

```
class MySuperClassName {
    public static void oneMethod() {
    }
    public static void twoMethod() {
    }
    public static void threeMethod() {
    }
}
```

Об этом мы поговорим в курсе по [ООП в Java](https://ru.hexlet.io/courses/java-oop-basics).

Главное, что нужно сейчас запомнить — любые статические методы вызываются через точку после имени класса, а сами вызовы происходят внутри других методов:

```
// Просто пример вызовов методов друг из друга
class MySuperClassName {
    public static void oneMethod() {
        MySuperClassName.twoMethod();
    }

    public static void twoMethod() {
        MySuperClassName.threeMethod();
    }

    public static void threeMethod() {
    }
}
```

# Возврат значений

Методы, которые мы определяли в предыдущих уроках, заканчивали свою работу тем, что печатали на экран какие-то данные:

```
public class App {
    public static void greeting() {
        System.out.println("Winter is coming");
    }
}
```

Пользы от таких методов не очень много, ведь результатом их работы невозможно воспользоваться внутри программы.

Рассмотрим это на примере. Возьмем задачу обработки электронной почты. Когда пользователь регистрируется на каком-то сайте, то он может ввести почту любым способом:

-   Добавить случайно пробелы в начале или в конце `_support@hexlet.io__`
-   Использовать буквы в разном регистре `SUPPORT@hexlet.io`

Если мы сохраним адрес в таком виде в базу данных, то пользователь не сможет войти на сайт, если будет вбивать адрес без пробелов и в другом регистре.

Чтобы этого не произошло, адрес нужно подготовить к записи в базу — привести его к нижнему регистру и обрезать пробелы по краям строки. Вся задача решается в пару строчек:

```
class App {
    public static void main(String[] args) {
        // Получаем адрес из формы
        var email = "  SuppORT@hexlet.IO";
        // Обрезаем пробельные символы
        var trimmedEmail = email.trim();
        // Приводим к нижнему регистру
        var preparedEmail = trimmedEmail.toLowerCase();
        System.out.println(preparedEmail); // => support@hexlet.io
        // Записываем в базу данных
    }
}
```

Этот код стал возможен только благодаря возврату значения. Методы `trim()` и `toLowerCase()` ничего не печатают на экран. Они **возвращают** результат своей работы, и поэтому мы можем записать его в переменные. Если бы они вместо этого печатали на экран, мы бы не могли присвоить результат их работы переменной. Как мы не можем сделать с определенным выше методом `greeting()`:

```
// Java будет ругаться, что `greeting()` ничего не возвращает
// Код не заработает
var message = App.greeting();
```

Изменим метод `greeting()` таким образом, чтобы он начал возвращать данные, а не печатать их. Для этого нам понадобится выполнить две правки:

-   Описать тип возвращаемых данных — здесь это строка `String`
-   Выполнить возврат вместо печати на экран

Посмотрим на измененный код:

```
class App {
    public static String greeting() {
        return "Winter is coming!";
    }
}
```

Вместо `void` теперь написано `String`, потому что у метода есть возврат. Так мы указали Java, что результатом работы метода будет строка.

Еще обратите внимание на `return` – это особая инструкция. Она берет выражение справа и отдает его наружу тому коду, который вызвал метод. Как только Java натыкается на `return`, выполнение метода на этом завершается:

```
// Теперь этот код работает
var message = App.greeting();
// Мы можем выполнить какие-то действия над результатом
System.out.println(message.toUpperCase()); // => WINTER IS COMING!
```

Любой код после `return` не выполняется:

```
class App {
    public static String greeting() {
        return "Winter is coming!";
        // Любой код ниже не выполнится никогда
        // Недостижимый код в Java даже не скомпилируется
        System.out.println("Я никогда не выполнюсь");
    }
}
```

Даже если метод возвращает данные, это не ограничивает его в том, что он печатает. Кроме возврата данных, мы можем и печатать их:

```
class App {
    public static String greeting() {
        System.out.println("Я появлюсь в консоли");
        return "Winter is coming!";
    }
}

// Где-то в другом методе программа
// и напечатает текст на экран, и вернет значение
var value = App.greeting();
```

Возвращать можно не только конкретное значение. Так как `return` работает с выражениями, то справа от него может появиться почти что угодно. Здесь нужно руководствоваться принципами читаемости кода:

```
class App {
    public static String greeting() {
        var message = "Winter is coming!";
        return message;
    }
}
```

Здесь мы не возвращаем переменную — возвращается всегда значение, которое находится в этой переменной. Ниже пример с вычислениями:

```
class App {
    public static long doubleFive() {
        // или return 5 + 5;
        var result = 5 + 5;
        return result;
    }
}
```

[https://replit.com/@hexlet/java-basics-return](https://replit.com/@hexlet/java-basics-return)

В этом примере в определении метода использовался `long`, так как возвращается целое число.

# Параметры методов

![Метод App.average()](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjRkZmU5NjM2MmQ2NTUwZDFjNThlNmE1ZDcyNDU4YTI4LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=642ce74fcd625a17c44b2d4780f0123a6e87e49e2d0fb7e2323ac6762a8eb5e9)

Методы могут не только возвращать значения, но и принимать их в виде параметров. С параметрами методов мы уже сталкивались много раз:

```
// Принимает на вход один параметр любого типа
System.out.println("я параметр");
// Принимает на вход индекс, по которому извлекается символ
"какой-то текст".charAt(3); // 'о'
// Принимает на вход два строковых параметра
// Первый — что ищем, второй — на что меняем
"google".replace("go", "mo"); // "moogle"
// Принимает на вход два числовых параметра
// первый — начальный индекс включительно, второй — конечный индекс не включительно
"hexlet".substring(1, 3); // "ex"
```

В этом уроке мы научимся создавать методы, которые принимают на вход параметры.

Представим, что перед нами стоит задача — реализовать статический метод `App.getLastChar()`. Он должен возвращать последний символ в строке, переданной на вход как параметр.

Вот как будет выглядеть использование этого метода:

```
// Передача параметров напрямую без переменных
App.getLastChar("Hexlet"); // 't'
App.getLastChar("Goo"); // 'o'
// Передача параметров через переменные
var name1 = "Hexlet";
App.getLastChar(name1); // 't'
var name2 = "Goo";
App.getLastChar(name2); // 'o'
```

Из описания и примеров кода мы можем сделать следующие выводы:

-   Нам нужно определить статический метод `getLastChar()` в классе `App`
-   Метод должен принимать на вход один параметр типа `String`
-   Метод должен возвращать значение типа `char`

Для начала определим метод:

```
class App {
    public static char getLastChar(String str) {
        // Вычисляем индекс последнего символа как длина строки минус 1
        return str.charAt(str.length() - 1);
    }
}
```

[https://replit.com/@hexlet/java-basics-methods-parameters-1](https://replit.com/@hexlet/java-basics-methods-parameters-1)

Разберем этот код подробнее. `char` говорит нам о типе возвращаемого значения. Далее в скобках указывается тип параметра `String` и его имя `str`.

Внутри метода мы не знаем, с каким конкретно значением идет работа, поэтому параметры всегда описываются как переменные.

Имя параметра может быть любым — оно не связано с тем, как вызывается метод. Главное, чтобы это имя отражало смысл того значения, которое содержится внутри. Конкретное значение параметра будет зависеть от вызова этого метода.

Параметры в Java всегда обязательны. Если методу нужны параметры, а мы попробуем написать код без параметра, то компилятор выдаст ошибку:

```
App.getLastChar(); // такой код не имеет смысла
method getLastChar in class App cannot be applied to given types;
  required: String
  found:    no arguments
  reason: actual and formal argument lists differ in length
```

Точно таким же образом можно указывать два и более параметра. Каждый параметр отделяется запятой:

```
class App {
    // Метод по нахождению среднего числа
    // Возвращаемый тип — double, потому что
    // при делении может получиться дробное число
    public static double average(int x, int y) {
        return (x + y) / 2.0;
    }
}

App.average(1, 5); // 3.0
App.average(1, 2); // 1.5
```

[https://replit.com/@hexlet/java-basics-methods-parameters-2](https://replit.com/@hexlet/java-basics-methods-parameters-2)

Методы могут требовать на вход любое количество параметров, которое им нужно для работы:

```
// первый параметр – что ищем
// второй параметр – на что меняем
"google".replace("go", "mo"); // moogle
```

Для создания таких методов, нужно в определении указать нужное количество параметров через запятую, дав им понятные имена. Ниже пример определения метода `replace()`, который заменяет в слове одну часть строки на другую:

```
class App {
    public static String replace(String text, String from, String to) {
        // здесь тело метода, но мы его
        // опускаем, чтобы не отвлекаться
    }
}

App.replace("google", "go", "mo"); // moogle
```

Когда параметров два и более, то практически для всех методов становится важен порядок передачи этих параметров. Если его поменять, то метод отработает по-другому:

```
// ничего не заменилось,
// так как внутри google нет mo
App.replace("google", "mo", "go"); // google
```

# Необязательные параметры методов


![Автосервис](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjM0M2ZkMDI5YWViZjA3YjFmMTIwYmIwNWRiODJiMjdkLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=099949dd954de55e4362aa78cbc75bd279df88570fe6aa5e2fdb4532a9114eb7)

В программировании большое количество функций и методов имеют параметры, которые редко меняются.

В таких случаях этим параметрам задают **значения по умолчанию**, которые можно поменять по необходимости. Этим немного сокращается количество одинакового кода.

Это наглядно видно на таком примере:

```
class App {
    // Функция возведения в степень
    // Степень — это второй параметр со значением по умолчанию 2
    function pow(x, base = 2) {
      return x ** base;
    }
}

App.pow(3); // Результат — 9, так как по умолчанию возводим во вторую степень
// Возводим в третью степень
App.pow(3, 3); // 27
```

В отличие от других языков, в Java нет возможности задать значение по умолчанию, но ее можно имитировать с помощью **перегрузки методов**.

Что это такое? Java позволяет создать несколько методов с одинаковым именем. У таких одинаковых методов должны быть:

-   Разные типы входных параметров
-   Разное количество параметров
-   Или все это одновременно

Посмотрим на примере метода, складывающего два числа:

```
class App {
    public static int sum(int x, int y) {
        return x + y;
    }
}

App.sum(2, 3); // 5
```

Теперь напишем другой метод `sum()`, который принимает только один параметр и складывает его с числом 10:

```
class App {
    public static int sum(int x) {
        return x + 10;
    }
}

App.sum(2); // 12
App.sum(2, 1); // 3
```

Компилятор без проблем выполнит такой код и создаст два метода с одним именем. Как Java узнает, какой метод нужно использовать?

Все очень просто: во время компиляции выбирается та версия метода, которая совпадает по типу и количеству параметров. Если такой метод не был найден, то возникнет ошибка.

Как минимум с одним перегруженным методом мы уже встречались — это метод `substring()`. По умолчанию он извлекает подстроку до конца, но ему можно передать второй параметр, который ограничит длину:

```
// Вызываются два разных метода с одним именем
"hexlet".substring(3); // "let"
"hexlet".substring(3, 5); // "le"
```

Перегрузка методов может приводить к дублированию кода, особенно когда речь идет про значения по умолчанию. В таких ситуациях логика одинаковая, разница лишь в начальной инициализации.

Для снижения дублирования достаточно сделать два шага:

-   Сначала определить общий метод, который принимает больше всего параметров
-   Затем вызывать его из тех методов, где есть значения по умолчанию

В коде это выглядит так:

```
class App {
    public static int sum(int x, int y) {
        return x + y;
    }

    public static int sum(int x) {
        // Вызываем уже готовый метод суммирования
        return sum(x, 10);
    }
}
```

[https://replit.com/@hexlet/java-basics-default-parameters](https://replit.com/@hexlet/java-basics-default-parameters)

# Логические операции

## Операции сравнения

Кроме арифметических операций, из школьной математики нам известны еще и операции сравнения, например:

```
5 > 4
```

Это звучит как вопрос: «Пять больше четырех?». В данном случае, ответ «да». В других случаях, ответом может быть «нет», например, для такого выражения:

```
3 < 1
```

Операции сравнения не имеют привязки к числам. Сравнивать можно практически что угодно — например, строки. Когда мы входим на какой-то сайт, внутри происходит сравнение введенного логина и пароля с теми, какие есть в базе. Если совпадение есть, то происходит авторизация.

Языки программирования адаптировали все математические операции сравнения практически в неизменном виде. Единственное серьезное отличие – **операторы равенства и неравенства**.

В математике для этого используется обычное равно `=`, но в программировании такое встречается нечасто. Во многих языках символ `=` используется для присваивания значений переменным, поэтому для сравнения взяли `==`.

Список операций сравнения в Java:

-   `<` — меньше
-   `<=` — меньше или равно
-   `>` — больше
-   `>=` — больше или равно
- == — равно
-   != — не равно

Посмотрим на пару примеров логических операций:

```
5 > 4
password == text
```

Оба примера — это выражения. Результат вычисления этих выражений — это одно из двух специальных значений:

-   `true` — «истина»
-   `false`— «ложь»

Это новый для нас тип данных — **boolean**. Он содержит всего лишь два этих значения. Так выглядит пример кода с ним:

```
var result = 5 > 4;
System.out.println(result); // => true
```

Попробуем написать метод, который принимает на вход возраст ребенка и определяет, младенец ли он. Младенцами считаются дети до года:

```
// Метод, возвращающий boolean, называется предикатом
// Обычно такие методы имеют префикс has, can, is, was и так далее
public static boolean isInfant(int age) {
    return age < 1;
}
```

Пользуемся тем фактом, что любая операция — это выражение. Поэтому единственной строчкой функции пишем «вернуть то значение, которое получится в результате сравнения `age < 1`».

В зависимости от пришедшего параметра, сравнение будет либо истинным (`true`), либо ложным (`false`). В итоге `return` вернет этот результат:

```
System.out.println(App.isInfant(3)); // => false
System.out.println(App.isInfant(0)); // => true
```

## Сравнение строк

Посмотрите на код и попытайтесь ответить, чему равны значения этих выражений:

```
// Какой результат будет в этих примерах — `true` или `false`?

"a" == "a";
"a".toUpperCase() == "a".toUpperCase();
```

Правильный ответ: в первом случае `true`, во втором — `false`. Почему? Для ответа на этот вопрос нужно немного погрузиться в то, как работают компьютеры.

В наших программах мы оперируем данными — числами, строками, булевыми значениями. Мы выполняем разнообразные операции — записываем их в переменные, умножаем, делим, конкатенируем.

Так свою работу видит программист. Но внутри компьютера все немного по-другому. Во время работы программа получает доступ и манипулирует данными через их адреса в памяти:

```
// Под хранение переменной выделяется область памяти
// Программа запоминает адрес этой области и работает с ней внутри себя
var name = "CodeBasics";
// Программа считала значение переменной по адресу, где хранится значение
System.out.println(name);
```

**Память** — это большая область для хранения данных, которая очень похожа на склад. В памяти любое значение получает номер, по которому его можно извлечь и заменить. Этот номер и есть **адрес**.

### Сравнение по ссылке и по значению

Из-за этих технических особенностей на сравнение данных между собой можно смотреть двумя способами:

-   _То же самое_ — тот же участок памяти
-   _Такое же_ — одинаковые значения независимо от того, куда указывают адреса

Пример из реальной жизни: два одинаковых стакана из одного набора. Несмотря на свою одинаковость, все же разные стаканы.

Языки программирования по-разному работают с этими понятиями. Как и во многих других языках, в Java все данные делятся на два больших типа:

-   Примитивные данные сравниваются по значению, независимо от адресов
-   Ссылочные данные сравниваются по адресам

Так работают примитивные данные:

```
// Сравнение идет по значению, а не адресам
4 == 4; // true
true == true; // true
10.0 == 10.0; // true
```

Из ссылочных данных мы пока знакомы только со строками, но они работают хитро, поэтому в качестве примера посмотрим на массивы. Не обращайте внимание на незнакомый синтаксис. Просто обратите внимание, что в этом коде вроде бы одинаковые штуки не равны друг другу:

```
// Создание массивов
int[] a = {1, 2}
int[] b = {1, 2}
// Значения одинаковые, но ссылки разные
a == b; // false
```

### Особенности строк

Строки относятся к ссылочным типам данных, но ведут себя странно:

```
// Сравнение, как у примитивных типов данных
"hm" == "hm"; // true
// Сравнение, как у ссылочных типов данных
"hexlet".toUpperCase() == "hexlet".toUpperCase(); // false
```

Программы постоянно оперируют строками, поэтому эффективность работы с ними выходит на первое место. Если бы строка всегда вела себя как ссылочный тип, то на каждое значение в коде выделялась дополнительная память:

```
// Без оптимизаций это выражение привело бы к двойному выделению памяти
// По одной единице памяти на каждый "hm"
"hm" == "hm";
```

Но этого не происходит. Когда Java встречает явно создаваемую строку, выполняется проверка, а есть ли уже в памяти такая строка.

Если есть, то она переиспользуется, если нет — создается:

```
// Выделяется память
var name1 = "Java";
// Такая строка уже есть, поэтому подставляется ссылка на уже созданную строку
// В результате экономится память
var name2 = "Java";
// Сравнение по ссылке
// Обе переменные указывают на один участок памяти
name1 == name2; // true
```

Но если строка возвращается из метода, то она помещается в свою область памяти со своим уникальным адресом:

```
// Выделяется новая память в любом случае
var name1 = "java".toUpperCase(); // "JAVA"
// Выделяется новая память в любом случае
var name2 = "java".toUpperCase(); // "JAVA"
name1 == name2; // false
```

Может показаться, что ссылочные данные приносят сплошные проблемы. На самом деле они нужны. Это станет понятно, когда мы столкнемся с изменяемостью в будущем.

В прикладном программировании мы чаще сравниваем строки по значению, чем по ссылке. Для этого в строки встроен метод `equals()`:

```
var name1 = "java".toUpperCase(); // "JAVA"
var name2 = "java".toUpperCase(); // "JAVA"
name1.equals(name2); // true
```

[https://replit.com/@hexlet/java-basics-logical-operations](https://replit.com/@hexlet/java-basics-logical-operations)

Помимо `equals()`, в строки встроен метод `equalsIgnoreCase()`, который выполняет проверку по значению без учета регистра:

```
var name1 = "java".toUpperCase(); // "JAVA"
var name2 = "java".toLowerCase(); // "java"
name1.equalsIgnoreCase(name2); // true
```

Иногда сравнение строк в Java ведет себя как сравнение значений, но никогда не делайте ставку на это. При изменении кода легко забыть поправить проверку и получить ошибку. Всегда используйте методы, когда нужно сравнивать по значению.

## Комбинирование операций и методов

Логические операции — это выражения. Значит, **логические операции можно комбинировать с другими выражениями**. Разберем на примере. Допустим, мы хотим проверить четность числа. В программировании четность проверяется через остаток от деления на 2:

-   Если остаток 0, то число было четным
-   Если остаток не 0, то число было нечетным

Остаток от деления — простая, но очень важная концепция в арифметике, алгебре, теории чисел и криптографии. Идея проста: нужно разделить число на несколько равных групп. Если в конце что-то останется, это и есть остаток от деления.

Делим конфеты поровну между людьми:

-   7 конфет, 2 человека: 2 x 3 + **остаток 1**. Значит, 7 не кратно 2
-   21 конфету, 3 человека: 3 x 7 + **остаток 0**. Значит, 21 кратно 3
-   19 конфет, 5 человек: 5 x 3 + **остаток 4**. Значит, 19 не кратно 5

В коде остаток вычисляется с помощью оператора `%`:

-   `7 % 2` → `1`
-   `21 % 3` → `0`
-   `19 % 5` → `4`

С помощью него напишем метод для проверки четности:

```
// Определен в классе App
public static boolean isEven(int number) {
    return number % 2 == 0;
}

App.isEven(10); // true
App.isEven(3); // false
```

[https://replit.com/@hexlet/java-basics-logical-operations-1](https://replit.com/@hexlet/java-basics-logical-operations-1)

В одном выражении мы скомбинировали два логических оператора:

-   == — проверка равенства
-   % — арифметический оператор остатка от деления

**Приоритет арифметических операций выше логических.** Значит, сначала вычисляется арифметическое выражение `number % 2`, затем результат участвует в логическом сравнении.

По-русски это можно расшифровать так: «Нужно вычислить остаток от деления числа `number` на 2 и сравнить с нулем; затем вернуть результат сравнения».

Рассмотрим еще один пример. Напишем метод, который принимает строку и проверяет, заглавная ли первая буква. Алгоритм действий будет такой:

1.  Получим и запишем в переменную первый символ из строки-аргумента
2.  Сравним, равен ли символ своей заглавной версии
3.  Вернем результат

А так будет выглядеть реализация в коде:

```
public static boolean isFirstLetterInUpperCase(String string) {
    var firstLetter = string.charAt(0);
    // Класс Character содержит различные методы для работы с символом
    // Метод isUpperCase() проверяет, что переданный символ в верхнем регистре
    return Character.isUpperCase(firstLetter);
}

App.isFirstLetterInUpperCase("marmont"); // false
App.isFirstLetterInUpperCase("Robb"); // true
```

# Логические операторы
Мы уже умеем писать методы, которые проверяют одиночные условия. В этом уроке мы продолжим работу с методами и научимся строить составные условия.

Такие навыки пригождаются в довольно распространенных задачах — например, при проверке пароля. Как вы знаете, некоторые сайты при регистрации просят придумать пароль от 8 до 20 символов в длину.

В математике мы бы написали `8 <= x <= 20`, но в Java такой трюк не пройдет. Нам придется сделать два отдельных логических выражения и соединить их специальным оператором «И».

Напишем метод, который принимает пароль и говорит, соответствует ли он условиям:

```
// Пароль длиннее 8 символов **И** пароль короче 20 символов
public static boolean isCorrectPassword(String password) {
    var length = password.length();
    return length > 8 && length < 20;
}

isCorrectPassword("qwerty"); // false
isCorrectPassword("qwerty1234"); // true
```

Оператор `&&` означает «И». В этом случае выражение считается истинным, только если истинен каждый _операнд_ — каждое из составных выражений. Другими словами, `&&`означает «и то, и другое».

Приоритет этого оператора ниже, чем приоритет операторов сравнения, поэтому выражение отрабатывает правильно без скобок.

Кроме `&&` часто используется оператор `||` — «ИЛИ». Он означает «или то, или другое, или оба». Операторы можно комбинировать в любом количестве и любой последовательности. Единственное исключение — когда одновременно встречаются `&&` и `||`, то приоритет лучше задавать скобками:

```
a && b || c; // Без скобок сложно понять приоритет
a && (b || c) // Приоритет очевиден
```

Рассмотрим еще один пример. Представим, что мы хотим купить квартиру, которая удовлетворяет таким условиям:

> Больше 100 м2 на любой улице **ИЛИ** больше 80 м2 на центральной улице _Main Street_

Напишем метод, проверяющий квартиру. Он принимает два параметра: площадь и название улицы:

```
isGoodApartment(91, "Queens Street"); // false
isGoodApartment(78, "Queens Street"); // false
isGoodApartment(70, "Main Street"); // false

isGoodApartment(120, "Queens Street"); // true
isGoodApartment(120, "Main Street"); // true
isGoodApartment(80, "Main Street"); // true

public static boolean isGoodApartment(int area, String street) {
  return area >= 100 || (area >= 80 && "Main Street".equals(street));
}
```

[https://replit.com/@hexlet/java-basics-logical-operators](https://replit.com/@hexlet/java-basics-logical-operators)

Область математики, в которой изучаются логические операторы, называется **булевой алгеброй**. Ниже показаны «таблицы истинности» — по ним можно определить, каким будет результат применения оператора:

### Оператор И `&&`

|A |B|A && B|
|---|---|---|
|TRUE|TRUE|**TRUE**|
|TRUE|FALSE|FALSE|
|FALSE|TRUE|FALSE|
|FALSE|FALSE|FALSE|

![Оператор И на примере папы](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImE2Mzc4YTEyNGQ2N2YwZGFiNjBhNDA5ZmViNGE4MzcxLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=7559fed2ac63937ac2c9fef94c5535e5cbe137122f4b6040b7bf566c0362a4b7)

### Оператор ИЛИ `||`

|A|B|A ❘❘ B|
|---|---|---|
|TRUE|TRUE|**TRUE**|
|TRUE|FALSE|**TRUE**|
|FALSE|TRUE|**TRUE**|
|FALSE|FALSE|FALSE|

![Оператор ИЛИ на примере папы](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjI4MDk2ZGVmZTgyNjFjYjBhNzZhZDJmYjZmMGI0MTNhLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=2c7bdbdbab75fbda9210ad7e8d226ad75366ace98a84d7dbc39f8fe965b06551)

## Отрицание

Наряду с конъюнкцией (**И**) и дизъюнкцией (**ИЛИ**), часто используется операция «**отрицание**».

Отрицание меняет логическое значение на противоположное. В программировании ему соответствует оператор `!`. Если есть метод, проверяющий четность числа, то с помощью отрицания можно выполнить проверку нечетности:

```
public static boolean isEven(int number) {
    return number % 2 == 0;
}

isEven(10);  // true
!isEven(10); // false
```

То есть мы просто добавили `!` слева от вызова метода и получили обратное действие. Отрицание можно применять не только к вызову метода, но и к целому выражению:

```
!(x == 5 || x == 3)

// Это же выражение можно записать и по-другому:
// x не равен 5 и не равен 3
x != 5 && x != 3
```

Отрицание — мощный инструмент, который позволяет лаконично выражать задуманные правила в коде без необходимости писать новые методы.

# Условные конструкции

![Условная конструкция if](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjA2ZDVkNWQ4MGExMzljZmIyMTFhYWU5MGU5MmViMzJkLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=8ee56b7b3fc8d3bbe5b312e09fd3643635b3d232b7dee07e3c36074e1d8454a0)

Условные конструкции позволяют выполнять разный код, основываясь на логических проверках. Посмотрим на таком типичном примере:

-   Человек хочет оплатить покупку с карты
-   Если на счету есть деньги, то нужная сумма спишется автоматически
-   Если денег нет, то операция будет отклонена

## Конструкция if

Для примера напишем метод, который определяет тип переданного предложения. Для начала он будет отличать обычные предложения от вопросительных:

```
public static String getTypeOfSentence(String sentence) {
    if (sentence.endsWith("?")) {
        return "question";
    }

    return "general";
}

App.getTypeOfSentence("Hodor");  // "general"
App.getTypeOfSentence("Hodor?"); // "question"
```

`if` — конструкция языка, управляющая порядком инструкций. В скобках ей передается логическое выражение, а затем описывается блок кода в фигурных скобках. Этот блок кода будет выполнен, только если условие выполняется.

Если условие не выполняется, то блок кода в фигурных скобках пропускается, и метод продолжает свое выполнение дальше. В нашем случае следующая строчка кода — `return "general";` — заставит метод вернуть строку и завершиться.

## Конструкция if-else

Условная конструкция `if` имеет несколько разновидностей. Одна разновидность включает в себя блок, который выполняется, если условие ложно:

```
if (x > 5) {
    // Если условие true
} else {
    // Если условие false
}
```

Такая структура может понадобиться при начальной инициализации значения. В примере ниже проверяется наличие `email`. Если он отсутствует, то устанавливаем значение по умолчанию, если его передали, то выполняем нормализацию:

```
// Здесь приходит email

if (email.equals("")) { // Если email пустой, то ставим дефолт
    email = "support@hexlet.io";
} else { // Иначе выполняем нормализацию
    email = email.trim().toLowerCase();
}

// Здесь используем эту почту
```

Если ветка `if` содержит `return`, то `else` становится не нужен — его можно просто опустить:

```
if (/* условие */) {
    return /* какое-то значение */;
}

// Продолжаем что-то делать, потому что else не нужен
```

## Конструкция else if

В самой полной версии конструкция `if` содержит не только ветку `else`, но и другие условные проверки с помощью `else if`. Такой вариант используется при большом количестве проверок, которые взаимоисключают друг друга:

```
if (/* что-то */) {

} else if (/* другая проверка */) {

} else if (/* другая проверка */) {

} else {

}
```

Здесь стоит обратить внимание на два момента:

-   Ветка `else` может отсутствовать
-   Количество `else if` условий может быть любым

Напишем для примера расширенный метод определяющий тип предложения. Он распознает три вида предложений:

```
App.getTypeOfSentence("Who?"); // "Sentence is question"
App.getTypeOfSentence("No");   // "Sentence is general"
App.getTypeOfSentence("No!");  // "Sentence is exclamation"

public static String getTypeOfSentence(String sentence)
{
    var sentenceType = "";

    if (sentence.endsWith("?")) {
        sentenceType = "question";
    } else if (sentence.endsWith("!")) {
        sentenceType = "exclamation";
    } else {
        sentenceType = "general";
    }

    return "Sentence is " + sentenceType;
}
```

[https://replit.com/@hexlet/java-basics-if-else](https://replit.com/@hexlet/java-basics-if-else)

Теперь все условия выстроены в единую конструкцию. Оператор `else if` — это «если не выполнено предыдущее условие, но выполнено текущее». Получается такая схема:

-   Если последний символ `?`, то "question"
-   Иначе, если последний символ `!`, то "exclamation"
-   Иначе "general"

В итоге выполнится только один из блоков кода, относящихся ко всей конструкции `if`.

## Тернарный оператор

Посмотрите на определение метода, который возвращает модуль переданного числа:

```
// Если больше нуля, то выдаем само число. Если меньше, то убираем знак
public static int abs(int number) {
    if (number >= 0) {
        return number;
    }

    return -number;
}

App.abs(10);  // 10
App.abs(-10); // 10
```

В Java существует конструкция, которая по своему действию аналогична конструкции _if-else_, но при этом является выражением. Она называется **тернарный оператор**.

Тернарный оператор — единственный в своем роде оператор, требующий три операнда. Он помогает писать меньше кода для простых условных выражений. Наш пример выше с тернарным оператором превращается в три строки кода:

```
public static int abs(int number) {
    return number >= 0 ? number : -number;
}
```

Общий шаблон выглядит так:

```
<predicate> ? <expression on true> : <expression on false>
```

То есть сначала мы записываем логическое выражение, а дальше два разных варианта поведения:

1.  Если условие истинно, выполняет вариант до двоеточия
2.  Если условие ложно, выполняет вариант после двоеточия

![Тернарный оператор](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjNhNjQwMjM0NzEwZmE5ZDYyZDlhZTFkODE1NDkwMjBiLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=a47954baa3cb5e259b6642f4884ea5a46838bdbec58fcfd8df98dc010e4ff5e9)

# Конструкция Switch

![switch как коробка передач](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjE3OTNmMTczMDVjYzMxMjExMGQyYzMyYzU5MGUxZmJkLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=7327dc9f18cd6f7e407561aaf51115f46cb1c69e6e61f03dd0aee3ffc0ed4ee3)

Многие языки используют не только условную конструкцию `if`, но и `switch` в дополнение к ней. Конструкция `switch` — это специализированная версия `if`, созданная для некоторых особых ситуаций.

Например, ее стоит использовать там, где есть цепочка `if else` с проверками на равенство:

```
if (status.equals("processing")) {
    // Делаем раз
} else if (status.equals("paid")) {
    // Делаем два
} else if (status.equals("new")) {
    // Делаем три
} else {
    // Делаем четыре
}
```

Эта составная проверка обладает одной отличительной чертой: каждая ветка здесь — это проверка значения переменной `status`. Конструкция `switch` позволяет записать этот код короче и выразительнее:

```
switch (status) {
    case "processing":
        // Делаем раз
        break;
    case "paid":
        // Делаем два
        break;
    case "new":
        // Делаем три
        break;
    default: // else
        // Делаем четыре
}
```

С точки зрения количества элементов, `switch` — довольно сложная конструкция. В нее входят:

-   Внешнее описание с ключевым словом `switch`. В нем два элемента:
    -   Переменная, по значениям которой `switch` будет выбирать поведение
    -   Фигурные скобки для вариантов выбора
-   Конструкции `case` и `default`, внутри которых описывается поведение для разных значений рассматриваемой переменной. Каждый `case` соответствует `if`, как в примере выше. Здесь `default` — это особая ситуация, соответствующая ветке `else` в условных конструкциях. Как и в случае с `else`, указывать `default` необязательно
-   Конструкция `break`, который предотвращает «проваливание». Если ее не указать, то после выполнения нужного `case`, выполнение перейдет к следующему `case`. Этот цикл будет повторяться до ближайшего `break` или до конца `switch`

Фигурные скобки в `switch` не определяют блок кода, как это было в других местах. Внутри допускается только тот синтаксис, который показан выше — там можно использовать `case`или `default`. А вот внутри каждого `case` (и `default`) ситуация другая. Здесь можно выполнять любой произвольный код:

```
switch (count) {
  case 1:
    // Делаем что-то полезное
    break;
  case 2:
    // Делаем что-то полезное
    break;
  default:
    // Что-то делаем
}
```

Иногда результат, полученный внутри `case` — это конец выполнения метода, содержащего `switch`. В таком случае его нужно как-то вернуть наружу. Для решения этой задачи есть два способа.

Первый способ — можно создать переменную перед `switch`, заполнить ее в `case` и затем вернуть значение этой переменной наружу:

```
class App {
    public static String getExplanation(int count) {
        // Объявляем переменную
        String result;

        // Заполняем
        switch(count) {
            case 1:
                result = "one";
                break;
            case 2:
                result = "two";
                break;
            default:
                result = null;
        }

        // Возвращаем
        return result;
    }
}
```

Второй способ проще и короче. Вместо создания переменной можно использовать `case`, внутри которого можно делать обычный возврат из метода. После `return` никакой код не выполняется, так что мы можем избавиться от `break`:

```
class App {
    public static String getExplanation(int count) {

        switch(count) {
            case 1:
                return "one";
            case 2:
                return "two";
            default:
                return null;
        }
    }
}
```

[https://replit.com/@hexlet/java-basics-switch](https://replit.com/@hexlet/java-basics-switch)

`Switch` хоть и встречается в коде, но технически всегда можно обойтись без него.

Польза этой конструкции в том, что она лучше выражает намерение программиста, когда нужно проверять конкретные значения переменной. В отличие от блоков `else if`, код со `switch` становится немного длиннее, но читать его гораздо проще.

# Цикл while—Основы Java

[](https://ru.hexlet.io/courses/java-basics)

![Цикл while](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImEyNDkyYjBjNGYyODljNmQ4NTliMWMxYWVmM2VmNWZiLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=4e66095c7fe2937e8b277f8b6205201fb4ea28db44796231daa8af7a1852825e)

Программы, которые мы пишем во время обучения, становятся все сложнее и объемнее. Они все еще очень далеки от реальных программ, где количество строк кода измеряется десятками и сотнями тысяч, но текущая сложность уже способна заставить напрячься людей без опыта.

Любые прикладные программы служат очень прагматичным целям. Они помогают управлять сотрудниками, финансами, развлекают в конце концов. Несмотря на различия, все эти программы выполняют заложенные в них алгоритмы, которые очень похожи между собой.

**Алгоритм** — это последовательность действий или инструкций, которая приводит нас к какому-то ожидаемому результату. Это описание подходит под любую программу, но под алгоритмами обычно понимается что-то более специфичное.

Представьте себе, что у нас есть книга и мы хотим найти внутри нее какую-то конкретную фразу. Саму фразу мы помним, но не знаем, на какой она странице. Как найти нужную страницу?

Самый простой и долгий способ — последовательно просматривать книгу до тех пор, пока мы не найдем нужную страницу. В худшем случае придется просмотреть все страницы, но результат мы все равно получим.

Именно этот процесс и называется **алгоритмом**. Он включает в себя перебор страниц и логические проверки, нашли мы фразу или нет. Количество страниц, которое придется посмотреть, заранее неизвестно, но сам процесс просмотра повторяется из раза в раз совершенно одинаковым образом.

Для выполнения повторяющихся действий как раз и нужны циклы. Каждый такой повтор называется **итерацией**.

Допустим, мы хотим написать метод. Он должен выводить на экран все числа от 1 до того числа, которое мы указали через параметры:

```
App.printNumbers(3);
// 1
// 2
// 3
```

Этот метод невозможно реализовать уже изученными средствами, так как количество выводов на экран заранее неизвестно. А с циклами это не составит никаких проблем:

```
public static void printNumbers(int lastNumber) {
    // i — это сокращение от index (порядковый номер)
    // Используется по общему соглашению во множестве языков как счетчик цикла
    var i = 1;

    while (i <= lastNumber) {
        System.out.println(i);
        i = i + 1;
    }
    System.out.println("finished!");
}

App.printNumbers(3);
// => 1
// => 2
// => 3
// => finished!
```

[https://replit.com/@hexlet/java-basics-while](https://replit.com/@hexlet/java-basics-while)

В коде метода использован цикл `while`. Он состоит из трех элементов:

-   **Ключевое слово** `while`. Несмотря на схожесть с вызовом методов, это не вызов метода
-   **Предикат** — условие, которое указывается в скобках после `while` и вычисляется на каждой итерации
-   **Тело цикла** — блок кода в фигурных скобках, аналогичный блоку кода в методе. Все константы или переменные, определенные внутри этого блока, будут видны только внутри этого блока

Конструкция читается так: «делать то, что указано в теле цикла, пока истинно условие `i <= lastNumber`». Разберем работу этого кода для вызова `App.printNumbers(3)`:

```
// Инициализируется i
var i = 1;

// Предикат возвращает true, поэтому выполняется тело цикла
while (1 <= 3)
// System.out.println(1);
// i = 1 + 1;

// Закончилось тело цикла, поэтому происходит возврат в начало
while (2 <= 3)
// System.out.println(2);
// i = 2 + 1;

// Закончилось тело цикла, поэтому происходит возврат в начало
while (3 <= 3)
// System.out.println(3);
// i = 3 + 1;

// Предикат возвращает false, поэтому выполнение переходит за цикл
while (4 <= 3)

// System.out.println("finished!");
// На этом этапе i равен 4, но он нам уже не нужен
// Метод завершается
```

Самое главное в цикле — завершение его работы, то есть **выход из цикла**. Процесс, который порождает цикл, должен в конце концов остановиться. Ответственность за остановку полностью лежит на программисте.

Обычно задача сводится к введению переменной, называемой **счетчиком цикла**. Он работает по такому принципу:

-   Сначала счетчик инициализируется, то есть ему задается начальное значение. В примере выше счетчик — это инструкция `var i = 1`, выполняемая до входа в цикл
-   Затем в условии цикла проверяется, достиг ли счетчик своего предельного значения.
-   В итоге счетчик меняет свое значение `i = i + 1`

На этом моменте новички делают больше всего ошибок. Представим, что в коде неправильно написана проверка в предикате. Это может привести к **зацикливанию** — ситуация, при которой цикл работает бесконечно и программа никогда не останавливается.

В таком случае приходится ее завершать принудительно:

```
public static void printNumbers(int lastNumber) {
    var i = 1;

    // Этот цикл никогда не остановится
    // и будет печатать всегда одно значение
    while (i <= lastNumber) {
        System.out.println(i);
    }
    System.out.println("finished!");
}
```

В некоторых случаях бесконечные циклы полезны. Здесь мы такие случаи не рассматриваем, но полезно увидеть, как выглядит этот код:

```
while (true) {
    // Что-то делаем
}
```

Подведем итог. Когда все же нужны циклы, а когда можно обойтись без них? Невозможно обойтись без циклов тогда, когда алгоритм решения задачи требует повторения каких-то действий, при этом количество этих операций заранее неизвестно. Так и было в примере с книгой, который мы рассматривали в начале урока.

## Синтаксический сахар

Подобные конструкции `index = index + 1` в Java используются довольно часто, поэтому создатели языка добавили сокращенный вариант записи: `index += 1`. Такие сокращения принято называть **синтаксическим сахаром**, потому что они делают процесс написания кода немного проще и приятнее.

Существуют сокращенные формы для всех арифметических операций и для конкатенации строк:

-   `a = a + 1` → `a += 1`
-   `a = a - 1` → `a -= 1`
-   `a = a * 2` → `a *= 2`
-   `a = a / 1` → `a /= 1`
-   `a = a + "foo"` → `a += "foo"`


# Использование циклов

![Итерации цикла](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjA4ODQ1NDlmODA1ZWJjOGNkNjk1ZGY3MTZkODVjOGQ2LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=6e7b64bd8cfdc791877d30ee2db91b9eeb8b117c44bd66e7d4cd541d7e317c94)

В программировании есть отдельный класс задач, который не может обойтись без циклов — он называется **агрегированием данных**.

К таким задачам относится поиск:

-   Максимального значения
-   Минимального значения
-   Суммы
-   Среднего арифметического

Их главная особенность в том, что результат зависит от всего набора данных. Для расчета суммы нужно сложить **все** числа, для вычисления максимального нужно сравнить **все**числа.

С этой темой хорошо знакомы все, кто занимаются числами. Например, с такими задачами часто работают бухгалтеры или маркетологи в таблицах наподобие Microsoft Excel или Google Sheets.

Разберем самый простой пример — поиск суммы набора чисел. Реализуем функцию, которая складывает числа в указанном диапазоне, включая границы.

В этом случае **диапазоном** называется ряд чисел от какого-то начала до определенного конца. Например, диапазон `[1, 10]` включает в себя все целые числа от 1 до 10:

```
App.sumNumbersFromRange(5, 7); // 5 + 6 + 7 = 18
App.sumNumbersFromRange(1, 2); // 1 + 2 = 3

// Диапазон [1, 1] с одинаковым началом и концом – тоже диапазон
// Он включает одно число — саму границу диапазона
App.sumNumbersFromRange(1, 1); // 1
App.sumNumbersFromRange(100, 100); // 100
```

Для реализации этого кода нам понадобится цикл. Мы выбираем именно цикл, потому что сложение чисел – это итеративный процесс. Он повторяется для каждого числа, а количество итераций зависит от размера диапазона.

Чтобы лучше понять тему, попробуйте ответить на вопросы:

-   Каким значением инициализировать счетчик?
-   Как он будет изменяться?
-   Когда цикл должен остановиться?

А теперь посмотрите код ниже:

```
public static int sumNumbersFromRange(int start, int finish) {
    // Технически можно менять start, но входные аргументы нужно оставлять в исходном значении
    // Это сделает код проще для анализа
    var i = start;
    var sum = 0; // Инициализация суммы

    while (i <= finish) { // Двигаемся до конца диапазона
        sum = sum + i; // Считаем сумму для каждого числа
        i = i + 1; // Переходим к следующему числу в диапазоне
    }

    // Возвращаем получившийся результат
    return sum;
}
```

[https://replit.com/@hexlet/java-basics-loops-using-1](https://replit.com/@hexlet/java-basics-loops-using-1)

Общая структура цикла здесь стандартна:

-   Счетчик, который инициализируется начальным значением диапазона
-   Сам цикл с условием остановки при достижении конца диапазона
-   Изменение счетчика в конце тела цикла

Количество итераций в таком цикле равно `finish - start + 1`. Например, нужно 3 итерации, чтобы посчитать диапазон от 5 до 7:

```
7 - 5 + 1 = 3
```

Главные отличия от обычной обработки связаны с логикой вычислений результата. В задачах на агрегацию всегда есть какая-то переменная, которая хранит внутри себя результат работы цикла. В коде выше это `sum`.

На каждой итерации цикла происходит ее изменение, прибавление следующего числа в диапазоне: `sum = sum + i`. Весь процесс выглядит так:

```
// Для вызова sumNumbersFromRange(2, 5);
var sum = 0;
sum = sum + 2; // 2
sum = sum + 3; // 5
sum = sum + 4; // 9
sum = sum + 5; // 14
// 14 – результат сложения чисел в диапазоне [2, 5]
```

В математике существует понятие **нейтральный элемент операции**. Операция с таким элементом не изменяет то значение, над которым проводится операция:

-   В сложении любое число плюс ноль дает само число
-   При вычитании – то же самое
-   Даже у конкатенации есть нейтральный элемент – это пустая строка: `"" + "one"` будет `"one"`

## Агрегация данных (Строки)

Агрегация применяется не только к числам, но и к строкам.

При агрегации строка формируется динамически, то есть заранее неизвестно, какого она размера и что будет содержать. Представьте себе метод, который умеет умножать строку — то есть он повторяет ее указанное количество раз:

```
App.repeat("hexlet", 3); // "hexlethexlethexlet"
```

Принцип работы этого метода довольно простой. В цикле происходит наращивание строки указанное количество раз:

```
public static String repeat(String text, int times) {
    // Нейтральный элемент для строк – пустая строка
    var result = "";
    var i = 1;

    while (i <= times) {
        // Каждый раз добавляем строку к результату
        result = result + text;
        i = i + 1;
    }

    return result;
}
```

Распишем выполнение этого кода по шагам:

```
// Для вызова repeat("hexlet", 3);
var result = "";
result = result + "hexlet"; // "hexlet"
result = result + "hexlet"; // "hexlethexlet"
result = result + "hexlet"; // "hexlethexlethexlet"
```

## Обход строк

Циклы подходят не только для обработки чисел, но и при работе со строками. В первую очередь благодаря возможности получить конкретный символ по его индексу. Ниже пример кода, который распечатывает буквы каждого слова на отдельной строке:

```
public static void printNameBySymbol(String name) {
    var i = 0;
    // Такая проверка будет выполняться до конца строки
    // включая последний символ. Его индекс `length() - 1`.
    while (i < name.length()) {
        // Обращаемся к символу по индексу
        System.out.println(name.charAt(i));
        i += 1;
    }
}

var name = "Arya";
App.printNameBySymbol(name);
// "A"
// "r"
// "y"
// "a"
```

Самое главное в этом коде — поставить правильное условие в `while`. Это можно сделать сразу двумя способами:

-   `i < name.length()`
-   `i <= name.length() - 1`

Оба способа приводят к одному результату.

## Формирование строк в циклах

Еще одно использование циклов — **формирование строк**. Подобная задача нередко встречается в программировании. Она сводится к обычной агрегации через конкатенацию.

Есть одна задача, которая популярна на собеседованиях — это **переворот строки**. Ее можно решить множеством разных способов, но именно посимвольный перебор считается базовым:

```
App.reverse("Hexlet"); // "telxeH"
```

Общая идея переворота состоит в следующем — нужно брать символы по очереди с начала строки и соединять их в обратном порядке. Давайте проверим, как это работает:

```
public static String reverse(String str) {
    var i = 0;
    // Нейтральный элемент для строк — это пустая строка
    var result = "";
    while (i < str.length()) {
        // Соединяем в обратном порядке
        result = str.charAt(i) + result;
        i += 1;
    }

    return result;
}

var name = "Bran";
App.reverse(name); // "narB"
// Проверка нейтрального элемента
App.reverse(""); // ""
```

[https://replit.com/@hexlet/java-basics-loops-using-2](https://replit.com/@hexlet/java-basics-loops-using-2)

Важно прочувствовать, как собирается сама строка — каждый следующий символ прикрепляется к результирующей строке слева, и в итоге строка оказывается перевернута.

# Условия внутри цикла и возврат значений

Тело цикла, как и тело метода — это место выполнения инструкций. Значит, мы можем использовать внутри него все изученное ранее — в том числе условные конструкции.

Рассмотрим метод, который считает, сколько раз входит буква в предложение:

```
countChars("Fear cuts deeper than swords.", 'e'); // 4
// Если вы ничего не нашли, то результат — 0 совпадений
countChars("Sansa", 'y'); // 0
```

Сначала попробуйте ответить на вопросы:

-   Является ли эта операция агрегацией?
-   Какой будет проверка на вхождение символа?

А теперь посмотрим на фрагмент кода:

```
public static int countChars(String str, char ch) {
    var i = 0;
    var count = 0;
    while (i < str.length()) {
        if (str.charAt(i) == ch) {
            // Считаем только подходящие символы
            count = count + 1;
        }
        // Счетчик увеличивается в любом случае
        i = i + 1;
    }

    return count;
}
```

[https://replit.com/@hexlet/java-basics-conditions-inside-loops](https://replit.com/@hexlet/java-basics-conditions-inside-loops)

Эта задача является агрегирующей. Метод считает не все символы, но при этом для подсчета самой суммы все равно приходится анализировать каждый символ.

Ключевое отличие этого цикла от рассмотренных в наличии условия внутри тела. Переменная `count` увеличивается только в том случае, когда текущий рассматриваемый символ совпадает с ожидаемым. В остальном — это типичный агрегатный метод, который возвращает количество нужных символов вызываемому коду.

## Возврат из циклов

Работа с циклами обычно сводится к двум сценариям:

1.  Агрегация — накопление результата во время итераций и работа с ним после цикла. Переворот строки как раз относится к такому варианту
2.  Выполнение цикла до достижения необходимого результата и выход. Например, задача поиска простых чисел. Вспомним, что простое число делится без остатка только на себя и на единицу

Рассмотрим простой алгоритм проверки простоты числа. Попробуем поделить искомое число `x` на все числа из диапазона от двух до `x - 1` и смотреть остаток от деления. Если в этом диапазоне не найден делитель, который делит число `x` без остатка, значит перед нами простое число.

Можно заметить, что достаточно проверять числа не до `x - 1`, а до половины числа. Например, 11 не делится на 2, 3, 4, 5. Но и дальше гарантированно не будет делиться на числа больше своей половины.

Значит, можно провести небольшую оптимизацию и проверять деление только до `x / 2`:

```
public static boolean isPrime(int number) {
    if (number < 2) {
        return false;
    }

    var divider = 2;

    while (divider <= number / 2) {
        if (number % divider == 0) {
            return false;
        }

        divider++;
    }

    return true;
}

App.isPrime(1); // false
App.isPrime(2); // true
App.isPrime(3); // true
App.isPrime(4); // false
```

Алгоритм построен таким образом, что если во время последовательного деления на числа до `x / 2` находится хоть одно, которое делит без остатка, то переданный аргумент — не простое число, а значит дальнейшие вычисления не имеют смысла. В этом месте стоит возврат `false`.

И только если цикл отработал целиком, можно сделать вывод, что число — простое, так как не было найдено ни одного числа, которое делит число без остатка.

# Цикл for
Цикл `while` идеален для ситуаций, когда количество итераций неизвестно заранее, например, при поиске простого числа.

Когда количество итераций известно, предпочтительнее использовать цикл `for`. Посмотрим реализацию переворота строки через цикл `for`:

```
public static String reverseString(String str) {
    var result = "";
    // Счетчик увеличивается с помощью инкремента.
    // Об этой операции мы поговорим ниже.
    for (var i = 0; i < str.length(); i++) {
        result = str.charAt(i) + result;
    }

    return result;
}
```

[https://replit.com/@hexlet/java-basics-conditions-for](https://replit.com/@hexlet/java-basics-conditions-for)

Этот код можно описать так:

> Цикл с индексом `i` повторяется, пока `i < str.length()`, а также после каждого шага увеличивает `i` на 1

В определении цикла `for` есть:

1.  Начальное значение счетчика. Этот код выполняется ровно один раз перед первой итерацией
2.  Предикат — условие повторения циклов. Выполняется на каждой итерации. Точно так же как и в `while`
3.  Описание изменения счетчика. Этот код выполняется в конце каждой итерации

В остальном принцип работы точно такой же, как у цикла `while`.

## Инкремент и декремент

Из языка Си в Java перекочевали две операции: **инкремент** `++` и **декремент** `--`, которые очень часто встречаются вместе с циклами.

Эти унарные операции увеличивают и уменьшают на единицу число, записанное в переменную:

```
var i = 0;
i++; // 0
i++; // 1

i--; // 2
i--; // 1
```

Кроме постфиксной формы, у них есть и префиксная:

```
var i = 0;
++i; // 1
++i; // 2

--i; // 1
--i; // 0
```

Кажется, что нет никакой разницы между постфиксной и префиксной формами, но тут начинаются сложности. В отличие от всех остальных операций, инкремент и декремент не только возвращают значение, но и **изменяют значение переменной**.

При использовании префиксной нотации сначала происходит изменение переменной, а потом возврат. При использовании постфиксной нотации — наоборот: можно считать, что сначала происходит возврат, а потом изменение переменной.

Правило работает одинаково для инкремента и декремента. Для простоты рассмотрим только инкремент:

```
var x = 5;

System.out.println(++x); // => 6
System.out.println(x);   // => 6

System.out.println(x++); // => 6
System.out.println(x);   // => 7
```

Что происходит в коде выше:

1.  Выводим на экран `++x` — префиксный инкремент. Поэтому сначала значение переменной увеличилось на 1, потом результат вернулся и вывелся на экран
2.  Так как значение изменилось, `System.out.println(x)` вывел 6
3.  Теперь выводим на экран `x++` — постфиксный инкремент. Поэтому мы получили значение, содержавшееся в переменной до ее увеличения на 1
4.  Так как значение изменилось, `System.out.println(x)` вывел 7

Особенно сложно становится, когда инкремент вставляют внутрь других операций: `x = i++ - 7 + --h`. Понять такой код почти невозможно.

Рекомендации по использованию:

-   Никогда не смешивайте операции без побочных эффектов с операциями с побочными эффектами. То же самое касается и методов
-   Используйте инкремент и декремент только там, где нет разницы между префиксным и постфиксным вариантом — отдельно от всего, на отдельной строчке кода

# Пакеты

Реальные программы на Java состоят из сотен и тысяч классов. При таких размерах легко возникают ситуации, когда создаются классы с одинаковыми именами. Если два таких класса окажутся внутри одного проекта, то он перестанет компилироваться.

Для решения проблемы конфликта имен вводится **система пакетов**. Пакеты позволяют группировать похожие классы.

## Определение пакетов

Структура пакетов тесно связана со структурой директорий. Как правило, структура пакетов соответствует файловой структуре директорий проекта, в которых находится файлы с исходным кодом. Например, если классы размещены в пакете `example.package1`, то и файлы в проекте должны быть расположены в директории _example/package1_. Некоторые IDE, например популярная IntelliJ IDEA, при создании пакета автоматически создают соответствующую файловую структуру в директории проекта

![project structure](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjBlNTUzNzM1YmY3OTQ0NDAxODU4YjY0ZjQ2NjI4OTM1LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=9e8b8e31a1ce7d4a9e9f60d7cf83b6b06b7bed13fea4af98551208d365dd19ba)

Здесь имя `User` - это так называемое простое имя класса. А полным именем класса считается имя, состоящее из всех пакетов, перечисленных через точку, и простого имени класса. Например, полные имена для классов `User` будут такими: `example.package1.User` и `example.package2.User`. Теперь проблема одинаковых имён классов в большом проекте решена, так как в разных пакетах могут находиться классы с одинаковым простым именем

Для примера в пакете `example.package1` создадим класс `User`, который будет описывать методы для работы с пользователем:

```
// Файл src/main/java/example/package1/User.java

// Именовать пакет начинаем от директории src/main/java/,
// в которой расположен корневой пакет
package example.package1;

class User {
    public static String getGreeting(String userName) {
        System.out.println("Hello, " + userName + "!");
    }
}
```

Используем этот класс в том же пакете:

```
// Файл src/main/java/example/package1/App.java

// Класс расположен в том же пакете, что и класс User
package example.package1;

class App {
    public static void main(String[] args) {
        // Внутри своего пакета класс можно использовать,
        // обратившись к нему по простому имени
        var greeting = User.getGreeting("John");
        System.out.println(greeting); // => Hello, John!
    }
}
```

Внутри своего пакета можно обращаться к классу по его простому имени. Компилятор поймет, что мы хотим использовать класс `User`, расположенный в том же пакете. Но в разработке постоянно приходится использовать классы из других пакетов. Помимо разрешения конфликтов имен, пакеты выполняют еще одну функцию — контроль доступа.

## Контроль доступа

По умолчанию все классы внутри пакета доступны только классам этого же пакета. Чтобы получить доступ к классу снаружи, из другого пакета, этот класс нужно сделать публичным. Вернемся к нашему примеру с пользователем и сделаем класс `User` в пакете `example.package1` публичным

```
package example.package1;

// К определению класса добавляем модификатор public
// Теперь класс User становится публичным
// и к нему можно обратиться из другого пакета
public class User {
    public static String getGreeting(String userName) {
        System.out.println("Hello, " + userName + "!");
    }
}
```

Используем класс `User` в другом пакете. Чтобы использовать класс в другом пакете, нужно обратиться к нему по его полному имени, чтобы однозначно указать компилятору, какой именно класс мы хотим использовать:

```
// Файл src/main/java/example/App.java

// Уже другой пакет
package example;

class App {
    public static void main(String[] args) {
        // Обращаемся по полному имена класса
        var greeting = example.package1.User.getGreeting("John");
        System.out.println(greeting); // => Hello, John!
    }
}
```

Постоянно писать полное имя класса может быть не удобно. На деле чаще всего поступают иначе. Чтобы каждый раз не писать полное имя класса, мы можем импортировать этот класс, после чего в коде можно будет обращаться к нему по простому имени. Чтобы импортировать класс, нужно использовать ключевое слово `import`, после которого указать полное имя класса, который мы хотим импортировать

```
package example;

// Импортируем класс User из пакета example.package1
import example.package1.User;

class App {
    public static void main(String[] args) {
        // Теперь класс можно использовать, обратившись к нему по простому имени
        var greeting = User.getGreeting("John");
        System.out.println(greeting); // => Hello, John!
    }
}
```