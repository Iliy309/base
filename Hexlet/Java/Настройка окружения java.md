## Окружение

Об этом мало говорят, но работа с командной строкой, редактором, настройка окружения (установка языка, библиотек), взаимодействие с операционной системой – это значительная часть работы любого программиста на любом языке. От этого зависит эффективность отладки, способность самостоятельно справляться с проблемами и даже качество кода.

Когда программист только приходит на свою первую работу, то первое время он пытается запустить проект у себя локально на компьютере. Чем больше и сложнее проект, тем больше разных знаний для этого может понадобиться. Начиная от сетей (порты, ip-адреса) и виртуализации (докер), заканчивая сборщиками (webpack). В некоторых компаниях подобная настройка может занимать дни, а в особо запущенных случаях и всю неделю. И это при условии достаточной квалификации программиста.

Изучение экосистемы своего языка процесс непрерывный и очень непредсказуемый. Постоянно возникающие непонятные ошибки это норма. Постоянное часовое гугление это тоже норма. Через это проходили все и это необходимое зло. Почему такое происходит? В отличие от языков программирования, где все подчиняется определенным правилам, экосистема это зоопарк из огромного количества программ, операционных систем и особенностей железа, которые очень хитрым образом переплетаются друг с другом. Настолько индивидуально, что практически у каждого программиста своя собственная уникальная ситуация.

Именно поэтому существуют тысячи статей по установке и настройке Java и постоянно появляются новые. А по комментариям к этим статьям можно заметить, что далеко не всем они помогли и пользователи сталкиваются с ошибками на каждом шагу.

Со временем, когда вы разберетесь, все это окажется не таким уж и страшным. Единственное важное условие – не пытайтесь решать проблемы методом тыка, старайтесь разобраться в их причинах. Только так вы вырастете как разработчик.

Сказанное выше справедливо для всех языков. В Java же многое дается на откуп редактору. Это не значит, что редактор решает за программиста все проблемы, скорее он скрывает их от него. Из-за этого нередко возникает ситуация, когда программист знает какую нажать кнопку в редакторе, но не понимает что за этим стоит. Это напрямую влияет на эффективность работы и качество принимаемых решений.

В этом курсе, мы пройдем весь путь от начала до конца, чтобы действительно разобраться в Java. Сначала проделаем все операции напрямую в терминале и затем, постепенно дойдем до автоматических инструментов, которые все делают за нас.

Не забудьте установить редактор [IDEA](https://www.jetbrains.com/idea/download/), который общепризнанно является лучшим редактором для Java.

# Запуск первой программы на Java

Начнем с установки **Java** и знакомства с **REPL**. Если на вашем компьютере пока не стоит Java, то выполните установку по нашей [инструкции](https://github.com/Hexlet/instructions/blob/main/java.md).

Если установка прошла без ошибок, то самое время убедиться в том, что Java работает. Заметьте, что "установилось" и "работает" — не одно и тоже. Наберите в терминале `java --version`. Вывод должен быть примерно такой:

```
# Вывод может отличаться, главное чтобы не было ошибок
java --version

openjdk 17.0.1 2021-10-19
OpenJDK Runtime Environment Temurin-17.0.1+12 (build 17.0.1+12)
OpenJDK 64-Bit Server VM Temurin-17.0.1+12 (build 17.0.1+12, mixed mode, sharing)
```

## REPL

Если все прошло удачно, то теперь самое время начать выполнять код на Java. Java поставляется со встроенным REPL (Read Eval Print Loop). REPL – это программа, которая работает как командная оболочка. Она ожидает ввод от пользователя (Read), выполняет введенный код (Eval) и печатает на экран результат (Print), затем снова входит в режим ожидания (Loop). Для его запуска достаточно набрать `jshell`:

```
jshell

|  Welcome to JShell -- Version 17.0.1
|  For an introduction type: /help intro

jshell>
```

Теперь можно выполнять код на Java и сразу же смотреть результат его выполнения. Наберите любой корректный код на Java и нажмите Enter:

```
jshell> 10 + 5
$1 ==> 15

jshell>
```

REPL выводит результат выполнения операции прямо на экран и снова входит в режим ожидания ввода команд. Для выхода из репла достаточно нажать Ctrl + d. Такой способ работы очень хорошо подходит для быстрой проверки гипотез "а как работает эта штука?", а также для отладки и простых вычислений. REPL позволяет использовать переменные и запоминает предыдущий ввод:

```
jshell> var a = 5
a ==> 5

jshell> var b = 3
b ==> 3

jshell> a + b
$4 ==> 8

jshell>
```

Для успешного обучения крайне важно, чтобы весь код, который мы демонстрируем в дальнейшем, вы набирали и запускали локально. Только тогда будет приходить настоящее понимание того, что происходит. В тех случаях, когда репла недостаточно, код можно и нужно запускать в виде файлов.

## Файлы

Создайте файл _HelloWorld.java_ внутри git-репозитория _hexlet-java_ из прошлого урока. Добавьте туда следующий код:

```
class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, Hexlet!");
    }
}
```

[https://replit.com/@hexlet/java-setup-environment-hello-world](https://replit.com/@hexlet/java-setup-environment-hello-world)

Теперь осталось запустить его на выполнение:

```
# Обязательно указать расширение
java HelloWorld.java
Hello, Hexlet!
```

Если все было сделано правильно, то на экране появится строка _Hello, Hexlet!_, а программа успешно завершится. На этом этапе появляются первые соглашения и правила, о которых нужно знать:

1.  Файлы Java имеют расширение java
2.  Каждый Java файл содержит ровно один Java класс. Практически все файлы в Java это файлы с классами (еще есть интерфейсы, но мы их рассмотрим позже)
3.  Имя класса совпадает с именем файла без расширения

Класс HelloWorld, в нашем случае, не обычный Java класс, это точка входа в программу. Именно с нее начинается выполнение. Откуда Java знает как запустить этот класс? Это благодаря методу `main`. Его необходимо реализовать ровно в таком виде, в котором мы его видим выше:

```
// args – сюда попадают аргументы командной строки
// если они есть
public static void main(String[] args) {

}
```

Метод `main()` нужен только у входной точки, в остальных классах его не добавляют, так как эти классы не запускаются отдельно.

## Компиляция и запуск

Команда _java_ выглядит очень простой. На вход ей подается файл с исходным кодом, на выходе – результат выполнения. Под капотом происходит два действия: компиляция и запуск. Их можно выполнить отдельно и тогда станет виден весь процесс.

Java — компилируемый язык программирования. Файл с исходным кодом компилируемого языка нельзя взять и просто так запустить, сначала его нужно превратить в понятный для машины код. За это отвечает компилятор _javac_. Вызывается он так:

```
javac HelloWorld.java
# ничего не выводит
```

`javac` не запускает программу, он выполняет компиляцию, во время которой проверяется корректность программы (соответствие типов) и формируется файл _HelloWorld.class_ с байткодом.

_Почему байткод, а не машинный код? Дело в том, что Java программы запускаются через виртуальную машину JVM, поэтому компиляция создает не машинный код, а байткод, это машинный код для виртуальной машины JVM. Пока звучит сложно, поэтому рассмотрим этот вопрос в одном из следующих уроков, после того как немного поработаем с инфраструктурой_

После того как компиляция прошла, программа готова к запуску. Запуск выполняется командой _java_:

```
# Расширение не указывается
java HelloWorld
```

Такой запуск ищет файл с именем _HelloWorld.class_ в рабочей директории и запускает его. Файл _HelloWorld.java_ уже не используется, его можно даже удалить. И изменения в этом файле не будут использованы до тех пор, пока не выполнится повторная компиляция.

Возникает вопрос, а зачем вызывать компилятор отдельно если команда _java_ умеет делать это автоматически? На это есть множество причин и одна из них это то, что программы на Java состоят больше чем из одного файла. Об этом мы поговорим в следующим уроке.

# Работа с несколькими файлами
Реальные программы на Java, состоят из сотен и тысяч файлов. Их уже не запустишь одной командой _java_. Процесс работы в таком случае выглядит сложнее. Предположим, что у нас есть два файла _One.java_ и _Two.java_ с таким содержимым:

```
// io/hexlet/One.java
// Этот файл точка входа
package io.hexlet;

public class One {
    public static void main(String[] args) {
        Two.greeting();
    }
}

// io/hexlet/Two.java
package io.hexlet;

public class Two {
    public static void greeting() {
        System.out.println("Java for Brave");
    }
}
```

В первом файле реализован метод `main()` так как это точка входа, во втором – обычный статический метод, который печатает на экран текст. Запуск `java One.java` приведет к ошибке:

```
One.java:5: error: cannot find symbol
        Two.greeting();
        ^
  symbol:   variable Two
  location: class One
1 error
error: compilation failed
```

То есть компиляция завершается с ошибкой. Что произойдет если мы попытаемся скомпилировать первый файл самостоятельно?

```
javac One.java

One.java:5: error: cannot find symbol
        Two.greeting();
        ^
  symbol:   variable Two # на чем произошла ошибка
  location: class One # место где произошла ошибка
1 error
```

Возникнет ровно та же самая ошибка. `java` внутри себя запускает `javac`. Компилятор проверяет код на типобезопасность, а для этого ему нужна информация обо всех используемых классах. Класс `Two` компилятору не известен, поэтому процесс останавливается. Дальше можно поступить двумя способами:

1.  Компилировать по очереди все файлы, начиная с тех, которые не зависят ни от кого, постепенно поднимаясь до тех класов, в которых используются все остальные
2.  Сразу передать компилятору весь список файлов

```
// Все это в директории io/hexlet
// Сработает только такой порядок
javac Two.java
javac -classpath ../.. One.java
// Про параметр classpath будет рассказано ниже

// Или проще так. В любом порядке, компилятор разберется сам
javac One.java Two.java
```

Теперь попробуем запустить:

```
# Внутри io/hexlet
java One

Error: Could not find or load main class One
Caused by: java.lang.ClassNotFoundException: One
```

А вот это уже неожиданно. Почему класс `One` не найден? Когда класс определяется внутри пакета, то при обращении к нему нужно указывать полное имя. В нашем случае `io.hexlet.One`. Но даже если мы укажем имя полностью, то все равно получим ошибку:

```
# Внутри io/hexlet
java io.hexlet.One

Error: Could not find or load main class io.hexlet.One
Caused by: java.lang.ClassNotFoundException: io.hexlet.One
```

Как и положено, java пытается найти класс по пути _io/hexlet/One.class_, но мы уже находимся внутри _io/hexlet_, поэтому возникает ошибка. Если выйти в родительскую директорию _io_, то программа заработает:

```
# Внутри родительской директории io
java io.hexlet.One
Java for Brave
```

Вот теперь работает! Для этого пришлось выйти из директории, дав возможность _java_найти класс по полному имени. Но можно и не выходить. Для этого нам понадобится **classpath**.

## classpath

classpath – параметр, который задает директории для поиска классов. В нашем случае это позволит не выходить из директории:

```
# io/hexlet
# ../.. указывает на родительскую директорию io
java -classpath ../.. io.hexlet.One
# или так java -cp ../.. io.hexlet.One
Java for Brave
```

_classpath_ имеет очень важное значение в Java. Классов много, все они находятся в разных пакетах, а значит и директориях. Поэтому при компиляции проектов невозможно обойтись без указания путей поиска классов. А неправильная работа с _classpath_, одна из самых распространенных ошибок новичков.

## Перекомпиляция

Когда файлов мало, то их можно компилировать сразу все на любое изменение. Но с определенного размера, компиляция начнет занимать серьезное время. Тогда возникает вопрос, можно ли компилировать не все файлы, а только те, которые изменились? Да можно, но с ограничениями. Если изменилось что-то, что используется другим классом (а значит файлом), например имя класса, количество параметров метода и тому подобное, то придется по цепочке компилировать все связанные классы. Такая техника называется инкрементальная компиляция и современные инструменты умеют делать ее сами. Скоро об этом поговорим.

# JAR файлы

У любого компилируемого приложения есть два состояния. Первое – исходный код для разработки. Второе – скомпилированная программа, готовая для запуска. Причем программа запускается не там где она компилируется, ее сначала нужно доставить либо на сервер, либо на компьютер тому, кто ее запустит.

```
Компиляция => Доставка по месту назначения => Запуск
```

Доставлять программу куда-либо удобно только если она состоит из одного файла. Поэтому создатели Java разработали специальный формат архива JAR (Java ARchive). Он позволяет взять любые файлы и упаковать их в один сжатый файл. Упаковка происходит в два этапа:

**Компиляция**

Сначала нужно выполнить компиляцию. Причем таким образом, чтобы готовые файлы лежали отдельно от исходного кода. Исходный код скрывается если это не открытый проект. У компилятора есть опция `-d`, которая задает директорию, куда надо сложить готовые файлы.

```
# Два файла из прошлого урока
# Внутри io/hexlet
javac One.java Two.java -d build
```

Компилятор создаст директорию _build_ и сложит туда готовые файлы. Сделает это с учетом пакетов:

```
# Показывает структуру директории
tree build

build
└── io
    └── hexlet
        ├── One.class
        └── Two.class
```

Проверим что все работает:

```
# Внутри директории build
java io.hexlet.One
Java for Brave
```

**Упаковка**

Теперь упакуем содержимое директории _build_ в _jar_ файл. Первым шагом создадим файл манифеста _manifest.MF_, который нужен для правильного запуска _jar_ на исполнение. В этом файле указывается входная точка в программу. Сам файл проще всего положить внутрь директории _build_ иначе придется указывать _classpath_.

```
tree build
build
├── io
│   └── hexlet
│       ├── One.class
│       └── Two.class
└── manifest.MF
```

Ниже содержимое файла. Справа указывается полное имя класса включая пакет. Обратите внимание на пустую строку в конце. Если ее не добавить, то возникнет ошибка.

```
Main-Class: io.hexlet.One

```

Следующим шагом запустим упаковку:

```
# Запускаем внутри директории build,
# поэтому в конце команды точка (текущая директория)
# Опции:
# c – создать новый файл
# v - подробный вывод
# f – имя выходного jar файла
# m – имя файла манифеста (или путь до него)
jar -cvfm build.jar manifest.MF .

added manifest
adding: manifest.MF(in = 39) (out= 41)(deflated -5%)
adding: io/(in = 0) (out= 0)(stored 0%)
adding: io/hexlet/(in = 0) (out= 0)(stored 0%)
adding: io/hexlet/(in = 0) (out= 0)(stored 0%)
adding: io/hexlet/Two.class(in = 415) (out= 292)(deflated 29%)
adding: io/hexlet/One.class(in = 332) (out= 242)(deflated 27%)
```

На выходе получился архив:

```
tree build
build
├── build.jar # вот он
├── io
│   └── hexlet
│       ├── One.class
│       └── Two.class
└── manifest.MF
```

Внутри архива лежит директория _io_. Сейчас там только байткод (файлы с расширением _class_), но может быть все, что угодно, например картинки, шрифты или любые другие файлы, нужные для работы приложения.

JAR можно запускать напрямую, поэтому сразу проверим как работает наша программа:

```
java -jar build.jar

Java for Brave
```

# Зависимости—Java:

Программисты не пишут весь код с нуля. Большая его часть приходит с библиотеками и фреймворками, которые подключатся к проекту как зависимости. Так говорят потому что код проекта теперь зависит от этих библиотек. Откуда берутся эти зависимости и как их подключать, на эти вопросы мы ответим в этом уроке.

Откуда вообще берутся такие библиотеки? Иногда их делают обычные программисты, такие же как и мы с вами. Иногда за библиотеками стоят компании, как большие так и маленькие. Исходный код этих библиотек почти всегда хранится на github.com и доступен для изучения.

Возьмем для примера библиотеку _Apache Commons Lang_. Она содержит множество полезных функций на все случаи жизни начиная от генерации случайных чисел, до обработки строк. Исходный код этой библиотеки доступен [здесь](https://github.com/apache/commons-lang). Посмотрите [файл с методами для строк](https://github.com/apache/commons-lang/blob/master/src/main/java/org/apache/commons/lang3/StringUtils.java). Он содержит более 9000 тысяч строчек кода. Правда половина из них комментарии, но все равно внушительно.

Предположим, что мы решили воспользоваться методом для генерации чисел. Выглядит он так:

```
import org.apache.commons.lang3.RandomUtils;

// Где-то внутри метода
// Случайное число от 1 до 1000
int x = RandomUtils.nextInt(1, 1000);
```

Как добавить этот метод к себе в проект? Чтобы разобраться с этим вопросом, надо знать как вообще распространяются библиотеки в Java. Существует специальное хранилище [Maven Central](https://mvnrepository.com/repos/central) (иногда говорят, что это каталог), куда любой разработчик, может выложить свою библиотеку. Здесь можно найти практически все публичные библиотеки для Java. Сам сайт, правда, выглядит страшновато, но им и не придется много пользоваться.

_Maven Central популярный, но не единственный источник пакетов. Есть и другие. В компаниях часто используются свои каталоги_

У каждого проекта в каталоге есть [своя страница](https://mvnrepository.com/artifact/org.apache.commons/commons-lang3). Здесь можно увидеть доступные версии, популярность, наличие критичных ошибок и тому подобное. Сами библиотеки распространяются в виде JAR-файлов, которые можно скачать прямо с сайта.

Попробуем скачать и подключить JAR библиотеки Apache Commons Lang к нашему коду. По порядку:

1.  На странице библиотеки нажимаем на последнюю доступную версию и попадаем на страницу конкретной версии
2.  На этой странице находим поле _Files_ и нажимаем на ссылку _jar_. Браузер предложит скачать файл.
3.  Скачиваем этот файл и кладем рядом с кодом в проект

Создадим класс, в котором получим случайное число и выведем его на экран:

```
package io.hexlet;

import org.apache.commons.lang3.RandomUtils;

public class Example {
    public static void main(String[] args) {
        System.out.println(RandomUtils.nextInt(1, 1000));
    }
}
```

После этого директория с кодом будет выглядеть так:

```
tree .
.
├── Example.java
└── commons-lang3-3.12.0.jar
```

Осталось запустить код. Для этого нужно указать компилятору где искать классы пакета _org.apache.commons.lang3_. Технически классы располагаются внутри файла _commons-lang3-3.12.0.jar_. И мы можем напрямую указать этот файл через _classpath_:

```
# cp это classpath
java -cp commons-lang3-3.12.0.jar Example.java
572
```

## Именование пакетов

В Maven Central есть определенные правила по именованию пакетов, которые стали стандартом де-факто во всей индустрии. Эти же правила применяются и при разработке локальных проектов. Даже редакторы требуют такой структуры. Речь идет про GroupId и ArtifactId.

GroupId – уникальный идентификатор, используемый для всех проектов компании. Даже если у вас нет компании, его все равно надо задавать. По задумке GroupId это домен который вы контролируете, например, _org.apache_ или _io.hexlet_ (в нашем случае). Если у вас нет такого домена, но вы хотите что-то поделать локально, то задайте в редакторе любой домен, какой вам нравится.

ArtifactId – Имя jar-файла без указания версии. В примере выше это _commons-lang3_. Обычно ArtifactId cовпадает с именем проекта.

Полный путь к пакету проекта строится как _GroupId.ArtifactId_. Для библиотеки Apache Commons Lang это _org.apache.commons-lang3_.

Подводя итог, мы видим, что библиотеки распространяются в виде пакетов, упакованных в JAR-файлы. Одна библиотека – один JAR. JAR-файлы подключаются к проекту через добавление в _classpath_.

# Инициализация Gradle
Ручная компиляции кода довольно утомительный процесс даже во время обучения. В реальных приложениях такой подход просто не применим, слишком много действий придется делать руками. Для компиляции используются специальные системы сборки, такие как Maven или Gradle. Последний стал стандартом де-факто для новых приложений, поэтому рассмотрим работу именно с ним. Принцип у всех таких систем один и тот же, поэтому зная один, несложно разобраться и в других.

Gradle — это не просто автоматизатор компиляции. Это навороченная система сборки, где компиляция это всего лишь один из этапов. Сборка проекта – довольно широкое понятие. Она включает в себя компиляцию исходного кода, упаковку в jar, запуск тестов и другие шаги, необходимые для создания рабочего приложения. Ключевые возможности Gradle:

1.  Автоматическая сборка проекта. Gradle сам знает какие файлы и как надо собирать. Сам компилирует, сам упаковывает в JAR
2.  Быстрая инкрементальная сборка. Компилируется только то, что изменилось
3.  Управление зависимостями. Gradle сам качает и подключает библиотеки. И заодно умеет их обновлять

Полный список возможностей [огромен](https://gradle.org/features/). Большая часть из них работает автоматически, об этом не придется думать.

В повседневной работе Java-программист пользуется Gradle через редактор, но во время обучения нужно потратить немного времени на то, чтобы разобраться с тем как он работает. Иначе потом будет сложно, когда что-то пойдет не так и возникнет ошибка. Поэтому здесь мы проделаем все операции через консоль, а дальше подключим редактор.

Начнем с установки. Если Gradle у вас не установлен, то посмотрите [инструкцию](https://github.com/Hexlet/instructions/blob/main/java.md). Проверить установку можно так:

```
gradle -v

------------------------------------------------------------
Gradle 7.3.3
------------------------------------------------------------
```

Теперь инициализируем новый Gradle-проект:

```
# Создаем директорию для проекта
mkdir hexlet-gradle-project
cd hexlet-gradle-project

# Запускаем инициализацию
gradle init
```

Дальше Gradle задаст множество вопросов, на базе которых сформируется правильная структура. Gradle умеет работать далеко не только с Java, поэтому одним из вопросов будет то, какой язык использовать. Если во время создания вы ошиблись и выбрали не тот вариант, то ничего страшного. Просто дойдите до конца и пересоздайте директорию с проектом. Потом запустите все заново. Разбираем вопросы:

```
Select type of project to generate:
  1: basic
  2: application
  3: library
  4: Gradle plugin
Enter selection (default: basic) [1..4]
```

Мы хотим создать приложение. В отличие от библиотеки, приложение можно запускать, у него есть точка входа. Библиотека же предназначена для использования в другом коде, как например _Apache Commons Lang_.

```
Select implementation language:
  1: C++
  2: Groovy
  3: Java
  4: Kotlin
  5: Scala
  6: Swift
```

Здесь выбираем Java.

```
Split functionality across multiple subprojects?:
  1: no - only one application project
  2: yes - application and library projects
```

Gradle умеет работать с набором связанных проектов. Такое разбиение актуально, когда из проекта выделяются библиотеки или сам проект распадается на независимые проекты. Нам достаточно одного проекта.

```
Select build script DSL:
  1: Groovy
  2: Kotlin
Enter selection (default: Groovy) [1..2]
```

Сам Gradle написан на языке Groovy и для конфигурации тоже использует этот язык. Какое-то время назад появилась поддержка Kotlin. Пока выбираем Groovy в силу большей распространенности в статьях и документации.

```
Generate build using new APIs and behavior (some features may change in the next minor release)? (default: no) [yes, no]
```

Выбираем yes

```
Select test framework:
  1: JUnit 4
  2: TestNG
  3: Spock
  4: JUnit Jupiter
Enter selection (default: JUnit Jupiter) [1..4]
```

Gradle сразу предлагает установить фреймворк для тестирования. Пока выберем 4 пункт, а обучаться тестированию начнем в одном из следующих курсов.

```
Project name (default: hexlet-gradle-project):
```

Просто жмем Enter. Текущее имя директории и есть имя проекта.

```
Source package (default: hexlet.gradle.project):
```

Gradle предлагает выбрать пакет, внутри которого будет лежать наш проект. Тут стоит сказать, что один проект – один пакет. То же самое касается библиотек. Прямо сейчас имя не принципиально, мы не будем никуда публиковать наш код, поэтому просто соглашаемся и жмем Enter.

После этого появляется радостная надпись:

```
BUILD SUCCESSFUL in 8m 46s
```

Посмотрим на получившуюся структуру:

```
tree -a .
.
├── .gitattributes
├── .gitignore
├── app
│   ├── build.gradle
│   └── src
│       ├── main
│       │   ├── java
│       │   │   └── hexlet
│       │   │       └── gradle
│       │   │           └── project
│       │   │               └── App.java
│       │   └── resources
│       └── test
│           ├── java
│           │   └── hexlet
│           │       └── gradle
│           │           └── project
│           │               └── AppTest.java
│           └── resources
├── gradle
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradlew
├── gradlew.bat
└── settings.gradle

16 directories, 10 files
```

Много всего, начнем по порядку.

Gradle сразу подготавливает проект к использованию через git добавив два файла .gitignore и .gitattributes. Игнорируются файлы сборки, которые попадут в директорию build и .gradle, это служебные файлы Gradle, которые он сам себе сгенерирует во время работы.

Файлы gradlew и gradlew.bat нужны для установки самого Gradle. Концепция здесь такая, Gradle во время создания проекта делает так, чтобы проект не использовал глобально установленный Gradle. Он скачивает сам себя в директорию _gradle_. Все команды будут запускаться через _./gradlew_ (в Windows _./gradlew.bat_). Зачем так сделано? Так Gradle фиксирует версию. Если поменяется глобально установленная версия, то проект продолжит работать с той с которой он работал. Меньше шансов что-то сломать, но сложнее в обновлении.

Файл _settings.gradle_ содержит различные настройки, например, там задается имя проекта. Остальное добавляется по мере развития и требований со стороны кода.

Самое интересное находится в директории _app_. Сначала мы видим файл _build.gradle_. Это основной файл Gradle, в котором на языке Groovy описано то, как будет работать система сборки:

```
plugins {
    // Поддержка запуска из командной строки
    id 'application'
}

repositories {
    // Подключена автоматическая работа с Maven Central
    mavenCentral()
}

dependencies {
    // Библиотека Guava (аналог Apache Commons Lang) указана как зависимость
    implementation 'com.google.guava:guava:30.1.1-jre'
}

testing {
    suites {
        // Конфигурация тестового окружения
        test {
            // Use JUnit Jupiter test framework
            useJUnitJupiter('5.7.2')
        }
    }
}

application {
    // Входная точка
    mainClass = 'hexlet.gradle.project.App'
}
```

Именно с этим файлом придется работать больше всего, настраивая Gradle для подключения новых библиотек и их конфигурации.

Дальше, в этой же директории _app_ находится _src_ (source), место в котором лежит весь исходный код проекта. Структура здесь следующая. Директория _main_ отвечает за код проекта и дополнительные ресурсы (директория _src/main/resources_), такие, как картинки, _test_ – за тесты. Внутри каждой из них находится _java_, то есть тут лежит Java-код, но подразумевается, что бывает и по-другому. И вот только внутри _java_ начинается структура соответствующая пакету проекта.

Попробуем запустить проект, а в следующем уроке поговорим о том, как конкретно работать с Gradle:

```
./gradlew run

> Task :app:run
Hello World! # Вот он вывод нашей программы

BUILD SUCCESSFUL in 2s
2 actionable tasks: 2 executed
```

# Gradle—Java: 

Поговорим о принципах работы Gradle. Базовая единица работы Gradle — это задача. Каждый раз когда мы хотим запустить Gradle, мы должны точно знать, какую задачу хотим запустить. Вот лишь некоторые из них:

```
# Вывод списка задач это тоже задача
# Список выводится в сокращенном виде
./gradlew tasks

> Task :tasks

------------------------------------------------------------
Tasks runnable from root project 'hexlet-gradle-project'
------------------------------------------------------------

Application tasks
-----------------
run - Runs this project as a JVM application

Build tasks
-----------
build - Assembles and tests this project.
clean - Deletes the build directory.
jar - Assembles a jar archive containing the main classes.

Build Setup tasks
-----------------
init - Initializes a new Gradle build.

Documentation tasks
-------------------
javadoc - Generates Javadoc API documentation for the main source code.

Verification tasks
------------------
check - Runs all checks.
test - Runs the test suite.
```

Например, если мы хотим выполнить сборку проекта, то надо запустить `./gradlew build`, а если получить готовый jar-файл, то `./gradlew jar`. Для запуска приложения как программы достаточно набрать `./gradlew run`.

Многие задачи имеют общие части. Сборка проекта и формирование jar-файла требуют компиляции. Gradle решает это через зависимости задач друг от друга. Когда мы запускаем `./gradlew build`, то внутри запускаются другие задачи, которые выполняют разные манипуляции с кодом. Gradle умеет показывать эти зависимости:

```
# Флаг --dry-run показывает то, как будет выполняться задача
# Что она в себя включает

./gradlew jar --dry-run # jar

:app:compileJava SKIPPED
:app:processResources SKIPPED
:app:classes SKIPPED
:app:jar SKIPPED

BUILD SUCCESSFUL in 556ms

./gradlew build --dry-run # build

:app:compileJava SKIPPED
:app:processResources SKIPPED
:app:classes SKIPPED
:app:jar SKIPPED
:app:startScripts SKIPPED
:app:distTar SKIPPED
:app:distZip SKIPPED
:app:assemble SKIPPED
:app:compileTestJava SKIPPED
:app:processTestResources SKIPPED
:app:testClasses SKIPPED
:app:test SKIPPED
:app:check SKIPPED
:app:build SKIPPED

BUILD SUCCESSFUL in 610ms
```

По выводу выше мы видим, что сборка jar-файла это один из этапов выполнения задачи _build_. А компиляция, как ни странно, это лишь малая часть процесса, выполняемая в самом начале:

```
./gradlew compileJava

BUILD SUCCESSFUL in 682ms
1 actionable task: 1 executed
```

## Разработка с Gradle

Основной редактор у всех Java разработчиков это [Idea](https://www.jetbrains.com/idea/download/). Но Idea не просто редактор, такие программы называют IDE (интегрированная среда разработки). Она глубоко интегрирована с инструментами Java и позволяет запускать код прямо изнутри. Idea интегрирована с Gradle, знает как вызывать его задачи и делает это либо сама, либо по кнопке. Фактически пользоваться Gradle через консоль нужно только в случае отладки, когда мы пытаемся разобраться в ошибках.

Теперь пришла пора попробовать завести проект на Gradle в Idea. Лучше всего это сделать по официальной документации с картинками: [https://www.jetbrains.com/help/idea/getting-started-with-gradle.html](https://www.jetbrains.com/help/idea/getting-started-with-gradle.html)

# Установка зависимостей—Java


Управление зависимостями одна из базовых задач Gradle. Он сам умеет скачивать нужные jar с Maven Central и подключать их к проекту или добавлять в jar. Все, что для этого нужно – указать название библиотеки в файле _build.gradle_. Делается это в несколько этапов.

Для начала нужно узнать название библиотеки и ее актуальную версию. Часто эта информация есть прямо в README.md проекта на Github. Например, у библиотеки Apache Commons Lang:

```
You can download source and binaries from our download page.

Alternatively you can pull it from the central Maven repositories:

<dependency>
  <groupId>org.apache.commons</groupId>
  <artifactId>commons-lang3</artifactId>
  <version>3.12.0</version>
</dependency>
```

Здесь прямо указан блок кода, который надо вставить в сборщик. Проблема только в том, что это Maven, а не Gradle. Чтобы получить правильную конфигурацию для Gradle, перейдем на [страницу проекта](https://mvnrepository.com/artifact/org.apache.commons/commons-lang3) в Maven Central. Дальше нужно кликнуть на конкретной версии. Если вы не знаете какая версия вам нужна, выбирайте последнюю доступную, она всегда сверху списка. На [странице версии](https://mvnrepository.com/artifact/org.apache.commons/commons-lang3/3.12.0) есть меню, в котором можно выбрать систему сборки. Если кликнуть на Gradle, то в окошке ниже появится нужная нам строчка:

```
implementation group: 'org.apache.commons', name: 'commons-lang3', version: '3.12.0'
```

Теперь перенесем ее в конфигурацию Gradle:

```
dependencies {
    // Возможно тут уже что-то было добавлено
    implementation group: 'org.apache.commons', name: 'commons-lang3', version: '3.12.0'
    // Сокращенный формат записи:
    // implementation 'org.apache.commons:commons-lang3:3.12.0'
}
```

Дальше, во время запуска на выполнение, Gradle сам скачает нужную зависимость и подключит ее. Все, что останется сделать вам – импортировать нужные классы.

## Обновление зависимостей

Библиотеки постоянно обновляются. В них добавляются новые возможности, исправляются старые баги, улучшается интерфейс. Например, каждая версия Gradle [сопровождается](https://github.com/gradle/gradle/releases) описанием изменений и даже ссылками на коммиты, в которых были сделаны правки.

Gradle не умеет обновлять зависимости из коробки, но его можно расширить плагинами, которые добавят соответствующие задачи. В сети довольно много подобных плагинов, некоторые из них только проверяют наличие новых версий, другие умеют обновлять их самостоятельно.

На текущий момент, самый удобный в работе [Gradle Use Latest Versions Plugin](https://github.com/patrikerdes/gradle-use-latest-versions-plugin). Он автоматически обновляет версии в файле _build.gradle_:

```
./gradlew useLatestVersions

# Пример вывода

> Task :app:dependencyUpdates

------------------------------------------------------------
:app Project Dependency Updates (report to plain text file)
------------------------------------------------------------

The following dependencies are using the latest milestone version:
 - io.freefair.lombok:io.freefair.lombok.gradle.plugin:6.3.0
 - org.apache.commons:commons-lang3:3.12.0

The following dependencies have later milestone versions:
 - com.google.guava:guava [30.1.1-jre -> 31.0.1-jre]
     https://github.com/google/guava
 - org.assertj:assertj-core [3.21.0 -> 3.22.0]
     https://assertj.github.io/doc/
```

После обновления обязательно проверьте работоспособность приложения. Затем зафиксируйте изменения в git-репозитории.

# _Запуск__
1.  Запустите установленную среду разработки Idea и создайте Gradle-проект, следуя [инструкции](https://www.jetbrains.com/help/idea/getting-started-with-gradle.html)
2.  Добавьте в зависимости проекта библиотеку [Apache Commons Lang](https://mvnrepository.com/artifact/org.apache.commons/commons-lang3)
3.  Подключите Gradle плагин Gradle Use Latest Versions Plugin по [инструкции](https://github.com/patrikerdes/gradle-use-latest-versions-plugin) в репозитории
4.  Попробуйте обновить зависимости в проекте

# JDK, JRE, JVM—Java
Работая с Java мы постоянно натыкаемся на несколько аббревиатур: JVM, JDK и JRE. В чем между ними разница и зачем они нужны? Давайте разбираться

## Составные части

JVM (Java Virtual Machine) - Виртуальная машина отвечает за само выполнение кода. Она работает с байткодом (тем, что находится внутри файлов с расширением _.class_).

JRE (Java Runtime Environment) - окружение, необходимое для запуска Java-программ. Включает в себя стандартную библиотеку. В нее входят, как базовые пакеты _lang_, _util_, так и пакеты для работы с различными форматами, базами данных, пользовательским интерфейсом. JVM тоже часть JRE.

JDK (Java Development Kit) - набор программ для разработки. Именно его мы (или редактор) устанавливаем к себе на компьютер, чтобы заниматься разработкой на Java. Он включает в себя JRE, загрузчик кода _java_, компилятор _javac_, архиватор _jar_, генератор документации _javadoc_ и другие утилиты, нужные во время разработки.

## Write once, run anywhere

Java — компилируемый язык. Обычно, когда говорят про такие языки, подразумевают, что компилятор берет исходный код и превращает его в машинный код, заточенный под конкретную архитектуру (машинный код у разных архитектур разный) и операционную систему. Так происходит во многих си-подобных языках. На выходе получаются файлы, каждый из которых может запуститься только на своей комбинации архитектуры и операционной системы.

```
# Компиляция Go программы для двух разных комбинаций
GOOS=linux GOARCH=arm go build path/to/file
GOOS=windows GOARCH=amd64 go build path/to/file
```

Для запуска таких программ больше ничего не нужно. Достаточно перенести их на нужную систему и запустить штатными средствами. Такие программы работают очень быстро, так как оптимизированы под конкретные условия.

```
# Запуск на Windows
hexlet.exe
```

Java устроена по-другому. Разработчики попытались обеспечить кроссплатформенность готовой программы, за счет введения виртуальной машины. Кроссплатформенность, способность программы запускаться на разных платформах (архитектура процессора и операционная система) без необходимости компилировать код под эти системы. Как это работает?

Ядро Java это JVM. Виртуальный процессор, со своим набором команд, который придумали создатели Java. Компилятор готовит код именно под эту единую JVM. Например, код:

```
for (int i = 2; i < 1000; i++) {
    for (int j = 2; j < i; j++) {
        if (i % j == 0)
            continue outer;
    }
    System.out.println (i);
}
```

После компиляции превращается в:

```
0:   iconst_2
1:   istore_1
2:   iload_1
3:   sipush  1000
6:   if_icmpge       44
9:   iconst_2
10:  istore_2
11:  iload_2
12:  iload_1
13:  if_icmpge       31
16:  iload_1
17:  iload_2
18:  irem
19:  ifne    25
22:  goto    38
25:  iinc    2, 1
28:  goto    11
31:  getstatic       #84; // Field java/lang/System.out:Ljava/io/PrintStream;
34:  iload_1
35:  invokevirtual   #85; // Method java/io/PrintStream.println:(I)V
38:  iinc    1, 1
41:  goto    2
44:  return
```

JVM выполняет байткод построчно и транслирует его в реальный машинный код, специфичный для той архитектуры, на которой он запускается.

## Java как платформа

Благодаря наличию виртуальной машины, Java стала не просто языком. Она превратилась в платформу, на базе которой создаются другие языки, причем многие из них достаточно популярны: Kotlin, Clojure, JRuby, Scala, Groovy. Из них только Kotlin похож на Java, остальные отличаются кардинально. Все это благодаря JVM.