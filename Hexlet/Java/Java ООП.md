Классы в JAva интегрированны на уровне языка без возможности выбора.
# Статические методы

Одна из базовых конструкций в программировании - функция. С помощью функций мы выделяем повторяющиеся блоки кода и вводим новые операции, которые не заложены в язык. В большинстве языков функции создаются просто, для этого достаточно знать синтаксис определения. Ниже пример на JavaScript, который будет понятен даже без знания языка:

```
// Функция возвращает строку
// Типы определять не надо, js динамический язык
function greeting() {
  return 'just a string';
}
// Вызов можно делать в любом месте
// Даже просто в файле, вне других функций
greeting(); // 'Just a string'
```

С Java все немного сложнее. Она не позволяет создавать обычные функции. Java требует наличия класса для определения функций, которые, в этом случае, называются методами. Для сравнения перепишем пример с JavaScript на Java:

```
// Имя класса можно выбирать произвольно
class App {
    // public - дает возможность вызывать метод снаружи класса
    // static - пока просто нужно, позже разберемся
    // String - возвращаемый тип
    public static String greeting() {
        return "just a string";
    }
}

// Любой код в Java выполняется только внутри классов
// Поэтому вызов метода greeting() тоже будет где-то внутри

// Где-то в другом месте программы
class SomeName {
    public static void someMethod() {
        // Для вызова статического метода нужно
        // указывать имя класса
        App.greeting();
    }
}
```

Если вызов метода идет из того же класса, где он определен, то указывать имя класса перед ним не нужно:

```

class App {
    public static String greeting() {
        return "just a string";
    }

    public static void main(String[] args) {
        // Тот же класс, поэтому имя не обязательно
        greeting();
    // Хотя, чисто технически, его можно поставить
    // App.greeting();
    }
}
```

[https://replit.com/@hexlet/java-oop-basics-static-methods](https://replit.com/@hexlet/java-oop-basics-static-methods)

Основная разница между функцией `greeting()` на JavaScript и методом `greeting()` на Java заключается в наличии класса в определении метода и его же указание при вызове из других классов. Возникает вопрос, зачем нужен класс когда можно просто создавать функции? Вообще так делать было не обязательно, но создатели Java решили по-другому. Например, в Kotlin, который является более продвинутой версией Java, нет такого ограничения, там можно создавать обычные функции.

Несмотря на наличие класса и смены названия на "метод", по сути, мы получили обычную функцию, которая определена в классе и вызывается через класс. Достигается это за счет ключевого слова `static`. Без него методы работают совсем по-другому, о чем мы поговорим в следующих уроках. Методы, определенные как `static`, называют статическими.

Еще немного примеров статических методов из реальной жизни:

```
// Встроенные в Java
// возвращает модуль числа
int y = Math.abs(-30);

// находит минимальное число
int m = Math.min(10, 11);

// Из библиотеки org.apache.commons.lang3
// возвращает случайное число
int x = RandomUtils.nextInt(1, 1000);
```

Теоретически мы могли бы писать код только в таком стиле, пользуясь одними статическими методами. Этого достаточно для решения любых задач, правда код получится не очень, так как Java все же рассчитана на другой стиль работы.

# Объекты

Так в чем же состоит настоящая цель классов? Упрощенно, с помощью классов описываются категории объектов, например, "кошки" или "адреса" или даже "строки". На базе классов создаются объекты, из которых потом строится логика работы кода.

Возьмем для примера студента Хекслета. В коде он описан классом `User`, у которого есть свойства и методы. Свойства ⎯ это любая информация о пользователе: дата рождения, дата создания, имя, наличие доступов и т.п. Методы – действия которые может выполнять пользователь.

Такой стиль работы предполагает, что класс используется как "шаблон" для создания объектов этого класса (или как говорят "экземпляров класса"). Например, для класса `User`объектами будут конкретные пользователи:

```
// Создание объекта пользователя (или просто пользователя)
// из класса User
// первый параметр - имя
// второй параметр - фамилия
var user = new User("Danil", "Miloshin");

// метод возвращает имя
user.getFirstName(); // "Danil"
// метод возвращает фамилию
user.getLastName(); // "Miloshin"
// метод возвращает полное имя
user.getFullName(); // "Danil Miloshin"
```

В коде мы создаем объект "пользователь" с указанными именем и фамилией. Делается это с помощью ключевого слова `new`, после которого идет имя класса со скобками, как при вызове обычной функции. Этот объект записывается в переменную и становится доступен для работы. Дальше, в зависимости от того как был написан класс, мы можем выполнять разные действия с ним - менять свойства и вызывать методы. Это похоже на работу со строками, только в таких объектах как выше, хранится не одно значение, а какой-то набор разнородных данных. Причем они могут быть разных типов. Вот пример другого класса `User`, который мы могли бы написать:

```
// первый параметр - email
// второй параметр - возраст
var user = new User("admin@hexlet.io", 25);

// Это не статический метод
// он взаимодействует с конкретным объектом и имеет доступ к его данным
user.getEmail(); // "admin@hexlet.io"
```

При таком подходе, программа превращается в набор объектов, которые взаимодействуют друг с другом. Через эти объекты выражаются процессы, происходящие в проекте. Например, создание курса, добавление туда уроков, прохождение курса студентом и так далее. Все это в коде выглядит как объекты, жонглирующие объектами:

```
// Гипотетический пример – Создание курса
// Даже даты это объекты
var course = new Course("java", "тут описание", new Date());
var lesson1 = new Lesson("строки", "тут текст");
course.addLesson(lesson1); // добавляем урок в курс
var lesson2 = new Lesson("числа", "тут текст");
course.addLesson(lesson2); // и еще один
repository.save(course); // сохранение в базу данных
course.getLessons(); // вернет два урока
```

В программировании такой стиль программирования называется объектно-ориентированным (ООП). Чтобы научиться писать такой код, нужно время. В начале, для создания объектов, мы будем использовать или дописывать готовые классы. Затем, постепенно, вы начнете создавать свои, пока это не станет обыденным делом.

## Связь с реальным миром

В интернете много вопросов от новичков, что такое ООП (объектно-ориентированное программирование) и как его понять. Один из самых популярных ответов, рассказ про то моделирование реального мира через классы. Вот у нас есть машина, вот дом, вот мы для них пишем классы. Такое объяснение больше путает, чем помогает. Классы действительно используются для моделирования, но только не реального мира, а конкретной предметной области. Например, пользователь с точки зрения бухгалтера и системы заказа пиццы это абсолютно разные сущности. У них разный набор свойств, разное поведение и разное предназначение. То есть важно понимать, что в коде мы всегда описываем какое-то специфичное представление, которое может идти в разрез с реальным миром. Более того, классами описывается вообще все, что не имеет никакой связи с реальным миром. Чему например соответствует HTTP-запрос? А многие классы носят исключительно утилитарный характер и нужны для обслуживания других частей системы.

А для понимания ООП действительно нужно время. Поэтому сначала полезно работать с уже существующими системами, и только потом уже приходить к проектированию своих.

# Классы
Разберемся в устройстве классов из которых создают объекты на примере кода:

```
var user = new User("Danil", "Miloshin");

// метод возвращает имя
user.getFirstName(); // "Danil"
// метод возвращает фамилию
user.getLastName(); // "Miloshin"
// метод возвращает полное имя
user.getFullName(); // "Danil Miloshin"
```

Первая строчка – это создание объекта из класса. За это отвечает оператор `new`. Затем идет "вызов" класса как функции с передачей туда аргументов. В реальности класс, конечно же, не вызывается. Вызывается конструктор класса, специальный метод, определенный внутри класса и имеющий такое же имя как и класс:

```
class User {
    // Возвращаемый тип не указывается, так как конструктор не может ничего возвращать
    // И здесь нет слова static
    User(String firstName, String lastName) {
        // тут код инициализации
    }
}
```

Конструктор нужен для инициализации объекта. В нашем примере нужно записать данные пользователя так, чтобы они остались внутри даже после завершения выполнения конструктора. Для этого потребуются свойства:

```
class User {
    public String firstName;
    public String lastName;
}
```

Свойства выглядят как переменные, определенные внутри класса («на уровне класса») с добавленными к ним модификаторами доступа, как у методов. Как они заполняются? Через конструктор во время создания объекта:

```
class User {
    public String firstName;
    public String lastName;

    User(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
}
```

Обратите внимание на `this` — это указатель на текущий объект. Через него мы можем читать и записывать свойства, а также вызывать методы нашего объекта. Зачем это нужно? Без `this` код выглядит так `name = value`, то есть как установка значения в обычную переменную. Такой код приводил бы к путанице.

Свойства хранят данные объектов, причем у каждого объекта они свои. Если мы создадим двух пользователей, то между собой они никак не будут взаимодействовать, так как `this`указывает на конкретный объект:

```
var user1 = new User("Jonny", "Depp");
var user2 = new User("Selina", "Dion");

// Обращение к свойству
user1.firstName; // "Jonny"
user2.firstName; // "Selina"
```

Свойства можно не только читать, но и менять:

```
user1.firstName = "Maya";
user1.firstName; // "Maya"
```

## Конструктор по умолчанию

Иногда у объектов начальная инициализация необязательна, либо ее вообще нет. В таком случае определять конструктор не нужно, так как Java определяет для каждого класса конструктор по умолчанию. Это обычный конструктор, но без параметров:

```
// Пример
class Car {
    public String make;

    // Его не нужно добавлять
    // Java сама создает такой конструктор если нет других
    Car() {

    }
}

var car = new Car();
car.make = "bmw";
System.out.println(car.make); // "bmw"
```

## Перегрузка конструктора

Перегрузка методов распространяется и на конструктор. В зависимости от ситуации можно добавлять любые конструкторы, которые удобно.

```
class Course {
    public String name;
    public int duration;

    Course(String name, int duration) {
        this.name = name;
        this.duration = duration;
    }

    // Создаем без указания длительности
    Course(String name) {
        this.name = name;
    }
}

// 18 часов
var course1 = new Course("Java", 18);
var course2 = new Course("PHP");
```

Про перегрузку конструктора полезно знать из-за частого использования в существующих классах, с которыми вам предстоит работать.

# Доступ к свойствам объекта
В реальном программировании к свойствам не принято обращаться напрямую. Почти всегда их делают приватными, то есть закрытыми от прямого внешнего воздействия. Для доступа определяют "геттеры" и "сеттеры". Первые позволяют извлечь свойство, вторые – поменять.

```
var user = new User("Jonny", "Depp");
// Геттер
user1.getFirstName(); // "Jonny"
// Сеттер
user1.setFirstName("Monika"); // "Jonny"
// Геттер
user1.getFirstName(); // "Monika"
```

И реализация:

```
class User {
    // Свойства делаются приватными
    // Попытка обратиться снаружи закончится ошибкой
    private String firstName;
    private String lastName;

    User(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }

    // Методы не статичные

    public String getFirstName() {
        return this.firstName;
    }

    // void потому что ничего не возвращает
    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }
}
```

Геттер просто возвращает значение свойства, а сеттер его меняет. Пример выше можно упростить. `this` обязателен только для записи, но при чтении свойств его можно убрать:

```
public getFirstName() {
    // Если нет локальной переменной с таким именем
    // то вернется свойство если оно есть, иначе ошибка
    return firstName;
}
```

Кроме методов доступа к свойствам, классы позволяют описывать любые другие методы, которые нам нужны. Благодаря им и реализуется логика программы. В примере выше это метод `getFullName()`:

```
public String getFullName() {
    return firstName + " " + lastName;
}
```

Во всех примерах выше, в определении методов, отсутствует слово `static`. Статические методы не принадлежат объектам, и не могут быть через них вызваны. Статические методы связаны с классами. Поэтому, для работы объектов нужны не статические методы.

## Соглашения и правила

При работе с классами нужно придерживаться некоторых соглашений:

1.  Один файл – один класс. Имя файла и класса совпадают
2.  Классы начинаются с заглавной буквы. Методы с прописной за исключением конструктора
3.  Сеттеры и Геттеры создаются путем добавления приставки _set_ и _get_
4.  Свойства всегда приватные

# Ссылочные типы данных

Классы в Java особым образом связаны с типами данных. Посмотрите на пример:

```
var user = new User("Danil", "Miloshin");
```

Каким будет реальный тип в данном случае? Классы, сами по себе, ведут себя как типы. Поэтому типом переменной `user` будет `User`, то есть так:

```
User user = new User("Danil", "Miloshin");
```

В Java все типы данных делятся на две категории: примитивные и ссылочные. К примитивным относятся все виды чисел, символы и логический тип данных (булеан). К ссылочным - классы, массивы, строки. В зависимости от категории, значительно меняется поведение кода и об этом нужно знать. В этом уроке мы разберем отличия между этими категориями и научимся правильно с ними работать.

Для изучения нам понадобится пример какого-то класса, чьи объекты мы используем в примерах кода. Возьмем для простоты класс `User` с двумя полями и одним конструктором:

```
class User {
    public String firstName;
    public String lastName;

    public User(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
}
```

## Значение по умолчанию

Примитивные данные всегда имеют значение, даже если они определяются без инициализации:

```
int a;
System.out.println(a); // => 0
```

У ссылочных в качестве значения по умолчанию используется `null`. Это специальное значение, которое может быть использовано в качестве любого объекта

```
User u;
System.out.println(u); // => null
// Можно присваивать и явно
// User u = null;
```

## Присваивание

Примитивное значение всегда копируется при присваивании:

```
// Содержимое a и b не связаны
var a = 5;
var b = a;
```

Ссылочные же данные не копируются. При присваивании переменные начинают указывать (ссылаться) на один и тот же объект:

```
var u1 = new User("Igor", "Mon");
// В реальности это один и тот же пользователь
var u2 = u1;

u2.firstName = "Nina";

System.out.println(u1.firstName); // => "Nina"

u1 == u2; // true

// Вот теперь тут другой пользователь
u2 = new User("Igor", "Mon");
```

Больше всего это проявляется при передаче данных в методы и их возврате оттуда. Ссылочное значение передается по ссылке, а значит его можно изменить изнутри метода.

```
class UserController {
    // Ничего не нужно возвращать, потому что пользователь будет изменен напрямую
    public static void replaceName(User user, String newFirstName) {
        user.firstName = newFirstName;
    }
}

var u = new User("Igor", "Mon");
UserController.replaceName(u, "Nina");
System.out.println(u.firstName); // => "Nina"
```

## Сравнение

Примитивные данные сравниваются по значению. Пять всегда равно пяти, истина всегда равна истине:

```
var a = 5;
var b = 5;

a == b; // true

var t1 = true;
var t2 = true;

t1 == t2; // true
```

Ссылочные сравниваются по ссылкам, а не по содержимому. Объекты равны только сами себе. То что хранится внутри них - не важно.

```
var u1 = new User("Igor", "Mon");
var u2 = new User("Igor", "Mon");

// Возможно вас это удивит, но сравнение объектов не учитывает содержимое
// Проверяется только ссылка, указывает она на тот же объект или нет
u1 == u2; // false
```

# Строки
Среди встроенных в Java типов данных, строки стоят особняком. У них настолько необычное поведение, что его нужно разбирать отдельно. Строки это объекты класса `java.lang.String`, а не примитивные значения, как можно было бы подумать. Но они существуют в двух формах для производительности. Иногда строки ведут себя как примитивные значения, иногда как объекты.

Зачем строки сделаны объектами? По двум причинам. У строк много полезного поведения, которое удобно реализовать в виде методов. Строки имеют непостоянную длину, по техническим причинам, такие данные внутри памяти хранятся не как примитивные объекты.

Строки как объекты:

```
// Такой способ работы называется String Literal
// Когда строка создается из литерала, специального
// синтаксиса для создания строки (текст обрамленный кавычками)
var name1 = "Hexlet";
name1.toUpperCase(); // "HEXLET"

// Этот способ называется String Object
var name2 = new String("Hexlet");
// Тут то же самое
name2.toUpperCase(); // "HEXLET"
```

С другой стороны, если мы попытаемся сравнить две строки, то получим неожиданный результат:

```
var name1 = "Hexlet";
var name2 = "Hexlet";

name1 == name2; // true
```

По логике, описанной в этом уроке, два создания строки должны приводить к созданию двух разных объектов с разными ссылками. В случае строк все хитрее из-за требований к производительности.

В реальных приложениях строки создаются в больших количествах на каждом шагу. Постоянное создание новых объектов приводило бы к огромному расходу памяти. Разработчики Java схитрили. Если строка создается как String Literal, то объект создается только при первом появлении такого значения строки. Второе и последующие создания строки с уже существующим значением будут ссылаться на ту первую строку:

```
// Внутри JVM создается объект
var lang1 = "Java";
//
// "Java" уже была, поэтому объект не создаем
// ссылаемся на уже созданный ранее
var lang2 = "Java";
// Тоже ссылка на первую строку
var lang3 = "Java";

lang1 == lang2; // true
lang2 == lang3; // true
lang1 == lang3; // true
```

Но если строки созданы как объекты, например через `new String()`, то они будут сравниваться по стандартной схеме:

```
var lang1 = new String("Java");
var lang2 = new String("Java");

lang1 == lang2; // false
```

Логично, но неудобно. В реальном коде сравнивать строки по ссылкам бессмысленно, строки сравнивают по значению. Программисты, в своем коде редко создают строки как объекты и, казалось бы проблемы нет. Если использовать String Literal, то все будет хорошо. К сожалению, эта логика не работает, Java много где выполняет автоматическое преобразование String Literal в String Object:

```
var lang = "Java";

lang.toUpperCase(); // "JAVA"
lang.toUpperCase(); // "JAVA"

// Казалось бы одинаковые значения
// А теперь сравним

lang.toUpperCase() == lang.toUpperCase(); // false
```

Вот это уже проблема. И она настолько важная, что в строки встроили метод `equals`, который сравнивает их по значению независимо ни от чего:

```
var lang1 = new String("Java");
var lang2 = new String("Java");

lang1.equals(lang2); // true
```

Общее правило звучит так. Если у нас нет цели сравнивать ссылки, то всегда используем метод `equals()`, так мы защитимся от случайных ошибок преобразования типов.

# Пакеты
Реальные программы на Java состоят из сотен и тысяч классов! Часть этих классов добавляется программистами проекта, но многие приходят вместе с библиотеками, используемыми внутри. Например, только библиотека [Apache Commons Lang](https://github.com/apache/commons-lang) включает в себя около сотни классов.

<<<<<<< HEAD
_Если быть точными, то речь идет и про классы и интерфейсы, но чтобы постоянно не повторяться, будут упоминаться только классы, хотя все это относится и к интерфейсам тоже_
=======
_Если быть точными, то речь идет и про классы и интерфейсы, но чтобы постоянно не повторяться, в этом уроке будут упоминаться только классы, хотя все это относится и к интерфейсам тоже_
>>>>>>> 0bdab3b5af5e14ff65178893653634b146ea54bf

При таких размерах легко возникают ситуации, когда разные программисты создают классы с одинаковыми именами. Если два таких класса окажутся внутри одного проекта, то он перестанет компилироваться. Иногда мы можем просто переименовать один из классов, но что если классы пришли из библиотек, которые мы используем? Здесь уже без вариантов.

Проблема конфликта имен актуальна для всех языков программирования и решение у всех примерно одинаковое. Для этого вводится система модулей, которая позволяет изолировать классы разных проектов, даже если у них одинаковые имена. В Java такая система называется пакетами.

## Использование пакетов

Пакеты позволяют группировать похожие классы или даже отдельные проекты. Даже стандартная библиотека Java это не просто набор классов, это набор пакетов, внутри которых уже находятся классы. Например, встроенный пакет _java.time_ содержит классы для работы с датой и временем:

```
// Импорт позволяет обращаться по прямому имени
import java.time.LocalDate;
import java.time.Month;
import java.time.temporal.ChronoUnit;

public class App {
    public static void main(String[] args) {
        LocalDate dateFrom = LocalDate.of(2017, Month.MAY, 24);
        LocalDate dateTo = LocalDate.of(2017, Month.JULY, 29);
        long noOfDaysBetween = ChronoUnit.DAYS.between(dateFrom, dateTo);
        System.out.println(noOfDaysBetween);
    }
}
```

В коде выше импортируется три класса из пакета _java.time_. Причем один из них из вложенного пакета _java.time.temporal_. Импортирование позволяет обращаться к классу по его имени, иначе пришлось бы писать полное имя (fully qualified): `java.time.LocalDate.of(...)`. Так тоже можно, но код получается захламленным, его сложнее читать.

Существует еще один способ импорта – с помощью `*`. Тогда код будет выглядеть немного по-другому:

```
import java.time.*;
import java.time.temporal.*;

public class App {
    public static void main(String[] args) {
        LocalDate dateFrom = LocalDate.of(2017, Month.MAY, 24);
        LocalDate dateTo = LocalDate.of(2017, Month.JULY, 29);
        long noOfDaysBetween = ChronoUnit.DAYS.between(dateFrom, dateTo);
        System.out.println(noOfDaysBetween);
    }
}
```

`*` импортирует весь пакет целиком, то есть внутри класса мы можем обратиться ко всем классам импортируемого пакета напрямую. Может показаться, что такой способ удобнее всего, так как не нужно импортировать каждый класс по отдельности. Но тогда возникает две проблемы:

1.  Импортируемые классы из разных мест могут пересечься по именам
2.  Непонятно, кто и откуда был импортирован

Поэтому актуальны все способы и конкретный вариант импорта зависит от ситуации. Правда, обычно об этом думать не надо, так как импорты проставляются редактором автоматически.

Помимо _java.time_ в Java еще есть множество других пакетов, например _java.nio_, _java.util_, _java.net_ и другие. А, поскольку язык развивается, то какие-то пакеты и классы устаревают и не рекомендуются к использованию. Не удивляйтесь наличию примерно одинаковых классов, которые делают примерно одно и тоже. Если какой-то класс или пакет устарел, об этом обязательно укажут в документации.

Встроенные пакеты легко распознать по имени, они все начинаются со слова _java_. Но пакеты бывают и пользовательские. Фактически весь остальной код приложений и библиотек находится внутри своих пакетов. И мы снова приходим к проблеме конфликтов имен, но здесь уже не все так страшно. Пакетов значительно меньше чем классов и, как правило, они содержат какой-то префикс, который закреплен за конкретной компанией или продуктом. Например, пакеты организации Apache начинаются с _org.apache_, то есть это имя домена в обратном порядке. Повторить такое название технически можно, но никто не будет сам себе стрелять в ногу.

_org.apache_ это пакет _apache_ вложенный в пакет _org_. Как не трудно догадаться имя _org_может быть использовано разными компаниями, например _org.w3c_. Такая ситуация допустима, так как классы лежат дальше, уже внутри вложенных пакетов, которые точно уникальны.

```
// Класс генерирующий рандомные числа из пакета org.apache.commons.lang3
// Установку этого пакета в систему мы рассматриваем в другом курсе
import org.apache.commons.lang3.RandomUtils;

public class App {
    public static void main(String[] args) {
        var x = RandomUtils.nextInt(1, 1000);
    }
}
```

Помимо разрешения конфликтов имен пакеты выполняют еще одну функцию — контроль доступа. По умолчанию все классы внутри пакета доступны только классам этого же пакета. Для доступа снаружи их нужно помечать публичными.

## Определение пакетов

Структура пакетов связана со структурой директорий. Если пакет называется _org.apache.commons.lang3_, то путь к нему будет таким _org/apache/commons/lang3_. Имя пакета всегда соответствует директории, если пакет вложенный, то и директория тоже вложенная. В конце цепочки всегда файлы, в которых находятся классы. Их легко определить по названию, имена пакетов всегда идут с маленькой буквы, тогда как классов с заглавной. Пример создания пакета:

```
// io/hexlet/Course.java
package io.hexlet;

public class Course {
    // Тут логика
}

// com/google/App.java
package com.google;

import io.hexlet.Course;

public class App {
    public static void main(String args[]) {
        var course = new Course("Java");
    }
}
```

Классы находящиеся в одном пакете видят друг друга без импортов:

```
// io/hexlet/Lesson.java
package io.hexlet;

public class Lesson {
    private Course course;

    // остальной код
}
```

Здесь может возникнуть вопрос, а по какому принципу раскладывается код по пакетам и вложенным пакетам? Классы стараются группировать по смыслу, но в реальности все зависит от представлений о прекрасном у конкретного разработчика, который этим занимается. Со временем и у вас разовьется это чувство, когда появится насмотренность.

## Статический импорт

Java позволяет импортировать и использовать статические методы и свойства без указания самого класса:

```
import static java.lang.System.*;

class App {
   public static void main(String args[]) {
      // Можем опустить System
      out.println("GeeksforGeeks");
   }
}
```

<<<<<<< HEAD
# Интерфейсы
Классы в Java — основы основ, но их описание будет неполным без интерфейсов с, которыми они тесно связаны. Интерфейсы — более простая конструкция, но, как и в случае с классами, полное понимание интерфейсов требует опыта работы с ними. Зачем они нужны? Интерфейсы позволяют задавать требования к классам, то есть какие методы требуются от класса. Предположим, что мы хотим работать в приложении с генератором паролей. Генератор в нашем случае это обычный класс, с методом `generate()`, возвращающим пароль.

```
var generator = new SimplePasswordGenerator();
generator.generate(); // Возвращает готовый пароль
generator.generate(); // Уже другой пароль
```

Теперь с помощью интерфейса опишем требования к классу генератора. Задача интерфейса — определить функционал, который затем будет реализован классами. Поэтому интерфейс содержит только сигнатуру методов без их реализации. 

Создадим интерфейс `PasswordGenerator` и опишем в нем два метода `generate()`. Один метод будет без параметров, другой — с возможностью настройки длины пароля:

```
interface PasswordGenerator {
    String generate();
    String generate(int length);
}
```

Теперь интерфейс нужно **реализовать**. Делается это в определении класса:

```
// Ключевое слово implements означает, что класс реализует интерфейс PasswordGenerator
class SimplePasswordGenerator implements PasswordGenerator {
    public String generate() {
        // Обращаемся к методу объекта
        // 16 – выбранное значение по умолчанию
        return this.generate(16);
    }

    public String generate(int length) {
        // Тут логика генерации простого пароля
    }
}
```

Интерфейсы не ограничивают класс в его расширении. Помимо интерфейсных методов, мы можем добавить и любые другие. 

Но все таки одно ограничение есть. Если класс применяет интерфейс, то он должен реализовывать все методы, указанные в интерфейсе, причем именно так, как они описаны.

Хорошо, вот мы ввели интерфейс, что он нам дал? Если коротко: полиморфизм, а если точнее — полиморфизм подтипов (subtyping). Прямо сейчас он нам не очень нужен, но для общего развития попробуем ухватить его идею. Осторожно, дальнейший текст может напугать. Если он кажется вам сложным, просто пропустите, все это мы будем повторять еще не раз.

Код, который будет использовать `passwordGenerator` может выглядеть так:

```
class UserController {
    // Здесь создаются пользователи
    // Этот код вызывается где-то внутри приложения при регистрации пользователя
    public void create() {
        // Создаем пользователя
        // И где-то тут же генерируем ему пароль
        var generator = new SimplePasswordGenerator();
        var password = generator.generate();
    }
}
```

Неплохой код, но представьте, что класс может меняться без изменения кода, просто в зависимости от того, какие опции выбирает пользователь при генерации пароля. Вполне реальная ситуация. Самый простой способ реализовать такую схему — вставить условие на параметр, который вводит пользователь. В одном случае берем один класс, в другом другой.

```
var generator;
if (userChooseSomething) {
    generator = new SimplePasswordGenerator();
} else {
    generator = new SuperPasswordGenerator();
}
```

Такой код уже может стать проблемой, если генераторы будут постоянно добавляться. Ситуация ухудшится, когда эта конструкция начнет расползаться по разным частям проекта. Интерфейсы изящно решают такие ситуации. 

Сделаем так, чтобы класс `SuperPasswordGenerator()` тоже реализовывал интерфейс `PasswordGenerator`:

```
class SuperPasswordGenerator implements PasswordGenerator {
    public String generate() {
        return this.generate(16);
    }

    public String generate(int length) {
        // Тут уже другая логика генерации супер-сложного пароля
    }
}
```

Код, который будет использовать `PasswordGenerator`, меняется на такой:

```
class UserController {
    // Интерфейс = Тип
    // Вместо конкретного класса указываем интерфейс
    public create(PasswordGenerator generator) {
        var password = generator.generate();
    }
}
```

Интерфейсы в Java — это настоящие типы данных, поэтому их можно указывать в определениях методов. 

В коде выше видно, что мы требуем передавать в метод `create` тип `PasswordGenerator`. Таким типом будет любой объект, класс которого реализует интерфейс `PasswordGenerator`. Теперь мы можем передать в метод `create()` любой генератор паролей, который реализует интерфейс `PasswordGenerator`. В получившимся коде генератор создается не там, где используется. Он создается где-то раньше, а уже в код приходит нужная реализация. 

Таким образом мы можем получить разное поведение, не меняя сам код, который использует `PasswordGenerator`.

[https://replit.com/@hexlet/java-oop-basics-intrfaces](https://replit.com/@hexlet/java-oop-basics-intrfaces)

Все это уже станет актуальным, как только мы дойдем до Java-коллекций.

## Соглашения и правила

К интерфейсам предъявляются такие же требования как и к классам

1.  Один файл – один интерфейс. Имя файла и интерфейса совпадают
2.  Интерфейсы начинаются с заглавной буквы
=======

>>>>>>> 0bdab3b5af5e14ff65178893653634b146ea54bf
