# Архитектура СУБД

[](https://ru.hexlet.io/courses/rdb-basics)

![Архитектура PostgreSQL](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjM1Njc1YTM3MjEzYjNjM2ZhNDQyYjE0MTliOGNmMWVkLmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=8fcc0b39f61b0ae1a6695716b4dda4b7441b4e46be7e8e6beb32ab59b8cbbc66)

Зачем нужны базы данных? Данные, с которыми работают программы, не существуют сами по себе: их нужно как-то хранить, уметь добавлять, извлекать, читать, обновлять и удалять. Все эти действия было бы сложно проводить, если бы базы данных не имели бы конкретной продуманной структуры. В этом уроке мы изучим подробнее архитектуру баз данных, чтобы лучше представлять себе то, с чем предстоит работать далее в курсе.

## Сложность СУБД

Программы Postgresql, Mysql, Oracle, SQL Server являются **СУБД** — Системой Управления Базами Данных. СУБД не то же самое, что и база данных (БД). **БД** — это хранилище данных, у которых определенная внутренняя структура. Но кто-то должен ее обслуживать: создать, обновлять, записывать в нее данные, выбирать их. Именно этим и занимается СУБД — специальная программа, которую необходимо установить на ту машину, где планируется размещать базу данных.

Когда компьютеры только появились, задачу хранения данных каждый решал по-своему. Самый простой способ хранить данные — положить их в файл. Но тогда неизбежно встанут вопросы:

-   Как потом найти эти данные?
-   А если разные данные имеют разную структуру и разный размер?
-   А что, если данные понадобятся нескольким пользователям одновременно?
-   А что, если во время обновления произойдет сбой?
-   А если данных станет настолько много, что они не поместятся в один файл?

Именно из-за этих вопросов разработка систем хранения — очень сложная и затратная история. Инженеры довольно быстро поняли, что базами данных должна заниматься специализированная программа, функционирующая независимо от софта, который они разрабатывают.

СУБД — невероятно сложные программы, к которым предъявляются практически максимальные требования по надежности, скорости работы и эффективности. Неспроста считается, что если СУБД меньше 10 лет, то это слишком молодой продукт для использования в серьезных приложениях.

## Как устроены СУБД

СУБД реализуется как клиент-серверное приложение:

-   Сервером выступает сама СУБД — она управляет файлами баз данных, принимает запросы от клиентов и выполняет их команды
-   Клиентом считается любое приложение, желающее взаимодействовать с базой данных.

Клиентские приложения могут быть разнообразны по форме:

-   Текстовая утилита
-   Графическое приложение
-   Веб-сервер, использующий базу данных для отображения веб-страниц
-   Специализированный инструмент для обслуживания баз данных

Сервер в такой архитектуре спроектирован так, что он может работать с большим количеством одновременных подключений от разных клиентов. Подобная схема имеет большое значение в реальной жизни. Как правило, база данных используется большим количеством пользователей одновременно.

Иногда сервер и клиент располагаются на одной машине. Это удобно во время разработки:

![Клиент Серверная Архитектура СУБД](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6Ijc2YjM3NTFkZDA5MDI5NGZjYmRjYjdiZGZlMDY5OWI4LmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=5e006ba1fa71e356608ef8a670d4070c9dc6d940ebc20bd9055ce826e12c8b5e)

Утилита `psql` с точки зрения СУБД является клиентом. Если СУБД не запущена, то консоль не сможет запуститься:

```
psql
psql: error: connection to server on socket "/tmp/.s.PGSQL.5432" failed: No such file or directory
    Is the server running locally and accepting connections on that socket?
```

По умолчанию соединение происходит с той машиной, на которой запускается REPL. Это поведение можно изменить, если задать соответствующие параметры

## Создание пользователя в СУБД

Чтобы упростить работу по ходу курса, создадим роль с таким же именем, как и пользователь, из-под которого вы работаете. Выполните следующие действия:

1.  Посмотрите имя вашего текущего пользователя:
    
    ```
    whoami
    
    tirion
    ```
    
2.  Создайте роль с таким же именем внутри PostgreSQL с помощью команды `createuser`. Ее нужно запускать от пользователя `postgres`, иначе она попробует соединиться с СУБД от имени текущего пользователя, которого там нет:
    
    ```
    # Флаг --createdb добавляет нашей роли возможность создавать базы данных
    # По умолчанию этой возможности нет
    sudo -u postgres createuser --createdb tirion
    
    # Чтобы удалить пользователя, можно воспользоваться командой:
    dropuser tirion
    ```
    

Теперь у нас есть роль в СУБД. Попробуем с ее помощью соединиться с PostgreSQL:

```
psql

psql: FATAL:  database "tirion" does not exist
```

Снова ошибка. Теперь `psql` «ругается», что не выбрана база данных. Невозможно соединиться с СУБД, если не указать конкретную базу данных. Ее можно указать самостоятельно — передать один аргумент в `psql`.

Мы уже знаем, что внутри PostgreSQL создана база _postgres_. Попробуем подключиться к ней:

```
psql postgres

postgres=>
```

Соединение удалось. Теперь посмотрим список ролей. Для этого подходит команда `\du`(Describe Users), которую нужно выполнить внутри REPL:

```
postgres=> \du
                                   List of roles
 Role name |                         Attributes                         | Member of
-----------+------------------------------------------------------------+-----------
 postgres  | Superuser, Create role, Create DB, Replication, Bypass RLS | {}
 tirion    | Create DB                                                  | {}
```

В СУБД создалось две роли: _postgres_ и которую самостоятельно добавили ранее. Теперь создадим базу данных.

## Создание базы данных в СУБД

Для экспериментов нам понадобится база данных и, возможно, даже не одна. Создадим базу с именем _hexlet_. Сделать это можно из командной строки командой `createdb`:

```
# Опция --owner позволяет указать владельца создаваемой базы данных
sudo -u postgres createdb --owner=tirion hexlet
# Если запустить эту команду без аргументов,
# то она попытается создать базу данных,
# которая совпадает с именем вашего пользователя в системе
createdb hexlet
```

Имя для базы данных выбирается произвольно и обычно совпадает с названием проекта, для которого она создается. Имена баз уникальны в рамках одной СУБД. Это значит, что повторный вызов `createdb` с тем же именем приведет к ошибке.

После установки PostgreSQL создает несколько служебных баз данных, которые нужны для работы самой СУБД. Посмотрим их список:

```
# Посмотреть список баз данных
psql -l

# Неполный вывод
                          List of databases
   Name    |  Owner   | Encoding |   Collate   |    Ctype    |
-----------+----------+----------+-------------+-------------+
 pgadmin   | pgadmin  | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
 tirion    | tirion   | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
 postgres  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
 template0 | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
 template1 | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 |
```

Теперь у нас есть роль и база данных для экспериментов. Подключимся к этой базе данных:

```
psql hexlet

hexlet=>
```

Созданную базу данных можно удалить командой `dropdb`:

```
dropdb hexlet
```

Если удалили, не забудьте ее снова создать, так как она понадобится нам в дальнейшем.

Запускать команду `dropdb` нужно с осторожностью. Удаление базы данных — необратимый процесс, так как базы невозможно восстановить без резервных копий. Чтобы избежать проблем: команда `dropdb` не работает без аргументов — ей всегда нужно передавать имя базы.

Удалить базу данных можно только в том случае, если к ней никто не подключен — за исключением того, кто удаляет. Если есть другие клиенты, например _psql_ или _pgadmin4_, то СУБД предупредит о невозможности выполнить команду.

```
dropdb hexlet
dropdb: error: database removal failed: ERROR:  database "hexlet" is being accessed by other users
DETAIL:  There is 1 other session using the database.
```

## Структура реляционной базы данных

Данные в реляционных базах данных хранятся в таблицах. Их структура напоминает Microsoft Excel. Каждая строка в таблице — это связанный набор данных, который относится к одному предмету. Например, в таблице можно посмотреть все детали об одном сотруднике — его фамилию, имя, номер, отдел, зарплату, год рождения, адрес и телефон:

![Microsoft Excel](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjVhN2M4NTI3ZDNjMTFjZjk5NWZhZTA3NmZjNzAzNzBlLnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=27b2fa7db10f61cf08f5646bd6c039e9c0c276d823539da61d1cfca4c4499bad)

Разные таблицы предназначены для хранения информации о различных сущностях, например, пользователи, статьи или заказы в интернет-магазине. В типичных веб-приложениях таблиц десятки и сотни, в больших — тысячи. Например, в Хекслете их несколько сотен.

У таблиц в базе данных есть определенная структура. Она включает:

-   **Название таблицы** — уникально в рамках одной базы данных. Имя таблицы и ее структура задаются при создании, но их можно изменить впоследствии
-   **Столбцы** или **поля** — располагаются в строго определенном порядке, и у каждого поля уникальное имя в рамках одной таблицы
-   **Тип данных** — сопоставляется каждому столбцу. Тип данных ограничивает набор допустимых значений, которые можно присвоить столбцу, и определяет смысловое значение данных для вычислений. Например, в столбец числового типа нельзя записать обычные текстовые строки, но его данные можно использовать в математических вычислениях, и наоборот
-   **Строки** — их число переменно и отражает текущий объем данных. В отличие от таблиц в Exсel, в таблицах реляционных баз данных нет никаких гарантий относительно порядка строк в таблице. Он может быть любым, и его можно задать с помощью языка SQL, который рассмотрим позже. Объем данных в разных таблицах сильно отличается — от нескольких штук до миллиардов записей

Пример таблицы с именем `users`:

**Структура**

Включает в себя имена полей и их типы. Структура определяет столбцы:

```
first_name string
last_name  string
email      string
created_at datetime
```

**Содержание**

Включает в себя данные. Содержание определяет строки:

```
| first_name | last_name |       email       | created_at |
|------------|-----------|-------------------|------------|
| Сергей     | Петров    | serj@gmail.com    | 11.10.2005 |
| Иван       | Сидоров   | sidorov@yahoo.com | 03.08.2000 |
| Виктор     | Курганов  | vkurg@indbox.com  | 23.12.2011 |
```

_first_name, last_name, email_ и _created_at_ — это имена столбцов. Строки содержат данные по каждому столбцу, а в поле _created_at_ установлен тип данных _datetime_, поэтому туда нельзя записать текст.

В дальнейшем эту структуру можно модифицировать: удалять и добавлять поля, менять типы данных.

## Правила именования сущностей базы данных

Именование таблиц и полей в базе не фиксировано и зависит от программиста. Например, в проектах, где используют ORM — название группы фреймворков или библиотек, которые помогают моделировать предметную область и связывать ее с базой данных, — имена определяются соглашениями конкретной экосистемы.

В этом курсе мы используем именование, принятое во фреймворке **Rails** и его ORM (ActiveRecord). Оно состоит из нескольких правил:

-   Все имена в нижнем регистре
-   Для имен из нескольких слов используется **snake_case** — когда слова разделяются подчеркиванием `_` без пробелов
-   Имя таблицы во множественном числе

В отличие от Excel, где ввод данных и отображение визуальные, в СУБД у данных нет никакого представления. Они вводятся и выбираются с помощью команд. При этом существуют специальные клиенты, которые используются, чтобы визуализировать управление базами данных. Они бывают платными и бесплатными. Из бесплатных в мире PostgreSQL наиболее популярен [PgAdmin](https://www.pgadmin.org/):

## Создание базы данных

Прежде чем создать таблицу, создадим базу данных `hexlet` с помощью SQL (если вы еще этого не сделали). Для этого подключитесь к СУБД через `psql`. При этом не указывайте базу данных, чтобы подключиться к базе по умолчанию. Далее выполните следующие запросы:

```
DROP DATABASE hexlet;
CREATE DATABASE hexlet;
```

В примере выше два SQL запроса:

-   `DROP DATABASE hexlet` — удаляет базу данных с именем `hexlet`
    
-   `CREATE DATABASE hexlet` — создает базу данных с таким же именем
    

Базовые правила построения запросов:

-   Каждый запрос должен заканчиваться точкой с запятой. Иначе `psql` будет думать, что вы продолжаете вводить команды
    
-   Регистр не важен. Можно было написать `drop database hexlet;`. По традиции принято использовать верхний регистр для ключевых слов самого SQL. Это позволяет визуально разделять структуру запроса от данных внутри него. Последнее в примере — это имя базы данных, которое может быть произвольным
    

Если подключиться к той же базе данных, которую вы хотите удалить или пересоздать, то во время попытки удаления СУБД будет ругаться, что к базе есть активное соединение — ваше соединение. Поэтому важно подключиться к любой другой базе данных.

Команды `createdb` и `createuser`, которые мы разобрали в прошлых уроках, выполняют SQL-запросы внутри СУБД. Их сделали ради удобства первоначальной настройки, и чтобы использовать в скриптах автоматизации.

SQL поддерживает **комментарии** — строчка, которая начинается с двух дефисов. Комментарии игнорируются СУБД при построении запросов:

```
hexlet=> -- i am comment
hexlet=>
```

Нам удалось создать базу данных `hexlet`, поэтому можно переходить к созданию таблицы.

## Создание таблиц

Таблица создается с помощью запроса `CREATE TABLE`:

```
-- Это один запрос, хоть и многострочный.
-- Описание запроса заканчивается символом ;
CREATE TABLE courses (
    name          varchar(255),
    slug          varchar(255),
    lessons_count integer,
    body          text
);
```

Чтобы создать таблицу, необходимо указать ее имя, набор полей и их типы. В примере выше названия полей — это `name`, `slug`, `lessons_count` и `body`, а `varchar(255)`, `integer` и `text` — их типы.

### Типы данных

У каждого поля в PostgreSQL определенный тип, который задается на этапе создания таблицы. Это значит, что значением этого поля могут быть только определенные данные. Если поле имеет числовой тип, то в него невозможно вставить строку, и наоборот. База данных выдаст ошибку при попытке выполнить подобный запрос.

```
-- Выполняем запрос на вставку передавая в lessons_count строку вместо числа
ERROR:  invalid input syntax for type integer: "wrong value"
```

В PostgreSQL встроено много различных типов данных, но на практике используются не все. Ниже мы разбираем только самые популярные типы.

#### Строки

Для строк в базах данных в основном используются два типа:

-   _varchar_ — для строк с ограничением максимальной длины
-   _text_ — для строк без ограничения. Как правило, это полноценные тексты

В базах данных нельзя оставить один тип без указания длины. Это связано с производительностью и эффективностью. Данные в базах данных физически хранятся на дисках в файлах. Быстрый доступ к этим данным возможен только тогда, когда у данных фиксированный размер. Это позволяет быстро перемещаться по ним и считать смещения.

Если размер данных не известен, то придется просматривать весь файл в поисках нужного значения. Чтобы избежать подобной ситуации, тип _text_ хранится отдельно. Это тоже негативно влияет на скорость, но уже не так сильно. Если размер строки известен или он меньше какого-то значения, то предпочтительнее использовать _varchar_.

character varying(n), varchar(n)  -
строка ограниченной переменной длины

text - 
строка неограниченной переменной длины

-   _varchar_. Полное название типа _character varying_ (_varchar_ может использоваться как псевдоним). Размер строки с таким типом указывается в скобках после названия типа, например, _varchar(10)_. Это значит, что в поле с таким типом можно записать строку длиной до 10 символов.
    
-   _text_. Не требует указания размера и может содержать текст произвольной длины
    

Пример создания таблицы с такими типами:

```
CREATE TABLE blog_posts (
    name          varchar(80),
    body          text
);
```

#### Числа

Для чисел в основном используются два типа данных: _integer_ и _bigint_. Какой конкретно указывать тип, зависит от потенциального потолка значения. Ниже указаны диапазоны, допустимые в рамках этих типов:



integer  типичный выбор для целых чисел

-2147483648 .. +2147483647

bigint.  целое в большом диапазоне

-9223372036854775808 .. 9223372036854775807

Пример создания таблицы с такими типами:

```
CREATE TABLE users (
    id          bigint,
    age         integer
);
```

#### Даты

Типы для хранения дат отличаются друг от друга очень сильно, в первую очередь по решаемой задаче. Нам надо хранить день без конкретного времени? Это тип _date_. Нужно конкретный момент времени, тогда _timestamp_. Просто время без даты? Тогда _time_.

timestamp дата и время (без часового пояса)
date. дата (без времени суток)
time время суток (без даты)


Пример создания таблицы с такими типами:

```
CREATE TABLE events (
    start_date          date,
     -- имя поля может называться как тип данных
    time                time,
    updated_at          timestamp,
    created_at          timestamp
);
```

Хорошей практикой считается добавление и заполнение полей _created_at_ и _updated_at_ в каждую таблицу базы данных. С их помощью всегда можно узнать, когда запись создалась и обновилась.

Значения даты и времени принимаются практически в любом известном формате. Вот несколько примеров того, как можно задавать дату:


#### Логический тип

Содержит всего два значения: `true` и `false`. Этот тип используется для флагов:

boolean.  true или false (истина или ложь)

Пример создания таблицы с такими типами:

```
CREATE TABLE blog_posts (
    -- флаг: опубликован?
    published          boolean
);
```

Состояние «true» может задаваться следующими значениями:

```
TRUE
't'
'true'
'y'
'yes'
'on'
'1'
```

Для состояния «false» можно использовать следующие варианты:

```
FALSE
'f'
'false'
'n'
'no'
'off'
'0'
```

#### NULL

Помимо типов данных для реальных значений, в базе существует специальное значение `NULL`, чтобы обозначать пустоту. Оно используется, когда у конкретного поля нет значения. Тип поля при этом не важен. Подробнее с `NULL` мы разберемся в следующих уроках.

## Анализ структуры базы данных

Чтобы исследовать структуру таблиц в визуальном режиме, используется _PgAdmin_:

![PgAdmin](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjQ2YzQ5MWMwMmZhOGFlOTc0ZWRmNzU3OGQzNjczYjI3LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=796506442ab4701dbbac404829e0dba0d59bc42762cbfa78d57647dfec7b14a7)

SQL для анализа структуры базы данных не существует. Если вы хотите посмотреть список таблиц и их структуру в базе данных, то придется использовать команды самого `psql`:

**Просмотр списка таблиц базы данных hexlet**

```
hexlet=> \d
         List of relations
 Schema |    Name    | Type  |  Owner
--------+------------+-------+---------
 public | courses    | table | vagrant
 public | events     | table | vagrant
 public | blog_posts | table | vagrant
```

Здесь мы видим список таблиц в базе данных _hexlet_. Все что здесь отображается, было создано в этом уроке выше.

В первом столбце видим новое для нас понятие — _schema_. Это пространство имен, которое позволяет группировать таблицы, в различных ситуациях. На практике эта возможность используется редко, поэтому мы не обращаем на нее внимание. По умолчанию все таблицы публикуются в общей схеме _public_, которую можно не указывать.

**Просмотр структуры таблицы courses**

```
hexlet=> \d courses
# public - обозначает схему по умолчанию
               Table "public.courses"
    Column     |          Type          | Modifiers
---------------+------------------------+-----------
 name          | character varying(255) |
 slug          | character varying(255) |
 lessons_count | integer                |
 body          | text                   |
```

В этом выводе показана структура таблицы _courses_. Здесь мы видим все имена полей и их типы.

Кроме перечисленных полезными могут оказаться следующие команды:

-   `\l` — список всех баз данных
-   `\dt` — список всех таблиц
-   `\?` — вывод справки

## Удаление таблиц

Чтобы удалить таблицу, выполняется запрос `DROP`:

```
DROP TABLE courses;
```


## Работаем с данными в таблице

С данными в SQL работают с помощью подмножества **DML** (Data Manipulation Language). Оно включает:

-   `INSERT` — запрос на вставку данных
-   `UPDATE` — запрос на обновление данных
-   `DELETE` — запрос на удаление данных

Разберем каждый запрос подробнее.

### Вставка данных в таблицу

Чтобы вставить данные в таблицу, нужно выполнить `INSERT INTO` запрос:

```
-- Числовое значение указывается без дополнительных символов,
-- а строковые взяты в одинарные кавычки
INSERT INTO courses (name, slug, lessons_count, body)
  VALUES ('basics of programming', 'basics', 10, 'this is theory');
```

-   `INSERT INTO courses` — запрос на вставку в таблицу _courses_
-   `(name, slug, lessons_count, body)` — список полей, которые нужно вставить
-   `('basics of programming', 'basics', 10, 'this is theory')` — значения вставленных полей в том же порядке

Выполнять запрос на вставку можно любое количество раз. Каждый раз в таблице будет создаваться новая запись, даже если данные не поменялись. Изменить это поведение можно с помощью уникальных индексов, которые разберем позже.

Если мы хотим оставить некоторые поля пустыми, то достаточно пропустить их при вставке в обеих частях запроса. В таком случае значением этих полей будет `NULL`:

```
INSERT INTO courses (name, slug) VALUES ('Bash', 'bash');
```

`NULL` — это специальное значение и оно одно. Пустая строка, 0 и тому подобные вещи не являются `NULL`.

`INSERT` позволяет вставить сразу несколько записей в рамках одного запроса. Для этого достаточно перечислить все необходимые значения в круглых скобках через запятую после ключевого слова `VALUES`:

```
-- В результате в таблице добавится три записи
INSERT INTO courses (name, slug) VALUES
  ('Bash', 'bash'), ('PHP', 'php'), ('Ruby', 'ruby');
```

Поля можно не указывать, тогда это равносильно их полному перечислению:

```
-- Значения идут в том же порядке, в котором определены поля в таблице
INSERT INTO courses VALUES ('linux', 'linux', 3, 'something about linux');
```

Чтобы извлечь данные и посмотреть содержимое таблицы, используем запрос `SELECT`:

```
hexlet=> SELECT * FROM courses;
         name          |  slug  | lessons_count |         body
-----------------------+--------+---------------+-----------------------
 basics of programming | basics |            10 | this is theory
 bash                  | bash   |               |
 linux                 | linux  |             3 | something about linux
(3 rows)
```

Запрос `SELECT` не является частью DML. Подробнее о нем поговорим в следующем уроке.

### Обновление или изменение данных

Обновление записей в таблице выполняется `UPDATE` запросом:

```
UPDATE courses SET body = 'updated!' WHERE slug = 'bash';
```

Обычно `UPDATE` запрос состоит из двух частей:

1.  `SET body = 'updated!'` — описывается, какое значение установить в какое поле
2.  `WHERE slug = 'bash'` — указывается ограничение на то, к каким строкам применить обновление

Символ «=» в `WHERE` — это не присваивание, а проверка на совпадение. В `SET` равно используется как обычное присваивание.

Поскольку в нашей таблице только одна запись удовлетворяет условию `slug = 'bash'`, то и обновится одна запись. Если бы их было больше, то обновились бы все соответствующие записи.

`UPDATE` в примере выше можно выполнять безопасно любое количество раз. После первого запроса дальнейшие его вызовы не сделают никаких изменений.

За одну операцию можно обновить несколько полей. Для этого достаточно перечислить каждое присваивание через запятую в части `SET`. Порядок, в котором изменяются поля, — не важен:

```
UPDATE courses SET body = 'updated!', name = 'Bash' WHERE slug = 'bash';
```

Часть `WHERE` можно вообще не указывать:

```
UPDATE courses SET body = 'oops';
```

Такой запрос обновит все записи. Если записей в таблице много и они важны, то он приведет к тому, что данные конкретного поля будут перезаписаны у всех данных в таблице. Почти наверняка это не то, чего мы хотим. Поэтому нужно внимательно следить за тем, как пишется `update`. Потеря условия `WHERE` может обернуться перезаписью важных данных.

Проверка на точное соответствие это самый простой способ сравнения, которого не всегда достаточно. SQL позволяет выполнять значительно более хитрые проверки. Рассмотрим несколько примеров:

-   Операции сравнения
    
    Мы можем использовать любые математические операции сравнения: больше, меньше, не равно и другие.
    
    ```
    -- Количество уроков больше трех
    UPDATE courses SET name = 'new name' WHERE lessons_count > 3;
    -- Количество уроков меньше двух
    UPDATE courses SET name = 'another new name' WHERE lessons_count < 2;
    ```
    
-   Логические операции
    
    Мы можем использовать логические операции для объединения условий: И и ИЛИ.
    
    ```
    -- slug равен 'bash' И количество уроков больше 3
    UPDATE courses SET name = 'new name'
      WHERE slug = 'bash' AND lessons_count > 3;
    
    -- количество уроков меньше 2 ИЛИ количество уроков больше 8
    UPDATE courses SET name = 'another new name'
      WHERE lessons_count < 2 OR lessons_count > 8;
    ```
    
    Для логических операций используются ключевые слова `AND` и `OR`. Их можно добавлять и комбинировать в любых количествах. Как и в случае с обычными языками программирования, в составных выражениях полезно задавать приоритет с помощью круглых скобок:
    
    ```
    -- slug равен 'linux' ИЛИ
    -- количество уроков должно быть от 2 до 8
    UPDATE courses SET name = 'another new name'
      WHERE (lessons_count > 2 AND lessons_count < 8) OR slug = 'linux';
    ```
    

### Удаление данных

Последний запрос из DML — `DELETE`. С его помощью можно удалить данные из таблицы:

```
DELETE FROM courses WHERE slug = 'bash';
```

Этот запрос работает практически так же, как и `UPDATE`. Только здесь ничего не надо указывать после `DELETE`.

Такой запрос опасно выполнять. Он отработает, даже если не указана секция `WHERE`. Секция `WHERE` в разных видах запросов работает идентично — все, что описывалось для `UPDATE`, справедливо и для `DELETE`.

В базах данных есть еще один способ удалять данные в таблице — `TRUNCATE`. Это не часть стандарта, но реализуется большинством баз данных. У этого запроса есть две особенности:

-   Он предназначен для полной очистки таблиц
-   В отличие от `DELETE`, он выполняется очень эффективно, так как у `TRUNCATE` нет возможности задавать условия. В этом случае СУБД не нужно ничего дополнительно анализировать. Она сразу очищает место на диске без промежуточных этапов:

```
TRUNCATE courses;
```

# Выборка данных
В типичных веб-приложениях данные выбираются в 10 раз чаще, чем модифицируются. Для этого используют запрос `SELECT`. Его простая форма выглядит так:

```
SELECT * FROM users;
```

![SELECT всех полей из таблицы](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjFjMDM2OTllN2ZlZDY5ZmRhNDc2M2U5MzE2MzI3ZTg1LmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=846b95645db53ad057928e73b363ec9cf2efd10fc5255c528ca8209b76aed509)

Этот запрос достает все содержимое таблицы `users`. Звездочка в примере означает все поля. Если поля нужны не все, то достаточно перечислить их через запятую вместо звездочки:

```
SELECT username, email FROM users;
```

![SELECT только определенных полей](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjAwNmFkYTBjYzIyMjNhYzFmMTgyNTk1MDYxMTQyZTUxLmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=1407261f67f83fda1eecce65a29b3b48dd0c0f7271c84ddf3bfbca3e59d2af42)

Поля необязательно перечислять в том же порядке, в котором они идут в таблице. В результате такого запроса порядок полей в выводе будет соответствовать не тому, что в таблице, а указанному в части `SELECT`.

На практике выборка, которая извлекает все записи, встречается редко. Дело в том, что у таблиц бывают большие объемы и нужно ограничивать вывод для конкретного пользователя. В этом случае используется `WHERE`, который мы рассматривали в прошлом уроке. Он работает одинаково вне зависимости от типа выполняемого запроса, будь-то `UPDATE`, `DELETE` или `SELECT`:

```
-- После WHERE указывается имя поля, которое сравнивается с некоторым значением (это один из вариантов)
-- Выбираем всех пользователей, которые родились ранее 21 октября 2018 года
SELECT * FROM users WHERE birthday < '2018-10-21';
```

Даже в таком варианте количество возможных записей может быть слишком большим. Поэтому нужно сделать так, чтобы из всей информации выбиралось ограниченное количество записей.

## Пагинация

Когда записей очень много, можно реализовать пагинацию — она позволяет перемещаться по страницам, если их много. Этот механизм можно реализовать целиком в коде. Но так не делают, потому что количество данных, перегоняемых из базы данных в код, может быть огромным. На такую задачу не хватит ресурсов сервера. Поэтому пагинацию реализуют на уровне базы данных.

Чтобы реализовать его, используют `LIMIT` — ограничение на количество записей, которые выбирают из базы данных:

```
SELECT * FROM users LIMIT 3;
```

Число после `LIMIT` — это количество записей, которые мы хотим выбрать. В нашем примере запрос выберет не больше трех записей. Если в таблице их меньше, то выберутся все. Количество записей в лимите можно увеличивать или уменьшать.

SQL не гарантирует порядка в выборках выше. Если не указать сортировку, то мы не можем знать, в каком порядке вернутся данные. Поэтому в подобных выборках всегда присутствует секция `ORDER BY`:

```
SELECT * FROM users ORDER BY birthday;
```

Такой запрос отсортирует данные по ключу `birthday` в прямом порядке — кто родился раньше, будет выше. Если нужно отсортировать в обратном порядке, то надо добавить ключевое слово `DESC`:

```
SELECT * FROM users ORDER BY birthday DESC;
```

Такой запрос вернет пользователей, отсортированных по дню рождения в обратном порядке — выше будут те, кто младше.

На этом базовые возможности `SELECT` заканчиваются. Все части запроса, которые мы рассмотрели, комбинируются друг с другом и даже могут использоваться одновременно:

```
-- Порядок следования частей `WHERE`, `ORDER BY` и `LIMIT` в SQL запросе фиксирован.
SELECT username, created_at FROM users WHERE birthday < '2018-10-21' ORDER BY birthday DESC LIMIT 2;
```

Запрос читается практически как фраза на английском языке: "Выбрать поля username и created_at из таблицы users для пользователей, которые родились раньше 2018-10-21. Результат должен быть отсортирован по дню рождения в обратном порядке. Ограничить выборку двумя записями."

Чтобы было удобно считывать код, длинные запросы разбивают на строчки:

```
SELECT
    username,
    created_at
FROM users
WHERE birthday < '2018-10-21'
ORDER BY birthday DESC
LIMIT 2;
```

# Реляционная модель данных
Логика работы в реляционных СУБД строится на реляционной алгебре. Поэтому в подобных системах добавляют приставку «реляционная». Прикладному программисту необязательно разбираться в этой области алгебры, но знать основы полезно.

В этом уроке мы разберем способы представления данных и расскажем, почему реляционная модель подходит для этого лучше всего.

## Способы представления данных

Данные и как они хранятся на диске — две большие разницы. Физическое размещение данных на носителях — возможность конкретных СУБД. И в этом случае они соревнуются, кто быстрее и эффективнее.

Внешнее представление — это то, что видит пользователь. Оно влияет на способ взаимодействия с данными. Поэтому разные способы представления данных называются **моделями**.

Эти модели не отражают то, что происходит на физическом уровне. Они описывают, как данные структурированы, и как с ними взаимодействовать. Модели данных очень похожи на абстрактные типы данных, которые определяют интерфейс взаимодействия с типом и не определяют его внутреннюю реализацию.

Существует много разных способов представить одни и те же данные. В этом уроке мы разберем три самых популярных:

-   Иерархическая модель
-   Сетевая модель
-   Реляционная модель

Разберем каждый способ подробнее.

### Иерархическая модель

В **иерархической модели** данные представлены в виде дерева, где дочерние элементы находятся в зависимости от родительских:

![Иерархическая модель данных](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjE4ZGQ3M2EzMDQzNzgwMzI1MmU2ZGRhMWExMjFiYjdiLmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=77b55684d559781a62ec7ed9e5c5253b3bacbe96c17d661bfb28853747d346d4)

С помощью иерархической модели можно представить не только университет, но и составляющие бизнеса. К примеру, у сервиса такси есть такие понятия, как пользователь и заказ. У одного пользователя может быть множество заказов. Это сразу определяет структуру дерева:

-   Родительский элемент — пользователь
-   Дочерние элементы — заказы

Подобным образом структурируются и все остальные части.

Проблемы начинаются, когда у одного дочернего элемента может быть несколько родительских. Представим, что сервис такси добавил такую функцию — можно оплачивать счет совместно. Это значит, что у одного заказа сразу несколько клиентов.

В этом случае иерархическая модель не может предложить хорошего решения данной задачи. Придется создавать параллельные деревья, в которых появится дублирование данных. Эта проблема решается в сетевой модели данных, которую мы разберем далее.

### Сетевая модель

**Сетевая модель** данных расширяет иерархическую и позволяет иметь множество предков. Сетевая модель — это **граф**, у которого много вершин и соединений между ними:

![Сетевая модель данных](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImRiYjBiMzAwY2Q2MmY4NjFhY2U1ZDU1MjM4ZWZjNTJlLmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=c26c2c089fd83994de2421f94f2d94770d698bf6cc3ddb9216f8886e493aec7f)

В сетевой структуре каждый элемент может быть связан с любым другим элементом.

Недостаток сетевой модели данных — высокая сложность и жесткость схемы БД, которая построена на ее основе. Поскольку логика процедуры выборки данных зависит от физической организации этих данных, то эта модель не является полностью независимой от приложения. Если необходимо изменить структуру данных, то нужно изменить и приложение.

Чтобы не столкнуться с еще одной проблемой, программисты используют реляционную модель.

### Реляционная модель

Наибольшее распространение получила **реляционная модель** данных. На ее основе построены реляционные СУБД. В реляционной модели данные — это набор отношений. В алгебре понятие **отношение** звучит так:

> Пусть дана совокупность типов данных T1, T2, ..., Tn, называемых также доменами, необязательно различных. Тогда n-арным отношением R, или отношением R степени n называют подмножество декартовa произведения множеств T1, T2, ..., Tn.

Разберем это определение, чтобы лучше его понять.

#### Что такое отношение в реляционной модели

У отношения нет физического представления. Реляционная база данных — это попытка отразить реляционную модель, а не ее точная копия.

Реляционная модель опирается на раздел математики теорию множеств, которую нужно знать хотя бы немного. Множество — это совокупность произвольных элементов, которые объединены по некоторому признаку. Например, множество натуральных чисел или множество учеников одного класса. Изучить этот раздел подробнее вы можете в нашем курсе [«Теория множеств»](https://ru.hexlet.io/courses/set-theory).

Из любого множества можно выделить **подмножество** — множество элементов, все элементы которого входят в исходное множество. Подмножество — это часть множества. Например, множество натуральных чисел — это подмножество по отношению к множеству целых чисел, которое в свою очередь — подмножество рациональных чисел. Из этого следует, что натуральные числа — это подмножество рациональных чисел.

Еще одно важное понятие — **кортеж**. Это упорядоченный набор данных фиксированной длины. Элементами кортежа может быть все что угодно. Это математический способ представить некоторый набор связанных данных.

На основе этих понятий можно сформулировать более понятное определение отношения. Отношение — это множество кортежей, которые называются **телом отношения**. В нем каждый кортеж соответствует схеме.

**Схема** — это заголовок отношения. Она описывает общую структуру кортежей, количество элементов внутри них и их типы. Каждый такой элемент называется **атрибутом**:

![Отношение](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6Ijk2OWRhNTVhMDE4ZTgwOTRmMzI0ZDMzMzFiYTM2NGMxLmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=9e7a79130cebd83e953aa3dffdf91481e8948cd045c3dc946c3614e0d3826251)

Отношение визуально похоже на таблицу, но у него есть существенные отличия:

-   Нет двух одинаковых элементов (кортежей)
-   Порядок кортежей не определен
-   Порядок атрибутов в заголовке не определен

По этой причине таблица непригодна для точного описания отношения. В любой таблице порядок столбцов (атрибуты схемы) и строк (кортеж) строго определен. При этом на практике мы оперируем таблицами и не можем игнорировать их.

Во всех реляционных базах данных столбцы расположены в определенном порядке, и данные тоже добавляются строго определенным образом. Но этот порядок зависит от реализации самой базы данных и не может быть задан, а задается только при выборке.

Реляционная модель — удачный выбор в большинстве ситуаций. У нее нет недостатков, которые есть у других моделей. Но чтобы ее освоить, нужно время, так как придется научиться раскладывать данные по таблицам правильным способом. Чтобы взаимодействовать с данными, которые описаны реляционной моделью, используется реляционная алгебра. Ее элементы мы рассмотрим позже.

Данные, представленные в реляционной модели, нужно привести к **нормальной форме** — это требования, которым должно удовлетворять отношение для минимизации избыточности данных, потенциально приводящих к логическим ошибкам.

# Первая нормальная форма

Чтобы облегчить считываемость информации в таблице, программисты приводят данные, которые представлены в реляционной модели, к нормальной форме. В этом уроке мы узнаем, что это за форма, а также разберем ее первый уровень.

## Нормальная форма

Возьмем для примера интернет-магазин, в котором продается электроника. Когда пользователь делает заказ, в базу данных заносится запись об этом. В нее входит вся необходимая информация: данные пользователя, какой товар он купил, сколько он стоил и адрес доставки. Затем эти данные используются всеми подразделениями интернет-магазина — от бухгалтеров до службы доставки.

**Таблица order_items**

|first_name |last_name| address| item| price|
|---|---|---|---|---|
|Сергей|Иванов|Москва, ул. Промышленная|утюг|15.00|
|Виктор|Сидоров|Омск, ул. Дворцовая|утюг, телевизор|1000.00, 6500.00|

В первой строке последнего столбца цена указана в долларах, в остальных записях — это рубли. Последняя запись повторяет предыдущую, потому что этот заказ выполнил тот же человек, но сделал это в другое время.

В этой табличке много повторяющейся информации. Приведем ее к правильной структуре с точки зрения реляционной модели. Для этого приведем данные к **нормальной форме** — это требования, которые минимизируют избыточность данных, потенциально приводящих к логическим ошибкам.

Всего существует шесть нормальных форм, которые включают определенные требования. С каждым следующим уровнем требования все жестче, так как включают в себя предыдущие уровни.

В рамках курса мы разберем три нормальные формы. В этом уроке познакомимся с первой.

## Первая нормальная форма

Первая нормальная форма сводится к трем правилам:

-   Каждая ячейка таблицы может хранить только одно значение
-   Все данные в одной колонке могут быть только одного типа
-   Каждая запись в таблице должна однозначно отличаться от других записей

Разберем каждое правило подробнее.

### Каждая ячейка – одно значение

Вернемся к примеру выше. У одной записи поля _item_ и _price_ содержат два значения через запятую. У такого способа организации данных много недостатков. Например, пропадает возможность делать обычную выборку по условиям:

```
-- Как найти записи о всех проданных утюгах?
SELECT * from order_items WHERE item = "?"
```

Другая проблема связана с типами данных. Поле _price_ в таблице _order_items_ имеет числовой тип (numeric). Если мы захотим хранить там более одного значения, то тип превратится в строковый, а все данные станут обычными строками.

При такой организации невозможно проверить корректность данных и формат числа. Становится проблематично выполнить агрегирующие запросы, например, считать выручку за определенный месяц одним запросом.

Чтобы избавиться от перечислений в ячейках, можно создать новые записи:

|first_name |last_name| address| item| price|
|---|---|---|---|---|
|Сергей|Иванов|Москва, ул. Промышленная|утюг|15.00|
|Виктор|Сидоров|Омск, ул. Дворцовая|телевизор|1000.00|
|Виктор|Сидоров|Омск, ул. Дворцовая|утюг| 6500.00|
Теперь на одной строке находится информация только по одному товару. Так мы избавились от перечислений в поле, что позволит выполнять агрегирующие запросы, а также не будет путаницы с типами данных.

### Данные одного типа

Снова вернемся к таблице. Верхняя запись в ней содержит цену в долларах, хотя все остальные цены указаны в рублях. Технически база никак не укажет на это. И доллары, и рубли представлены числами, но с точки зрения программы у этих чисел разная природа.

Разные данные в рамках одного поля тоже не дают выполнить агрегирующие запросы, например, поиск сумм, максимального, минимального. Еще усложняется обработка данных на уровне кода. В коде придется каким-то образом понимать, что из себя представляют данные.

Вот еще несколько примеров с похожей ситуацией:

-   Хранение даты свадьбы в поле «день рождения»
-   Хранение номера телефона вместо адреса в поле «адрес»

Исправленная версия таблицы:

|first_name |last_name| address| item| price|
|---|---|---|---|---|
|Сергей|Иванов|Москва, ул. Промышленная|утюг|6500.00|
|Виктор|Сидоров|Омск, ул. Дворцовая|телевизор|1000.00|
|Виктор|Сидоров|Омск, ул. Дворцовая|утюг| 6500.00|

Мы сконвертировали цену утюга в первой строке из долларов в рубли. Теперь у данных в поле _price_ один тип. Так программе будет легче выполнять агрегирующие запросы.

### Уникальные записи

Последние две записи в таблице выглядят идентично, хотя это два разных заказа. Их сделал один человек, но в разное время:


Реляционная модель требует от нас уникальности каждой записи. Иначе нельзя понять, что к чему относится и с какой записью нужно работать при изменениях. Можно начать править не то и потерять важную информацию. При этом мы не можем полагаться на порядок данных внутри таблицы, так как он не гарантирован.

Реализовать уникальность можно несколькими способами, например, добавить новое поле с датой заказа, которое сделает запись уникальной. Этот способ не очень надежный и не очень удобный в работе. Придется постоянно анализировать весь набор полей.

Лучше добавить **первичный ключ** (_PRIMARY KEY_) — поле или набор полей, которые содержат уникальное значение для каждой записи. Первичный ключ не может меняться, его значение однозначно определяет любую запись в таблице.

Разберем два вида первичного ключа:

-   **Естественный** — когда используются значения из окружающего мира, например, email, ФИО или паспортные данные. При этом нужно убедиться, что ключ не будет повторяться. Такие первичные ключи используют редко из-за их ненадежности. Часто они не уникальны и могут изменяться или повторяться. Например, номер паспорта меняется при смене документа
-   **Суррогатный** — когда используются автоматически генерируемые уникальные значения. Такой ключ поддерживается любой базой данных «из коробки». Иногда это просто числа, а иногда — сложные число-буквенные строки или хеши

|primary key| first_name |last_name| address| item| price|
|---|---|---|---|---|---|
|8|Сергей|Иванов|Москва, ул. Промышленная|утюг|6500.00|
|3|Виктор|Сидоров|Омск, ул. Дворцовая|телевизор|1000.00|
|1|Виктор|Сидоров|Омск, ул. Дворцовая|утюг| 6500.00|

Первичный ключ принято создавать первым полем с названием _id_. Для первичного ключа обязательно указывать _PRIMARY KEY_ в описании таблицы:

```
-- Первичный ключ только один на таблицу
CREATE TABLE products (
    id bigint PRIMARY KEY,
    first_name varchar(255),
    last_name varchar(255),
    address varchar(255),
    item varchar(255),
    price numeric -- специальный тип данных, который подходит под работу с деньгами. Обеспечивает высокую точность при расчетах.
);
```

Такой ключ все еще нужно формировать самостоятельно, но теперь база данных сама следит за уникальностью. При попытке создать запись с повторяющимися первичными ключами возникнет ошибка.

# Вторая нормальная форма

Вторая нормальная форма включает в себя два требования:

-   Таблица должна быть в первой нормальной форме
-   Все неключевые атрибуты таблицы должны зависеть от первичного ключа

Первое требование уже выполнено, так как в таблице:

-   Каждая ячейка хранит только одно значение
-   Все данные в одной колонке одного типа
-   Каждая запись отличается от других записей


## Зависимость от первичного ключа

Зависимость атрибута от первичного ключа — это ситуация, при которой ключ имеет значение, зависимое от конкретного контекста. Предположим, что в таблице, Сергей — это всегда один и тот же человек, который делает заказ на разные адреса. В таком случае видно, что адрес привязан к конкретному заказу. Это и есть зависимость от первичного ключа. А вот имя пользователя и его фамилия с заказом никак не связано. Оно имеет отношение к самому пользователю.

Согласно второй форме, атрибуты _first_name_ и _last_name_ необходимо вынести в свою таблицу, которая будет отвечать за пользователей:

**users**

|id|. first_name| last_name|
|---|---|---|
|2| Сергей| Иванов|
|3 |Иван |Петров|
|5| Виктор| Сидоров|

В этой таблице всего три записи, потому что у нас три уникальных пользователя. Каждому из этих пользователей присваивается первичный ключ.

Теперь нужно связать таблицу _order_items_ с таблицей _users_. Делается это через указание первичных ключей в зависимых таблицах:

**order_items**

|id |user_id|address|item|price|
|---|---|---|---|---|
|8 |2| Москва, ул. Промышленная|утюг|1000.00


Мы удалили _first_name_, _last_name_ и добавили _user_id_. В этом поле хранятся идентификаторы пользователей, а само поле называется **внешним** или **вторичным**ключом.

Другой пример внешнего ключа в таблице покупателя и города можно схематично показать так:

![Внешний ключ](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjQwM2ViMDA4OTM2OTE4MmE3MWVkYmJmNGFiMTlhZjU4LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=fe82b57d78d22dab466f634f13c86c4e0bec8134950fbc306aef88af609ec5fc)

Внешний ключ — это не ссылка. Таблицы существуют сами по себе, и во внешнем ключе указывается конкретное значение, которое должно совпадать с первичным ключом другой таблицы.

Так выглядит синтаксис определения вторичного ключа:

`REFERENCES <название таблицы, на которую смотрим> (<список полей в той таблице, которым соответствуем>)`

```
-- Внешних ключей может быть любое количество: сколько ссылок — столько и ключей
CREATE TABLE orders (
    id bigint PRIMARY KEY,
    -- Тип внешнего ключа должен быть такой же,
    -- как у первичного в той таблице, куда ссылается внешний
    user_id bigint REFERENCES users (id),
    -- остальные поля
);
```

Благодаря вторичному ключу поддерживаются гарантии корректности данных. Например, невозможно удалить запись из основной таблицы, если на нее есть ссылки из внешних ключей в другой таблице. Так не получится случайно завести базу в **неконсистентное состояние** — когда данные ссылаются на несуществующие данные.

## Третья нормальная форма

Третья нормальная форма включает в себя два пункта:

-   Таблица должна быть во второй нормальной форме
-   Все колонки в таблице зависят от первичного ключа и не зависят друг от друга

Первое требование уже выполнено, так как:

-   Таблица соблюдает требования первой нормальной формы
-   Все неключевые атрибуты таблицы зависят от первичного ключа

Поэтому разберем подробнее второе требование.

## Зависимость колонок от первичного ключа, но не друг от друга

Стоимость заказа зависит от цены товара. При этом цена товара зависит от самого товара, то есть от _good_id_. Чтобы привести таблицу к третьей форме, нужно вынести цену в товар:

**goods**

|id|name|price|
|---|---|---|
|50|утюг|1000.00|
|30|кофеварка|5000.00|
|20|телевизор|6500.00|
|33|ноутбук|20000.00|

Наша таблица приобретает такой вид:

**order_items**

|id|user_id|address|good_id|
|---|---|---|---|
|8|2|Москва, ул. Промышленная|50|
|2|3|Самара, ул. Энгельса|30|
|7|5|Омск, ул. Дворцовая|50|
|4|5|Омск, ул. Дворцовая|20|


С одной стороны, мы выполнили большую часть необходимой нормализации, с другой — новая структура имеет большой недостаток. Цена товара — вещь изменяемая, а вот стоимость покупки, которую мы совершили в прошлом – нет. Когда изменяется цена товара, изменится стоимость всех совершенных покупок, в которые входил данный товар. С точки зрения бухгалтерии и истории покупок это недопустимо.

Это значит, что цена товара должна копироваться в таблицу _order_items_. Но и в таблице _goods_ она тоже нужна. В первую очередь для вывода на сайте на витрине.

Адрес тоже зависит от пользователя, но более сложным образом. У одного пользователя может быть несколько адресов. Если учитывать все, что мы говорили про нормальные формы, перенести адреса в таблицу пользователей нельзя. Мы не можем хранить несколько значений в одной колонке и не можем дублировать записи, так как нарушится уникальность первичного ключа.

Правильное решение – завести под адреса собственную таблицу. В ней адрес будет связан с пользователем, а вместо поля _address_ в таблице заказов появится поле _user_address_id_.

```sql 
Соствление трех взаимосывязанных таблиц 

CREATE TABLE countries (
    id bigint PRIMARY KEY,
    name varchar(255)
);

CREATE TABLE country_regions (
    id bigint PRIMARY KEY,
    country_id bigint REFERENCES countries(id),
    name varchar(255)
);

CREATE TABLE country_region_cities (
    id bigint PRIMARY KEY,
    country_region_id bigint REFERENCES country_regions(id),
    name varchar(255)
);

INSERT INTO countries VALUES (1, 'Россия');
INSERT INTO country_regions VALUES (1, 1, 'Татарстан');
INSERT INTO country_regions VALUES (2, 1, 'Самарская область');
INSERT INTO country_region_cities VALUES (1, 1, 'Бугульма');
INSERT INTO country_region_cities VALUES (2, 1, 'Казань');
INSERT INTO country_region_cities VALUES (3, 2, 'Тольятти');
```

## Автогенерация первичного ключа

Первичный ключ в базах данных принято заполнять автоматически, используя встроенные в базу данных возможности. Такой подход лучше ручного заполнения по двум причинам. Во-первых, это просто реализовать. Во-вторых, база данных сама следит за уникальностью во время генерации.

Автогенерация работает по следующим принципам:

-   Внутри базы создается отдельный счетчик, который привязывается к каждой таблице
-   Счетчик увеличивается на единицу при вставке новой строки
-   Получившееся значение записывается в поле, которое помечается как автогенерируемое

Автогенерацию первичного ключа часто называют автоинкрементом (autoincrement). Что переводится как _автоматическое увеличение_ и напоминает операцию инкремента из программирования _++_.

До определенного момента механизм автоинкремента был реализован по-своему в каждой СУБД разными способами. Это создавало проблемы при переходе от одной СУБД к другой и усложняло реализацию программного слоя доступа к базе данных.

Эта функциональность добавлена в стандарт SQL:2003, то есть очень давно. И только в 2018 году PostgreSQL в версии 10 стал его поддерживать. Такой автоинкремент известен под именем **GENERATED AS IDENTITY**:

```
CREATE TABLE colors (
  -- Одновременное использование и первичного ключа и автогенерации
  id bigint PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
  name varchar(255)
);

INSERT INTO colors (name) VALUES ('Red'), ('Blue');

SELECT * FROM colors;
```


Если удалить запись с `id` равным двум и вставить еще одну запись, то значением поля `id`будет `3`. Автогенерация не связана с данными в таблице. Это отдельный счетчик, который всегда увеличивается. Так избегаются вероятные коллизии и ошибки, когда один и тот же идентификатор принадлежит сначала одной записи, а потом другой.

Вот его структура из документации:

```
column_name type GENERATED { ALWAYS | BY DEFAULT } AS IDENTITY[ ( sequence_option ) ]
```

-   Тип данных может быть _SMALLINT_, _INT_ или _BIGINT_
    
-   `GENERATED ALWAYS` — не позволит добавлять значение самостоятельно, используя `UPDATE`или `INSERT`
    
-   `GENERATED BY DEFAULT` — в отличие от предыдущего варианта, этот вариант позволяет добавлять значения самостоятельно
PostgreSQL позволяет иметь более одного автогенерируемого поля на таблицу.

## Что такое онтология

Рассмотрим Хекслет, так как вы с ним знакомы. Чтобы понимать предметную область Хекслета, нужно выделить ключевые понятия — **сущности**, вокруг которых строится вся логика. У обучающих ресурсов это, как правило, «курс» и «урок». Но на самом деле сущностей гораздо больше.

В случае Хекслета еще можно выделить «профессию», «испытание», «code review», «квиз», «участника курса», «проект». Этот список можно продолжать еще долго. Но сущности не существуют сами по себе, а находятся во взаимоотношениях друг с другом.

Например, квиз содержит или агрегирует в себе вопросы, в которых есть ответы. Профессия состоит из курсов, а курсы из уроков, уроки — из теории, квиза и практики. Эти связи имеют конкретные названия:

-   **Один ко многим**, **one-to-many** или **o2m**. Например, когда один урок может находиться только в одном курсе, но курс содержит множество уроков
    
-   **Один к одному**, **one-to-one** или **o2o**. Например, на Хекслете такая связь установлена между пользователем и аккаунтом на Facebook
    
-   **Многие ко многим**, **many-to-many** или **m2m**. Например, когда один курс могут проходить много пользователей, и один пользователь может проходить много курсов
    

Так это выглядит на схеме:

![ERD](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjY2ODg1YmFmM2I2YjA3ZjI3N2M5YzM3YjdlMTM5Nzg2LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=dd9d901bd476229f12f624d257699595640ece1ca2a88ac013436efa7679ce6a)

Описание объектов рассматриваемой области и связей между ними называется **онтологией** предметной области. Эту онтологию хорошо знают эксперты соответствующей области: в бухгалтерии — бухгалтер, в обучении — преподаватель. Но, в отличие от программистов, они часто представляют ее на интуитивном уровне, неформально.

На практике программисты, бизнес-аналитики или менеджеры общаются с заказчиками, которые могут сами выступать в роли экспертов, и строят вместе с ними формальную онтологию. То есть выделяют конкретные термины, договариваются, что они означают и как связаны друг с другом.

Затем с помощью [ER-модели](https://ru.wikipedia.org/wiki/ER-%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C) программист формирует необходимую модель данных. Необязательно на бумаге или в специализированных программах. Чаще такая модель существует только в голове и коде.

Эта модель и становится основной для проектирования базы данных. Каждая сущность в реляционной базе данных представлена таблицей, а связи между сущностями реализуются через внешние ключи.

Чтобы визуализировать ER-модель, используют диаграмму Entity-Relationship Diagram (ERD). Познакомимся с ней.

## Что такое ERD

У ER-модели нет графического представления, поэтому используют ERD. Многие понимают под ER-моделью и ERD одно и то же. Хотя ER-модель можно представить и с помощью других нотаций.

В ERD каждая сущность представлена блоком, в котором перечисляются поля. Между блоками рисуются линии, у которой есть некоторые заранее определенные концы. Они определяют тип связи между сущностями:

![ERD Нотация](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjA4MTJiNjlhNGU1NDlmYjllNzNiMjIyN2M5Yzk4MWY5LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=688c8e8ffc4898b920d9b82d2a01efc585dc1aded2cdcfd6c3c985a042fb6f6d)

Рассмотрим подробнее каждый вид связи.

### Один ко многим (one-to-many)

Один ко многим — наиболее распространенный вид связи. Например, один лектор может вести несколько курсов:

![Один ко Многим](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjcwNDcwMmIwYTI1ZTVlN2UyMWI5NDM4YTYxMGY2OGQ0LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=c1d432a160f66c861495796fc1ed1f482cd84149e7112911e69fc2be970c8e71)

Технически, такая связь организуется через внешний ключ, который добавляется в зависимую сущность — many.


### Один к одному (one-to-one)

На схеме такая связь выглядит так:

![Один к Одному](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImVkMDk5ODhlYzBjZTRmMDA1YjU0MTc2ZmQ5OWM0NjM2LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=85a8ad95e634993d797fe9fec5e449704112ca0d163522365e8e44ef244ddae5)

Связь one-to-one обычно существует не сама по себе, а внутри связи one-to-many. То есть у каждой страны есть города, но только один из них столица.

### Многие ко многим (many-to-many)

Такие связи можно отобразить так:

![Многие ко многим](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6Ijc1OWU2Y2JlMmE5ZDhjMTBlMGUzYzZmZGQ2MzAzMWZmLmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=4c27ef20b67373749ef2625298410d09d051d22e373035df182a34887b6a5b0e)

Многие ко многим встречается очень часто. Например, у каждого человека множество друзей, каждый человек друг для множества других. Или один человек проходит множество курсов, один курс проходится множеством людей.

Эта связь реализуется уже не так просто. Технически невозможно связать две таблицы связью many-to-many без введения третьей таблицы.

В таблице `course_members` есть свой первичный ключ, и каждая запись содержит ссылки как на конкретный курс, так и на конкретного пользователя. На Хекслете эта таблица начинает заполняться в тот момент, когда пользователь нажимает кнопку «Вступить в курс». Для юзера создается запись с его идентификатором и идентификатором курса, который он собрался проходить.


Такая структура соблюдается для любых двух сущностей, которые надо связать. В общем виде схема выглядит так:

Есть исходные таблицы _A_ и _B_. Для них создается новая таблица _AB_. Внутри нее есть два внешних ключа — _a_id_ и _b_id_, которые связаны с исходными таблицами.

Как показывает практика, такая промежуточная таблица часто становится самостоятельной сущностью. Если брать курсы, то важно понимать, закончил ли пользователь курс или нет, когда конкретно он это сделал, сколько заданий решил. Вся эта информация может храниться только в одном месте — в связанной таблице.


# Ограничения—Основы реляционных баз данных

Первичные и внешние ключи в базах данных относятся к ограничению. Оно включает в себя различные модификаторы колонок в базе данных, которые добавляют ограничения на их содержимое. В этом уроке мы рассмотрим уже известные ограничения, а также изучим новые.

## Первичный ключ

**Первичный ключ** однозначно идентифицирует каждую запись внутри таблицы. Задается с помощью фразы `PRIMARY KEY`, которая добавляется после указания типа, когда создается таблица. Первичный ключ в таблице может быть только один, и для него используется суррогатный ключ — идентификатор, у которого нет физического смысла:

```
CREATE TABLE products (
    id bigint PRIMARY KEY,
    name text,
    price numeric
);
```

## Внешний ключ

**Внешний ключ** — это ограничение, которое связывает указанную колонку с данными из другой таблицы. Такое ограничение гарантирует целостность данных. То есть попытка удалить данные, у которых есть зависимые данные, приведет к ошибке:

```
CREATE TABLE orders (
    id bigint PRIMARY KEY,
    product_id bigint REFERENCES products (id),
    quantity integer
);
```

В данной таблице атрибут `product_id` связан с атрибутом `id` таблицы `products`. Синтаксически для этого добавляется ключевое слово _REFERENCES_ после типа поля. Затем добавляется имя таблицы, на которую идет связь. В скобках указывается поле, с которым эта связь создается. Наличие такой связи проявляется следующим образом:

-   Если попробовать вставить в `orders` запись со значением `product_id`, которого нет в таблице `products`, то возникнет ошибка
-   Если попытаться удалить запись из `products`, на которую есть ссылки из таблицы `orders`, то возникнет ошибка

Внешний ключ проверяет целостность данных и не позволяет появляться «мусору». Поэтому лучше ставить внешние ключи на все идентификаторы, для которых есть родительская таблица в базе.

Внешние ключи поддерживают несколько вариаций. Таким образом они поддерживают целостность, но не приводят к ошибкам при попытке удалить запись.

**Вариант 1** — Каскадное удаление:

```
CREATE TABLE orders (
    product_id bigint REFERENCES products (id) ON DELETE CASCADE,
);
```

В таком варианте при попытке удалить родительскую запись (_products_), будут удалены все записи в _orders_, которые ссылаются на этот продукт. Каскадное удаление опасная опция, так как можно случайно лишиться данных. Стоит хорошо подумать, прежде чем включать ее.

**Вариант 2** — Записи остаются, но вместо идентификатора проставляется `null`:

```
CREATE TABLE orders (
    product_id bigint REFERENCES products (id) ON DELETE SET NULL
);
```

Используется нечасто, но иногда может быть полезно.

## Not Null

**Not Null** — это ограничение указывает на то, что колонка не может содержать `null`значения. Его можно комбинировать с другими ограничениями, например, внешними ключами. Первичный ключ является `NOT NULL` по умолчанию:

```
CREATE TABLE products (
    id bigint PRIMARY KEY,
    name text NOT NULL,
    price numeric
);
```

```
CREATE TABLE orders (
    id bigint PRIMARY KEY,
    product_id bigint REFERENCES products (id) NOT NULL,
    quantity integer
);
```

## Уникальность

![Ограничение уникальности](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjUwMTNjY2M2YjliMjZjY2JlNmEyM2E4OTc0YjgwZThjLmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=10a742251d81c5d17f68ee81880082aff9232566a409bb3e240d08cdfbe4be52)

Чтобы гарантировать уникальность значений одного поля, используется ключевое слово `UNIQUE`. Обычно его используют в описании конкретного поля, когда создается таблица:

```
CREATE TABLE products (
    id bigint PRIMARY KEY,
    name text UNIQUE,
    price numeric
);
```

`UNIQUE` никогда не используется совместно с первичным ключом, так как он уникален по определению.

Иногда бывает нужно реализовать уникальность по двум или более атрибутам. Для этого нужно описать `UNIQUE` отдельно от конкретного поля:

```
CREATE TABLE products (
    id bigint PRIMARY KEY,
    name text,
    locale varchar,
    price numeric,
    UNIQUE(name, locale)
);
```

Существует ситуация, в которой ограничение уникальности не срабатывает. Такое происходит, если хотя бы в одном из столбцов, включенных в ограничение, встречается `NULL`. По стандарту, `NULL` никогда не равен самому себе.

# Изменение структуры таблицы (ALTER)

Наиболее сложный запрос при работе с таблицами — обновление ее структуры. Если посмотреть официальную документацию, то общая запись этого запроса занимает больше трех экранов монитора. Но ни один человек не помнит всех возможностей этой команды. Более того, большинство из них редко выполняются. Единственное, что нужно знать — возможности этой команды — общие принципы ее работы. А детали всегда можно будет найти в документации.

В этом уроке разберем такой тип запроса, как `ALTER TABLE`. Он отвечает за изменение таблицы базы данных. Также узнаем, какие четыре операции со столбцами он включает в себя.

## Запрос ALTER TABLE

Запрос `ALTER TABLE` используют, чтобы изменять структуру столбца таблицы базы данных. Он включает четыре операции:

-   Добавление колонки
-   Переименование колонки
-   Удаление колонки
-   Обновление колонки

Разберем каждую операцию подробнее.

### Добавление колонки

С помощью `ALTER` можно добавить колонку в уже имеющуюся таблицу:

![Добавление поля в таблицу](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImQzM2Y3MzkwNTFlNmMxODllMjgxNzg0ZWRjYWYxYmIzLmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=b3ac01a3a7fd681066be2202aa63d7e03438360f7c814dc4639f93c6cfbc362e)

В этом примере мы добавили колонку _age_.

Делается это таким образом:

```
-- в таблице "users"
-- добавить колонку с именем "age" и типом "int"
ALTER TABLE users ADD COLUMN age int;
```

Здесь после фразы `ADD COLUMN` идет строка описания новой колонки, точно такая же, как и при создании таблицы. В простом варианте она выглядит так: `<имя колонки> <тип>`. Здесь можно указывать любые ограничения, добавлять ключи, автогенерацию, значение по умолчанию и многое другое. Синтаксис на 100% совпадает с синтаксисом определения колонки, когда таблица создается.

### Переименование колонки

Чтобы переименовать колонку, нужно сделать следующий запрос:

```
-- в таблице "courses"
-- изменить колонку "example1":
-- поменять имя с "example1" на "example2"
ALTER TABLE courses RENAME COLUMN example1 TO example2;
```

Здесь нет никаких сложностей — одно имя меняется на другое.

### Удаление колонки

Следующий запрос удаляет колонку:

```
-- в таблице "courses"
-- удалить колонку с именем "example2"
ALTER TABLE courses DROP COLUMN example2;
```

Это тоже простая операция, которая убирает ненужную колонку.

### Обновление колонки

Команда по изменению параметров колонки наиболее сложная. Практически у каждого элемента, который поддается обновлению, есть собственный синтаксис для этого обновления. Вот несколько базовых примеров:

```
ALTER TABLE addresses
    ADD PRIMARY KEY (id);

ALTER TABLE addresses
    ALTER COLUMN created_at SET DATA TYPE timestamp,
    ALTER COLUMN street DROP NOT NULL;

-- Добавление ограничения NOT NULL в таблицу addresses для колонки city
ALTER TABLE addresses
    ALTER COLUMN city SET NOT NULL;

-- Добавление уникального индекса в таблицу "products" для колонки "product_id"
ALTER TABLE products ADD UNIQUE (product_id);
```

Наиболее распространенные команды:

-   `ADD` — добавление ограничения: например, ключа или уникальности
-   `SET` — установка значения: например, типа данных
-   `DROP` — удаление ограничения

В рамках одного обновления можно группировать операции, но существует ряд исключений. Например, группировке не поддается операция `RENAME` — ее нужно выполнять отдельным запросом, иначе СУБД завершит запрос с ошибкой.

# Сортировка (ORDER)


У выборки данных из базы нет определенного порядка. Точнее порядок есть, но он логически не обоснован. По умолчанию база возвращает данные в том порядке, в котором ей удобнее. По счастливому стечению обстоятельств этот порядок может совпасть с желаемым, но рассчитывать на это нельзя.

Теоретически порядок может поменяться при следующем запросе, или когда количество данных в таблице изменится. Обновление версии базы данных тоже может повлиять на это.

В этом уроке мы разберем, как сортировать данные в базе в том порядке, который нам нужен. Для этого используется запрос `ORDER BY`.

## Общая схема запроса на сортировку

Допустим, нам нужно сортировать данные в базе:

![Сортировка данных в таблице](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjAyM2JlNmNlMDkxNWU1Y2Y2OGI2MDRiYmRiZWYyMTQ4LmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=2a54953f4f015fecb70a363c5761ad8669c29517ee1dcf0e38a4f95c952f3bfd)

Сортировка задается с помощью части `ORDER BY`, за которой следует имя поля — по нему происходит сортировка:

```
SELECT * FROM users ORDER BY username;
```

Такой запрос вернет всю информацию о пользователях, отсортированную по `username`. Если порядок не указан, то сортировка происходит по возрастанию `ASC`.

Сортировка подразумевает сравнение значений между собой. По какому принципу база данных сортирует строки `username` как в примере выше? Самый распространенный способ — лексикографический порядок, то есть по алфавиту.

База данных знает, как сравнивать не только числа, но и строки, и даты. Сортировка по датам — крайне частая операция, выглядит она идентично любой другой сортировке:

```
SELECT * FROM users ORDER BY created_at;
```

Здесь мы отсортировали пользователей по дате создания в прямом порядке, то есть по возрастанию.

## Управление порядком сортировки

Сортировать данные можно разными способами:

-   В прямом порядке
-   В обратном порядке
-   По нескольким полям

### Прямой порядок сортировки

Если ничего дополнительно не указывать, то `ORDER BY` сортирует в **прямом порядке** — от меньшего к большему. Запрос выше — это сокращенная версия полного запроса с сортировкой. Полный запрос включает в себя `ASC`, который подставляется автоматически, если ничего не указано:

```
SELECT * FROM users ORDER BY created_at ASC;
-- То же самое, что и SELECT * FROM users ORDER BY created_at;
```

### Обратный порядок сортировки

Чтобы выполнить сортировку в обратном порядке, указывается `DESC`:

```
SELECT * FROM users ORDER BY created_at DESC;
```

### Сортировка по нескольким полям

Иногда нужно сортировать данные сразу по нескольким полям. Этого можно достичь, если перечислить поля через запятую:

```
SELECT * FROM users ORDER BY first_name, created_at;
```

Порядок сортировки в таком случае задается для каждого поля индивидуально:

```
SELECT * FROM users ORDER BY first_name DESC, created_at DESC;
SELECT first_name, created_at FROM users ORDER BY first_name ASC, created_at DESC;
```


В этой выборке сначала выполняется сортировка по имени в прямом порядке. Затем внутри групп с одинаковым именем данные сортируются по _created_at_ в обратном порядке.

Еще у сортировки есть один тонкий момент, который связан полями `NULL`.

## Сортировка NULL-значений

Если поле содержит `NULL`, и ничего не указано дополнительно, то считается, что `NULL`больше любого значения. Получается, что при прямой сортировке они окажутся в конце выборки, а при обратной — в начале. Этим поведением можно управлять с помощью фразы `NULLS FIRST`:

```
-- сортируем по возрастанию даты (поле "created_at")
-- поведение по умолчанию:
-- поля, которые содержат NULL, идут последними
SELECT * FROM users ORDER BY created_at ASC;

-- сортируем по возрастанию даты (поле "created_at")
-- поля, которые содержат NULL, идут первыми
SELECT * FROM users ORDER BY created_at ASC NULLS FIRST;
```

и `NULLS LAST`:

```
-- сортируем по убыванию даты (поле "created_at")
-- поведение по умолчанию:
-- поля, которые содержат NULL, идут первыми
SELECT * FROM users ORDER BY created_at DESC;

-- сортируем по убыванию даты (поле "created_at")
-- поля, которые содержат NULL, идут последними
SELECT * FROM users ORDER BY created_at DESC NULLS LAST;
```

# Условия (WHERE)


Обычно данных в базе много, и мы хотим работать только с их частью, а не всеми данными сразу. Например, нам нужно посмотреть данные только тех пользователей, которые зарегистрировались вчера. Для выборки части данных из базы используются условия. В этом уроке мы научимся строить подобные условия при выполнении запросов в базу данных с помощью `WHERE`.

## WHERE

Самое простое условие — указать прямое соответствие. Например, выборка по идентификатору:

```
-- В случае базы данных знак `=` должен восприниматься
-- как математическое равенство, а не присваивание.
SELECT * FROM users WHERE id = 3;

UPDATE users SET first_name = 'Valya' WHERE id = 3;

DELETE FROM users WHERE id = 3;
```

Первый запрос выше звучит так: выбрать всех пользователей, у которых идентификатор равен трем. Такая формулировка звучит странно, так как если мы выбираем по идентификатору, то и запись должна быть одна. С точки зрения семантики идентификатора она будет одна, но в реляционной базе данных результатом любой операции над множеством является множество.

В том случае, если ничего не найдено, возвращается не пустота, а пустое множество. Если же в базе есть пользователь с указанным идентификатором, то вернется множество, которое содержит один элемент — найденного пользователя.

Если нужно получить все записи, кроме тех, у которых есть определенное значение, то нужно `=`, заменить на `!=`:

```
-- выбрать всех пользователей с идентификатором, НЕ равным трем
SELECT * FROM users WHERE id != 3;
```

Сравнение с конкретным значением работает для всех типов данных, кроме `NULL`. Разберем эту ситуацию подробнее.

## Проверка на равенство с NULL

У данных типа `NULL` свой синтаксис:

Равно `NULL`:

```
SELECT * FROM users WHERE first_name IS NULL;
```

Не равно `NULL`:

```
SELECT * FROM users WHERE created_at IS NOT NULL;
```

`NOT`, как и отрицание в языках программирования, может добавляться практически к любому оператору.

## Равенство строк

У строк тоже свои особенности. В соответствии со стандартом ANSI SQL, строки в PostgreSQL **регистрозависимые** — результат зависит от регистра, в котором записан текст. Например, следующие два запроса выбирают разные данные:

```
SELECT * FROM users WHERE first_name = 'sunny';
SELECT * FROM users WHERE first_name = 'Sunny';
```

По этой причине данные в базе стараются хранить в **нормализованном** виде — перед добавлением в БД их приводят, например, к нижнему регистру, и то же самое делают при выборках. Классический пример — email. Его нужно хранить только в нижнем регистре.

## Другие операции сравнения

Кроме точного соответствия SQL поддерживает и все остальные операции сравнения:

-   `>` — больше
-   `<` — меньше
-   `!=` — не равно
-   `>=` — больше либо равно, не меньше
-   `<=` — меньше либо равно, не больше

![Работа WHERE](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImI2YmY3NTA5ZDRjODNjMGRkNDBiZWM2MTRhZDlmNjQxLmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=9d878698d06346841c1afc565870d256daece118b1313aa89b2bf3b1cd09fed0)

Например, так может выглядеть запрос на сравнение:

```
SELECT *
  FROM users
  WHERE created_at < '2018-10-05';
```

Здесь мы выбираем всех пользователей, созданных до _2018-10-05_.

## Логические операторы

Все операции можно объединять в цепочки, если использовать логические операторы `OR` и `AND`:

```
SELECT *
  FROM users
  WHERE created_at > '2018-01-01' AND created_at < '2018-10-05';
```

Здесь мы выбираем пользователей, которые зарегистрировались между _2018-01-01_ и _2018-10-05_.

Как и в случае с языками программирования, здесь действуют те же приоритеты. Чтобы не создавать неоднозначностей, в сложных ситуациях используются круглые скобки:

```
SELECT *
  FROM users
  WHERE first_name = 'Sunny' OR (created_at > '2018-01-01' AND created_at < '2018-10-05');
```

## BETWEEN

Для условий с проверкой диапазона SQL поддерживает особый формат `BETWEEN`. По сути, это сокращенная версия для двух условий соединенных через `AND`:

```
SELECT *
  FROM users
  WHERE created_at BETWEEN '2018-01-01' AND '2018-10-05';
  -- WHERE created_at >= '2018-01-01' AND created_at <= '2018-10-05';
```

Здесь мы выбираем пользователей, которые зарегистрировались между _2018-01-01_ и _2018-10-05_, включая эти даты. `BETWEEN` всегда учитывает границы диапазона.

## IN

В некоторых ситуациях требуется найти не диапазон строк, а строки, в которых поле соответствует одному значению из набора. Предположим, что мы хотим выполнить один запрос и найти пользователей с идентификаторами 1, 2 или 5. Для этого используют `OR`:

```
SELECT * FROM users WHERE id = 1 OR id = 2 OR id = 5;
```

Если понадобится найти десяток совпадений, можно использовать другое решение — `IN`:

```
SELECT * FROM users WHERE id IN (1, 2, 5);
```

Если нужно исключить определенные записи, достаточно добавить `NOT`:

```
SELECT * FROM users WHERE id NOT IN (1, 2, 5);
```

## LIKE

Иногда нужно искать по частичному совпадению: например, проверить, что строка начинается или заканчивается с определенной последовательности символов. Допустим, мы хотим посмотреть пользователей, имя которых начинается с буквы `A`:

```
SELECT * FROM users WHERE first_name LIKE 'A%';
```

`%` — специальный заполнитель, который означает «все что угодно». Если его поставить в конце, то поиск выполняется по совпадению в начале фразы, если в начале — то по совпадению с концом, а если по краям — то проверяется совпадение внутри текста. Совпадение в конце может понадобиться, чтобы анализировать пользователей, которые регистрировались с определенного почтового домена:

```
SELECT * FROM users WHERE email LIKE '%hotmail.com';
```

Здесь мы выбираем всех пользователей, электронная почта которых заканчивается на _hotmail.com_.

**Обратите внимание на то, что этот поиск регистрозависимый. Если вы хотите искать без учета регистра, то используйте __`ILIKE`__.


# Лимит (LIMIT)

Типичные таблицы в веб-проектах содержат огромное число данных, поэтому их никогда не показывают на страницах сразу все. Обычно выводится лишь небольшая часть, например, 50 строк. Чтобы ограничить выборку, используется `LIMIT`. В этом уроке разберем, как работать с таким запросом.

![LIMIT](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjQyNDRkYzQ1YTUzMjg5MjQzMDM1MDM1Y2EzNGFkZjQ4LmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=03e032c5fcbf38211397d7e560fbed1cf25b72e6074079df0de87f020cd4af31)

## Как ограничивать выборку таблицы

Представим, что нам нужно извлечь 10 записей. Для этого выполним такой запрос:

```
SELECT * FROM users LIMIT 10;
```

Из-за неопределенности порядка сортировки по умолчанию неизвестно, какие это будут записи. Для гарантии обязательно определять сортировку. `LIMIT` без сортировки практически никогда не используется. Поэтому нужно задать ее:

```
SELECT * FROM users ORDER BY id LIMIT 10;
```

## Как показать все данные по выборкам

Допустим, пользователь хочет посмотреть следующие 10. Это реализуется через **пагинацию** — механизм, который позволяет перемещаться по страницам. Чтобы реализовать его, одного `LIMIT` недостаточно. Еще понадобится смещение `OFFSET`:

```
SELECT * FROM users ORDER BY id LIMIT 10 OFFSET 10;
```

Этот запрос отсортирует пользователей, пропустит первые 10 за счет части `OFFSET 10` и возьмет 10 записей. Если менять `OFFSET`, можно обойти все данные в таблице:

```
-- выбрать записи с 21 по 30
SELECT * FROM users ORDER BY id LIMIT 10 OFFSET 20;

-- выбрать записи с 31 по 40
SELECT * FROM users ORDER BY id LIMIT 10 OFFSET 30;
```

# DISTINCT

Чтобы узнать все имена, которые есть у наших пользователей, нужно выполнить запрос не всех полей, а только имени:

```
-- Получить список имен всех пользователей
SELECT first_name FROM users;
```

Проблема в том, что эти имена наверняка дублируются, так как у людей могут быть одинаковые имена. Избавиться от дублей можно с помощью `DISTINCT`. В этом уроке узнаем, как находить уникальные записи.

## Находим уникальные записи

Чтобы имена из примера выше не дублировались, сделаем такой запрос:

```
SELECT DISTINCT first_name FROM users;

 first_name
------------
 Delphine
 Hanna
 Maxwell
 Russell
 Mia
```

Все повторяющиеся строки исключаются из результирующего набора. Так из каждой группы дубликатов остается одна строка.

`DISTINCT` позволяет указывать не одно, а сразу несколько полей:

```
-- DISTINCT добавляется в запрос только один раз, независимо от того, сколько колонок перечисляется
SELECT DISTINCT first_name, last_name FROM users;

 first_name |   last_name
------------+---------------
 Rhiannon   | Tremblay
 Vesta      | Kassulke
 Ena        | Gorczany
 Florencio  | Collier
 Garrett    | Koss
```

В эту выборку попадут все значения с уникальным сочетанием имен и фамилий. Это значит, что имена и фамилии могут повторяться, но пара всегда уникальна. Если в `DISTINCT`добавить первичный ключ (`SELECT DISTINCT id, first_name FROM users`), то запрос извлечет все записи. Такой результат является следствием уникальности первичного ключа.

`DISTINCT` можно совмещать с агрегатными функциями. С ними будем разбираться в отдельном уроке. Например, можно посчитать количество пользователей с уникальными именами:

```
SELECT COUNT(DISTINCT first_name) FROM users;
```

Такой запрос покажет количество уникальных имен.

## DISTINCT ON

В отличие от базовой формы, `DISTINCT ON` позволяет отдельно указывать два типа полей — для проверки уникальности и для результирующей выборки:

```
-- Все записи, уникальные по user_id
SELECT DISTINCT ON (user_id) * FROM topics;

 id | user_id |              title              | body                  |       created_at
----|---------|---------------------------------|-----------------------|------------------------
  2 |       2 | molestiae voluptas velit        | Quod quasi molestiae. | 2019-06-02 23:42:30.688

-- Все title для уникальных user_id
SELECT DISTINCT ON (user_id) title FROM topics;

             title
-------------------------
 molestiae voluptas velit

SELECT DISTINCT user_id, title FROM topics;
-- Такой запрос вернет совершенно другие данные — все уникальные пары user_id-title
-- То есть здесь возможно повторение user_id в результирующей выборке

SELECT DISTINCT ON (user_id, title) user_id, title FROM topics;
-- Этот запрос равносилен тому, что был выше
```

При работе с `DISTINCT ON` важно правильно использовать сортировку:

```
SELECT DISTINCT ON (user_id) id, user_id, title, created_at
  FROM topics
  ORDER BY user_id, created_at;

 id | user_id |            title             |       created_at
----+---------+------------------------------+-------------------------
 48 |       1 | qui non velit                | 2018-12-05 21:49:52.631
  7 |       4 | delectus in nihil            | 2018-12-06 00:46:32.712
 26 |       6 | rerum rerum recusandae       | 2018-12-05 18:39:47.937
 34 |       7 | soluta non voluptas          | 2018-12-06 07:55:00.095
```

Такой запрос вернет первый созданный топик для каждого пользователя. Запросы с `DISTINCT ON` требуют, чтобы первыми полями в `ORDER BY` были те, которые идут после `ON`. Только тогда сортировка отработает так, как ожидается. В запросе выше это `user_id` — указан в сортировке первым. В противном случае результат будет неверным.

В таких запросах сначала выполняется сортировка и уже после этого отрабатывает `DISTINCT`, так как он берет первую запись из группы. Но мы ведь не знаем какая запись первая. Нужно гарантировать порядок, в чем помогает `ORDER BY`.

# Встроенные Функции

При реализации пагинации обычно показывают общее число страниц. Но чтобы его узнать, нужно посчитать число строк в конкретной таблице. С помощью обычной выборки это сделать не получится, а вот функции под эту задачу как раз подходят.

Функции, которые что-то считают по таблице, называются **агрегатными**. Например, к ним относятся функции, связанные с нахождением числа записей, суммы значений, среднего арифметического и многих других параметров. В этом уроке мы рассмотрим только самые популярные функции, а с полным списком вы можете ознакомиться в документации.

## COUNT

`COUNT()` — функция, которая считает количество записей в выборке. Обратите внимание, что она считает именно в выборке, а не в таблице:

```
SELECT COUNT(*) FROM users WHERE birthday < '2018-10-21';

 count
-------
    91
(1 row)
```

Такой запрос вернет ровно одну запись с одним значением — количеством строк по указанному условию.

`COUNT()` относится к агрегатным функциям. У нее есть несколько форм, в которых она может:

-   Считать количество строк, если аргументом функции является `*`
-   Считать количество строк, в которых поле НЕ равно `NULL`, если в нее передать имя конкретного поля

## MAX и MIN

Функции `MAX` и `MIN` помогают находить максимальное и минимальное значение соответственно:

```
SELECT MAX(birthday) FROM users WHERE gender = 'male';

    max
------------
 2018-12-06
 (1 row)

SELECT MIN(birthday) FROM users WHERE gender = 'female';

    min
------------
 2017-12-08
 (1 row)
```

## Sum

Функция `SUM` находит сумму всех значений:

```
-- Получить сумму всех заказов из таблицы orders,
-- которые были совершены в 2016 году
SELECT SUM(amount) FROM orders
  WHERE created_at BETWEEN '2016-01-01' AND '2016-12-31';
```

## AVG

Функция `AVG` находит среднее арифметическое всех значений:

```
-- Получить среднюю стоимость всех заказов из таблицы orders,
-- которые были совершены в 2016 году.
SELECT AVG(amount) FROM orders
  WHERE created_at BETWEEN '2016-01-01' AND '2016-12-31';
```

В таблице ниже вы увидите, как это происходит:

![Работа AVG](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImY0NzIwOTU5OGQ0OWNhNDljZDQ1NzA2N2NkN2NmMGRkLmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=e3b1045564fce2cb8b3fac97834b1eddadbeed1762812fa81379b8b5f79e7550)

# Группировка (GROUP)


![Группировка данных](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6ImNiNzJlZjk5ZWRkMTA0NjkxZDQ5Y2I1NDViODcyNTc1LmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=f6ade99180c9f10c29403930cc9577c3e176a03c53e4b02ebe7a74a39abf163d)

С агрегатными функциями связано множество разных задач. Например, они помогают вывести общее число топиков для каждого пользователя. Так это может выглядеть:

```
SELECT COUNT(*) FROM topics WHERE user_id = 3;
SELECT COUNT(*) FROM topics WHERE user_id = 4;
-- ...
```

При этом здесь мы сталкиваемся с одной сложностью — невозможно выполнить данную задачу за один запрос, используя только функции. Нам придется делать выборку для каждой категории индивидуально, а это долго и неудобно. Если пользователей тысячи, то такое решение вопроса неприемлемо в принципе.

Подобные задачи возникают настолько часто, что для них существует специальная форма `GROUP BY`. В этом уроке мы изучим, как работает эта функция.

## GROUP BY

Эта функция группирует строки по определенному признаку и выполняет подсчеты внутри каждой группы независимо от других групп:

```
SELECT user_id, COUNT(*) FROM topics GROUP BY user_id;

 user_id | count
---------+-------
      71 |     1
      80 |     1
      84 |     3
      92 |     1
      60 |     1
      97 |     2
      98 |     1
      44 |     1
      40 |     1
      43 |     1
```

В запросе выше мы создали группы записей по значению поля `user_id`. Эти данные можно представить себе как набор виртуальных таблиц, каждая из которых содержит все записи по одному пользователю. Подсчет количества идет по каждому пользователю независимо от других. К **результатам** такой выборки можно применять **сортировку** и **лимитирование**:

```
SELECT user_id, COUNT(*) FROM topics GROUP BY user_id ORDER BY count DESC LIMIT 3;

 user_id | count
---------+-------
      84 |     3
      97 |     2
      57 |     2
```

С помощью сортировки мы можем обращаться не только к полям самой таблицы, но и к вычисленному значению. По умолчанию имя этого виртуального поля совпадает с именем функции, но его можно изменить с помощью механизма псевдонимов:

```
SELECT user_id, COUNT(*) AS topics_count
  FROM topics
  GROUP BY user_id
  ORDER BY topics_count DESC
  LIMIT 3;
```

Псевдонимы создаются не только для агрегатных значений, но и для любых имен в запросе. Переименовываются даже существующие поля. Общая структура имени выглядит так: `<expression> AS <name>`.

У псевдонимов есть одно удобное свойство. Если определить их в одном месте, они становятся доступны в других частях SQL-запроса:

```
SELECT first_name AS name FROM users ORDER BY name;
```

Теперь попытаемся выполнить следующий запрос:

```
SELECT user_id, created_at, COUNT(*) AS topics_count FROM topics GROUP BY user_id;
```

Запрос завершится с ошибкой:

```
ERROR:  column "topics.created_at" must appear in the GROUP BY clause or be used in an aggregate function
LINE 1: SELECT user_id, created_at, COUNT(*) AS topics_count FROM topics G...
```

Чтобы лучше понять работу `GROUP BY`, разберемся, почему запрос выше не сработает.

Дело в том, что группировка обращается к записям в таблице и создает из них независимые группы записей, по которым проводится анализ.

Группа записей — не то же самое, что одна запись. Мы не можем просто взять и указать имя любого поля — база данных сама не выберет какое-то значение из этой группы. Такое поведение создает неоднозначность и не несет в себе смысла.

СУБД отслеживает такие ошибки и просит выполнить одно из двух действий:

**Действие 1** — указать поле `created_at` в выражении `GROUP BY`. Тогда значение поля для каждой записи из группы будет одинаковым — в этом и суть группировки. Значит, СУБД однозначно определит, что нужно добавить в результат:

```
    SELECT user_id, created_at, COUNT(*) AS topics_count
      FROM topics
      GROUP BY user_id, created_at;

     user_id |       created_at        | topics_count
    ---------+-------------------------+--------------
          40 | 2018-12-05 18:40:05.603 |            1
          67 | 2018-12-06 05:23:40.65  |            1
```

Такой запрос выполнит группировку сначала по `user_id`, а затем по дате создания. Даты создания у всех топиков почти наверняка уникальны, поэтому вся таблица **разобьется на группы по одному элементу**. Смысла в таком запросе не очень много, гораздо полезнее сделать то же самое с разбивкой по дням или месяцам. Тогда можно будет увидеть, сколько топиков создает конкретный пользователь каждый день:

```
-- В этом запросе используется функция EXTRACT,
-- которая извлекает значения из даты: например, номер дня или месяца
SELECT user_id, EXTRACT(day from created_at) AS day, COUNT(*) AS topics_count
FROM topics
GROUP BY user_id, day
ORDER BY user_id;

user_id | day | topics_count
--------+-----+--------------
      1 |   5 |            1
      1 |   6 |            1
      4 |   6 |            1
      6 |   5 |            1
      7 |   6 |            2
      8 |   5 |            1
      9 |   6 |            1
```

**Действие 2** — использовать `created_at` внутри агрегатной функции. В таком случае мы получим результат на основе анализа всех значений в рамках группы. Например, добавление вызова `MAX(created_at)` посчитает дату последнего добавленного топика для каждой группы:

```
SELECT user_id, MAX(created_at), COUNT(*) AS topics_count
FROM topics
GROUP BY user_id;

user_id |           max           | topics_count
--------+-------------------------+--------------
     40 | 2018-12-05 18:40:05.603 |            1
     67 | 2018-12-06 05:23:40.65  |            1
     49 | 2018-12-06 14:55:08.99  |            1
     43 | 2018-12-06 00:20:11.835 |            1
```

## HAVING

Иногда встречаются более сложные ситуации, в которых нужно проводить анализ только по некоторым группам. Предположим, что мы хотим выбрать всех пользователей, у которых количество топиков больше одного. Эта задача сводится к поиску групп, в которых более одной записи.

Подобный запрос невозможно сделать через `WHERE`, потому что эти условия применяются к записям исходной выборки, еще до создания самих групп.

В этой задаче понадобится дополнение к `GROUP BY`, которое называется `HAVING`:

```
SELECT user_id, COUNT(*) FROM topics
  GROUP BY user_id
  HAVING COUNT(*) > 1;

 user_id | count
---------+-------
      84 |     3
      97 |     2
      57 |     2
      30 |     2
      83 |     2
       7 |     2
      38 |     2
       1 |     2
(8 rows)
```

Подчеркнем, что `HAVING` нужен для отбора групп по какому-то агрегатному признаку — например, количеству записей в группе. Если вам надо посмотреть значение конкретного поля, используйте именно `WHERE`.

Группировка — это мощный, но в то же время сложный инструмент, который помогает анализировать данные в таблицах. Не заморачивайтесь над тем, чтобы выучить группировку от и до прямо сейчас. Опытные разработчики пользуются ей не каждый день и сами постоянно подсматривают в документацию.

Важно понимать спектр задач, для которых группировка подходит, а остальное — дело техники и умения читать документацию. Это общее правило, характерное и для многих других аспектов баз данных.

# Соединения (JOINS)

Реляционная модель подразумевает связь между данными разных отношений посредством внешних ключей. С практической точки зрения это можно сформулировать так — зная первичный ключ одной сущности, мы можем извлечь связанные с ней данные из другой сущности.

В простых ситуациях данные извлекаются так:

```
-- Извлекаем все топики пользователя с id = 3
SELECT * FROM topics WHERE user_id = 3;
```

Но есть множество ситуаций, где простой выборкой не обойтись. Для этого нужна операция `JOIN`, которую мы изучим в этом уроке.

## JOIN

Для примера попробуем найти всех пользователей Хекслета, которые ни разу не создавали топики. На текущий момент мы знаем ровно один способ выполнить эту задачу. Нужно выполнить два шага:

1.  Извлечь из базы всех пользователей, которые создали хотя бы один топик:
    
    ```
    SELECT DISTINCT user_id FROM topics;
    ```
    
2.  Найти всех пользователей, у которых идентификаторы не совпадают со списком `user_id`, полученном на предыдущем этапе:
    
    ```
    SELECT * FROM users
      WHERE id NOT IN(<список идентификаторов, полученный предыдущим запросом>);
    ```
    

Задача будет решена, но есть одна проблема. Идентификаторов может быть очень много. Гонять такое количество записей из базы в код и обратно — не самая разумная идея.

## INNER JOIN

Теперь рассмотрим следующую задачу — найти записи о пользователях в одной таблице, для которых нет записей о топиках в другой таблице.

Реляционная алгебра позволяет выполнить эту операцию с помощью соединения `JOIN`, используя ровно один запрос. Начнем знакомство с `JOIN` на таком примере:

```
-- В выборке участвуют не все поля только для того, чтобы уместить
-- ее на экран, а вообще здесь можно использовать `*`
SELECT first_name, title
  FROM users JOIN topics ON users.id = topics.user_id LIMIT 5;

 first_name |            title
------------+------------------------------
 Sean       | beatae voluptatem commodi
 Wyatt      | tempora accusamus nostrum
 Oleta      | eaque fugiat consequatur
 Brandon    | aut exercitationem expedita
 Domenica   | voluptatem soluta similique
```

Результатом такого запроса станет выборка, в которую попали поля обеих таблиц. Здесь соединяются две таблицы: `users` и `topics` по условию `users.id = topics.user_id`. Это важное условие для правильной работы.

В нашем примере отношения связаны внешним ключом: соответственно, при объединении этих таблиц нужно явно указать, как мы их соединяем. Общий синтаксис выглядит так:

```
SELECT * FROM table1 JOIN table2 ON table1.id_field_name = table2.id_field_name
```

На самом деле общая форма сложнее, потому что объединять можно произвольное число таблиц. Другими словами, условий соединения может быть много.

`JOIN` — это сокращенная версия соединения `INNER JOIN`, то есть внутреннего соединения.

В эту выборку попадают только те записи, для которых есть соответствие в другой таблице. Причем, если у одного пользователя пять топиков, то в выборке окажутся все пять строк. Такой запрос имеет смысл делать на странице вывода топиков, что позволит к каждому топику сразу же вывести нужную информацию и о самом пользователе.

Запросы с соединениями порождают одну небольшую проблему. В примере выше часть `SELECT` содержит только те поля, имена которых уникальны среди всех полей обеих таблиц. Соответственно, при выборке не возникает неоднозначностей.

Если выполнить этот же запрос со звездочкой, то в выборку попадут поля, у которых одинаковые названия, что создаст сложности при анализе данных уже в коде приложения. А при выполнении запроса с указанием дублирующихся полей вообще возникнет ошибка:

```
SELECT id FROM users JOIN topics ON users.id = topics.user_id LIMIT 5;
ERROR:  column reference "id" is ambiguous
LINE 1: SELECT id FROM users JOIN topics ON users.id = topics.user_i...
```

В таких случаях спасают псевдонимы и возможность указывать таблицу для каждого поля:

```
SELECT users.id AS user_id, topics.id AS topic_id
  FROM users JOIN topics ON users.id = topics.user_id LIMIT 5;

 user_id | topic_id
---------+----------
       9 |        1
      33 |        2
      43 |        3
      49 |        4
      10 |        5
(5 rows)
```

## LEFT JOIN

Пока мы все еще не можем решить нашу исходную задачу. Для этого понадобится операция левого соединения `LEFT JOIN`:

![Left Join](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjJmY2JlNTM2YWFmMDBlZTNjNWI5NDRjYmEzNTJhYjc3LnBuZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=33abdcd6bdf45721bfa2d6fb08a2641cca41d38d516b9bf0f6f3150faa8a1fa2)

`LEFT JOIN` берет все данные из одной таблицы и присоединяет к ним данные из другой, если они присутствуют. Если нет, то заполняет их `NULL`. Чисто технически этот запрос отличается только тем, что добавляется слово `LEFT`:

```
SELECT first_name, title FROM users
  LEFT JOIN topics ON users.id = topics.user_id LIMIT 5;

first_name |            title
------------+------------------------------
 Sean       | beatae voluptatem commodi
 Wyatt      | tempora accusamus nostrum
 Mia        |
 Royal      |
 Enos       | et eos dicta
```

`LEFT JOIN` полезен, когда нам нужно работать со всеми данными одной таблицы и связанными с ними записями, если они есть. Если их нет, то ничего страшного, мы все равно хотим получить данные из первой таблицы.

Этот запрос все еще не возвращает нам то, что мы хотели изначально — записи о пользователях, которые не оставили ни одного топика на Хекслете. Чтобы закончить решение, нужно добавить в выборку условие `WHERE`:

```
SELECT COUNT(*)
  FROM users
  LEFT JOIN topics ON users.id = topics.user_id
  WHERE title IS NULL;

 count
-------
    59
(1 row)
```

# Транзакционность—Основы реляционных баз данных


Не все операции с базой данных можно выразить одним запросом. Например, так нельзя сделать с транзакцией, когда нужно перевести деньги с одного счета на другой. В этом уроке разберем, как выполнять запросы внутри транзакции. Также узнаем, какие существуют требования к транзакционной системе, чтобы она оставалась надежной.

## Запросы внутри транзакции

Допустим, у нас есть таблица счетов _accounts_, в которой две записи:

Процесс перевода можно представить так:

1.  Получаем количество денег пользователя:
    
    ```
    SELECT amount FROM accounts WHERE user_id = 10;
    ```
    
2.  Списываем необходимую сумму со счета этого пользователя:
    
    ```
    UPDATE accounts SET amount = amount — 50 WHERE user_id = 10;
    ```
    
3.  Зачисляем деньги другому пользователю:
    
    ```
    UPDATE accounts SET amount = amount + 50 WHERE user_id = 30;
    ```
    

Одна из проблем в этом процессе — отсутствует гарантия завершения. Представим, что система успела выполнить списание, и в этот момент произошла ошибка, например, выключили питание или компьютер перезагрузился. В результате получится странная ситуация: деньги списались, но никуда не зачислились:

Такое может произойти не только с деньгами, но и в большинстве других ситуаций. Приложения по возможности должны находиться в согласованном состоянии. В распределенных системах это невозможно, добиться этого можно с помощью механизма **транзакций**. Мы не будем подробно разбирать эту тему, но вы можете узнать о ней больше, изучив [CAP-теорему](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_CAP) и [Eventual Consistency](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D0%B3%D0%BB%D0%B0%D1%81%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D1%8C_%D0%B2_%D0%BA%D0%BE%D0%BD%D0%B5%D1%87%D0%BD%D0%BE%D0%BC_%D1%81%D1%87%D1%91%D1%82%D0%B5).

Транзакции используют не только в базах данных, но и в обычной жизни. Например, операция снятия денег в банкомате — это бизнес-транзакция. Пользователи банкомата ожидают, что эта операция либо снимет деньги, либо нет, и банкомат это обеспечивает.

Операция снятия денег — это процесс, который приводит не только к множеству запросов в базу данных, но и к затрагиванию многих систем. У них есть свои процессы и базы данных внутри.

Мы ожидаем от любой подобной транзакции **атомарность** — когда операция либо завершается успешно, либо не проходит. Транзакции в базе данных в этом смысле проще, чем бизнес-транзакции. За обеспечением необходимых гарантий следит сама СУБД, а не программист:

```
BEGIN;
SELECT amount FROM accounts WHERE user_id = 10;
UPDATE accounts SET amount = amount — 50 WHERE user_id = 10;
UPDATE accounts SET amount = amount + 50 WHERE user_id = 30;
COMMIT;
```

Транзакции в PostgreSQL — это блок запросов, который обрамляется запросами:

-   `BEGIN` — открытие транзакции
    
-   `COMMIT` — закрытие транзакции
    

Любая ошибка внутри транзакции откатывает все изменения, которые были сделаны после запроса `BEGIN`:

![Обработка транзакций](https://cdn2.hexlet.io/derivations/image/original/eyJpZCI6IjZkY2FlNWQzMzAwZjY3OTlkZWVhMTQ1NTM5OTYxOGI2LmpwZyIsInN0b3JhZ2UiOiJjYWNoZSJ9?signature=a018a6c8a9ab5580967ee63951a3e7353c1ead417955804f6f08b6933c86a16d)

Если нужно, транзакцию можно откатить самостоятельно. Для этого необходимо выполнить запрос `ROLLBACK` до `COMMIT`. Это нужно, когда выполняются запросы из кода приложения.

```
BEGIN;
UPDATE accounts SET amount = amount — 50 WHERE user_id = 10;
ROLLBACK;
```

Также, чтобы транзакция была надежной и предсказуемой, нужно соблюдать определенные требования.

## Требования к транзакционной системе

В информатике есть набор требований к транзакционной системе, которые гарантируют ее надежность — **ACID**. К ним относятся:

-   Atomicity (Атомарность)
-   Consistency (Согласованность)
-   Isolation (Изолированность)
-   Durability (Устойчивость)

Разберем каждое требование подробнее

### Atomicity (Атомарность)

Любая транзакция не может быть частично завершена — она либо выполнена, либо нет.

### Consistency (Согласованность)

Завершившаяся транзакция должна сохранять согласованность базы данных. Каждая успешная транзакция фиксирует только допустимые результаты, при том, что в процессе работы транзакции данные могут оказываться несогласованными.

В примере выше снятие денег с одного счета приводит к тому, что данные рассинхронизированы. Но когда транзакция завершается, этого нет.

Гарантию согласованности данных нельзя полностью обеспечить только средствами базы данных, например, различными ограничениями. Поддержка этого требования включает в себя работу со стороны программистов, которые пишут необходимый для этого код.

### Isolation (Изолированность)

Когда транзакция выполняется, параллельные транзакции не должны оказывать влияния на ее результат. Ни одна транзакция не может увидеть изменения, которые сделаны другими незавершенными транзакциями. Изолированность — дорогое требование, поэтому в реальных БД существуют режимы, которые изолируют транзакцию не полностью — уровни изолированности Repeatable Read и ниже.

### Durability (Устойчивость)

Изменения, которые сделаны успешно завершенной транзакцией, должны остаться сохраненными после возвращения системы в работу. И это не должно зависеть от проблем на нижних уровнях, к примеру, обесточивание системы или сбои в оборудовании. Если пользователь получил подтверждение от системы, что транзакция выполнена, он будет уверен, что ничего не отменится из-за какого-либо сбоя.

# Производительность


Вопрос производительности базы данных и запросов к ней с течением времени становится все актуальнее. Чем больше проект и данных в таблицах и сложнее связи, тем выше вероятность столкнуться с медленной работой и нежелательными блокировками.

Подобные вопросы редко касаются новичков. Но нужно знать, как работать с такими проблемами, так как в будущем с ними предстоит столкнуться. Поэтому в этом уроке разберем основные направления производительности базы данных.

## EXPLAIN

SQL — это декларативный язык, то есть им мы описываем **ЧТО** хотим получить, а не **КАК**. Но это не устраивает машину, так как СУБД должна знать, каким образом добраться до этих данных.

В СУБД реализована подсистема, которая называется **планировщик** или **scheduler**. Она строит **план запроса** — описывает, как будут извлекаться данные, которые хранятся внутри базы. Когда планировщик строит план, он учитывает множество факторов — например, статистику обращений или информацию о количестве данных в таблицах.

Результат работы планировщика можно посмотреть командой `EXPLAIN`:

```
EXPLAIN SELECT * FROM users
  JOIN topics ON users.id = topics.user_id
  WHERE users.created_at > '10.10.2018';

                                       QUERY PLAN
-----------------------------------------------------------------------------------------
 Hash Join  (cost=10.66..23.59 rows=42 width=2377)
   Hash Cond: (topics.user_id = users.id)
   ->  Seq Scan on topics  (cost=0.00..11.30 rows=130 width=572)
   ->  Hash  (cost=10.50..10.50 rows=13 width=1805)
         ->  Seq Scan on users  (cost=0.00..10.50 rows=13 width=1805)
               Filter: (created_at > '2018-10-10 00:00:00'::timestamp without time zone)
(6 rows)
```

Выполнение запроса идет изнутри наружу, начиная с самого сдвинутого блока. Каждая операция начинается со стрелки _->_. Затем данные, полученные на этих шагах, передаются выше — и так до самого верха. В примере выше последовательность такая: _Seq Scan_ -> _Hash_ -> _Seq Scan_. Подробнее про план читайте в статье [Производительность запросов в PostgreSQL — шаг за шагом](https://habr.com/company/oleg-bunin/blog/319018/).

## Индексы

План запроса можно использовать по-разному, например: переписать или разбить запрос на более эффективный. Некоторые запросы уже достаточно оптимизированы, поэтому для их ускорения используют **индексы** — специальную структуру внутри базы данных, которая создается, чтобы ускорить поиск. Индекс в базе данных подобен предметному указателю в любой книге:

```
-- Пример создания индекса по полю birthday таблицы users
CREATE INDEX ON users(birthday);
```

Этот запрос создает индекс на таблице `users` по полю `birthday`. Теперь запросы с условием или сортировкой по `birthday` будут работать быстрее за счет использования индекса во время подготовки данных. Пример:

```
SELECT * from users WHERE birthday = '2000-01-01';
```

Создание индекса не гарантирует эффективности. Многое зависит от того, правильный ли индекс создан, сколько данных в таблице, какие запросы выполняются к этой таблице, сколько уже индексов было.

В PostgreSQL встроено шесть разных видов индексов, которые подходят под разные ситуации. Для работы с ними нужно понимать несколько вещей:

-   Устройство индексов. Здесь не обойтись без знания **структур данных и алгоритмов**. В первую очередь речь идет про **сбалансированные деревья** — btree
-   Классификацию видов запросов. Например, запрос по диапазону или запрос с применением `LIKE` оператора — разные виды запросов, которые по-разному работают и оптимизируются
-   Влияние различных конструкций SQL на план запроса. Например, `ORDER BY` — дорогая операция, которая часто приводит к полному перебору таблицы

## Денормализация

Еще один подход для оптимизации называется **денормализацией** — процесс, обратный нормализации. В реляционной теории такого понятия нет и оно противоречит ее идеям. Но на практике этот способ активно применяется, так как за счет избыточности позволяет упростить запросы, так как данные ближе и их легче извлечь.

Цена за денормализацию — дополнительный объем и иногда необходимость производить синхронизацию данных самостоятельно. Например, мы можем хранить имя пользователя в разных таблицах, что создает сложности, когда оно изменяется. Поэтому его нужно поменять во всех таблицах, где оно используется. Денормализация значительно сокращает число запросов с соединениями — joins.

Производительность базы данных — серьезная тема, поэтому ей посвящена не одна книга. В этом уроке мы разобрали основные направления, а остальное сможете познать на практике.


#### Дополнительные материалы

1.  [Типы индексов в PostgreSQL](https://postgrespro.ru/docs/postgresql/15/indexes-types)
2.  [B-дерево](https://ru.wikipedia.org/wiki/B-%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE)
3.  [Продуманная оптимизация](http://optimization.guide/)
4. [# Производительность запросов в PostgreSQL – шаг за шагом](https://habr.com/ru/company/oleg-bunin/blog/319018/)
5. [# Основы реляционной алгебры](https://habr.com/ru/post/145381/)